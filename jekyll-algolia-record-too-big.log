{
  "html": "<p>## Introduction\n\nThis is a basic overview of homotopy type theory (HoTT) formalized in Agda. It's\nonly one file and has been type-checked by Agda 2.5.4. No other libraries are\nrequired to type-check this file.\n\n{: .only-website }\n\n  **URL link**: [https://tinyurl.com/mini-hott](https://tinyurl.com/mini-hott).\n\nTo be consistent with homotopy type theory, we tell Agda to not use Axiom K for\ntype-checking by using the option `without-K`. Without Axiom K, Agda's `Set` is\nnot a good name for universes in HoTT and we rename `Set` to `Type`.\n\nThis code is working in progress and it's for my own learning purposes.\nPlease check out the references at the end of this article.\n\n\\begin{code}\n{-# OPTIONS --without-K #-}\n\nopen import Agda.Primitive using ( Level ; lsuc; lzero; _⊔_ ) public\n\nType : (ℓ : Level) → Set (lsuc ℓ)\nType ℓ = Set ℓ\n\nType₀ : Type (lsuc lzero)\nType₀ = Type lzero\n\\end{code}\n\n## Basic types\n\n### Empty type\n\nThe Empty type, representing falsehood.\n\n\\begin{code}\n-- A datatype without constructors is the empty type.\ndata ⊥ {ℓᵢ} : Type ℓᵢ where\n\n-- synonyms of ⊥\nEmpty = ⊥\n𝟘     = ⊥\n\\end{code}\n\nIts eliminator:\n\n\\begin{code}\n-- Ex falso quodlibet\nexfalso\n  : ∀ {ℓ ℓᵢ} {A : Type ℓ} → ⊥ {ℓᵢ} → A\n\nexfalso ()\n\n-- synonyms of exfalso\nEmpty-elim = exfalso\n⊥-elim     = exfalso\n\\end{code}\n\nA useful convention\n\\begin{code}\n-- Negation\n¬\n  : ∀ {ℓ} → Type ℓ → Type ℓ\n\n¬ A = (A → ⊥ {lzero})\n\\end{code}\n\n### Unit type\n\nThe unit type is defined as record so that we also get the η-rule\ndefinitionally.\n\nNo elimination rule.\n\\begin{code}\nrecord ⊤ : Type₀ where\n  constructor ★\n\n{-# BUILTIN UNIT ⊤ #-}\n\n-- synonyms for the data constructor\nunit = ★\n\n-- synonyms for the Unit type\nUnit = ⊤\n𝟙    = ⊤\n\\end{code}\n\n### Σ-type\n\nSigma types are a particular case of records, but records can be constructed\nusing only sigma types. Note that l ⊔ q is the maximum of two hierarchy levels l\nand q. This way, we define sigma types in full generality, at each universe.\n\n\\begin{code}\ninfixr 60 _,_\nrecord Σ {ℓᵢ ℓⱼ} (A : Type ℓᵢ)(C : A → Type ℓⱼ) : Type (ℓᵢ ⊔ ℓⱼ) where\n  constructor _,_\n  field\n    π₁ : A\n    π₂ : C π₁\n\n  -- synonyms for data constructors\n  proj₁ = π₁\n  proj₂ = π₂\n  fst   = π₁\n  snd   = π₂\nopen Σ public\n\\end{code}\n\n### Π-types\nShorter notation for Π-types.\n\n\\begin{code}\nΠ\n  : ∀ {ℓᵢ ℓⱼ}\n  → (A : Type ℓᵢ) (P : A → Type ℓⱼ)\n  --------------------------------\n  → Type (ℓᵢ ⊔ ℓⱼ)\n\nΠ A P = (x : A) → P x\n\\end{code}\n\n### Product type\n\nProduct type as a particular case of the sigma\n\n\\begin{code}\n_×_\n  : ∀ {ℓᵢ ℓⱼ}\n  → (A : Type ℓᵢ) (B : Type ℓⱼ)\n  ----------------------------\n  → Type (ℓᵢ ⊔ ℓⱼ)\n\nA × B = Σ A (λ _ → B)\n\\end{code}\n\n### Coproduct\n\nSum types as inductive types\n\n\\begin{code}\ninfixr 80 _+_\ndata _+_ {ℓᵢ ℓⱼ} (A : Type ℓᵢ) (B : Type ℓⱼ) : Type (ℓᵢ ⊔ ℓⱼ) where\n  inl : A → A + B\n  inr : B → A + B\n\\end{code}\n\n### Boolean\n\nBoolean type, two constants true and false\n\n\\begin{code}\ndata Bool : Type₀ where\n  true  : Bool\n  false : Bool\n\\end{code}\n\n*Booleans can be also defined using the coproduct.*\n\n### Natural numbers\n\nNatural numbers are the initial algebra for a constant and a\nsuccessor function. The `BUILTIN` declaration allows us to use\nnatural numbers in Arabic notation.\n\n\\begin{code}\ndata ℕ : Type₀ where\n  zero : ℕ\n  succ : ℕ → ℕ\n\n{-# BUILTIN NATURAL ℕ #-}\n\n-- synonyms for natural numbers\nNat = ℕ\n\\end{code}\n\n## Functions\n\n### Identity function\n\nThe identity function with implicit type.\n\\begin{code}\nid\n  : ∀ {ℓ} {A : Type ℓ}\n  → A → A\n\nid = λ x → x\n\\end{code}\n\nThe identity function on a type `A` is `idf A`.\n\n\\begin{code}\nidf\n  : ∀ {ℓᵢ}\n  → (A : Type ℓᵢ)\n  ---------------\n  → (A → A)\n\nidf A = λ x → x\n\\end{code}\n\n### Constant function\n\nConstant function at some point `b` is `cst b`\n\n\\begin{code}\ncst\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ}\n  → (b : B)\n  ---------\n  → (A → B)\n\ncst b = λ _ → b\n\\end{code}\n\n### Composition\n\nA more sophisticated composition function that can handle dependent functions.\n\n\\begin{code}\n_∘_\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : A → Type ℓⱼ} {C : (a : A) → (B a → Type ℓₖ)}\n  → (g : {a : A} → Π (B a) (C a))\n  → (f : Π A B)\n  -------------------------------\n  → Π A (λ a → C a (f a))\n\ng ∘ f = λ x → g (f x)\ninfixr 80 _∘_\n\\end{code}\n\nSynonym for composition (diagrammatic version)\n\\begin{code}\n_//_\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : A → Type ℓⱼ} {C : (a : A) → (B a → Type ℓₖ)}\n  → (f : Π A B)\n  → (g : {a : A} → Π (B a) (C a))\n  -------------------------------\n  → Π A (λ a → C a (f a))\n\nf // g = g ∘ f\n\\end{code}\n\n### Application\n\n\\begin{code}\ninfixr 0 _$_\n_$_\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : A → Type ℓⱼ}\n  → (∀ x → B x)\n  -------------\n  → (∀ x → B x)\n\nf $ x = f x\n\\end{code}\n\n### Curryfication\n\n\\begin{code}\ncurry\n  : ∀ {i j k} {A : Type i} {B : A → Type j} {C : Σ A B → Type k}\n  → (∀ s → C s)\n  ---------------------\n  → (∀ x y → C (x , y))\n\ncurry f x y = f (x , y)\n\\end{code}\n\n### Uncurryfication\n\n\\begin{code}\nuncurry\n  : ∀ {i j k} {A : Type i} {B : A → Type j} {C : ∀ x → B x → Type k}\n  → (∀ x y → C x y)\n  -------------------------\n  → (∀ s → C (π₁ s) (π₂ s))\n\nuncurry f (x , y) = f x y\n\\end{code}\n\n### Instance search\n\n\\begin{code}\n-- how to use it ❓\n⟨⟩\n  : ∀ {i} {A : Type i}  → A\n\n⟨⟩  = a\n\\end{code}\n\n## Equality type\n\nIn HoTT, we have a different interpretation of type theory in which the\nset-theoretical notion of *sets* for *types* is replaced by the topological\nnotion of *spaces*. A type judgment like `x : A` means that the point `x`‌‌ is\n*in* the topological space `A`‌‌. Furthermore, we include the *Identity type* as\na primary type. The inhabitants of these identity types will not be longer\ninterpreted as *proofs of equalities* but as *paths* in a Path space, an\nIdentity type.\n\n### Homogeneous equality\n\nThe Identity type is defined as an inductive type. Its induction principle is\nthe J-eliminator.\n\n\\begin{code}\ndata _==_ {ℓᵢ} {A : Type ℓᵢ} (a : A) : A → Type ℓᵢ where\n  idp : a == a\n\ninfix 30 _==_\n{-# BUILTIN EQUALITY _==_ #-}\n\n-- synonyms for identity type\nPath = _==_\n\\end{code}\n\n\\begin{code}\nrefl\n  : ∀ {ℓᵢ} {A : Type ℓᵢ}\n  → (a : A)\n  ---------\n  → a == a\n\nrefl {ℓᵢ}{A} a = idp {ℓᵢ = ℓᵢ}{A = A}\n\\end{code}\n\n#### J eliminator\n\nThe elimination principle for the identity type is the path induction. It allows\nus to define an outgoing function from the identity type to a dependent type ‌‌\nas we see in the `J` definition below.\n\n*Paulin-Mohring J rule*\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {a : A}\n  → (B : (a' : A) (p : a == a') → Type ℓⱼ)\n  → (d : B a idp)\n  ----------------------------------------\n  → {a' : A} (p : a == a') → B a' p\n\nJ {a = a} B d idp = d\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ'\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {a : A}\n  → (B : (a' : A) (p : a' == a) → Type ℓⱼ)\n  → (d : B a idp)\n  ----------------------------------------\n  → {a' : A} (p : a' == a) → B a' p\n\nJ' {a = a} B d idp = d\n\\end{code}\n\n#### Composition of paths\n\n{: .foldable until=\"6\" }\n\\begin{code}\n_·_\n  : ∀ {ℓ} {A : Type ℓ} {x y z : A}\n  → (p : x == y)\n  → (q : y == z)\n  --------------\n  → x == z\n\n_·_ idp q = q\n\ninfixl 50 _·_\n\\end{code}\n\n![path](/assets/ipe-images/path-concatenation.png){: width=\"60%\" }\n\n#### Inverse of paths\n\n\\begin{code}\ninv\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → a == b\n  --------\n  → b == a\n\ninv idp = idp\n\n-- synonyms for inverse path\ninfixl 60 _⁻¹\n_⁻¹ = inv\n\ninfixr 60 !_\n!_  = inv\n\\end{code}\n\n#### Associativity of composition\n\n- Left associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\n∘-lassoc\n  : ∀ {ℓ} {A B C D : Type ℓ}\n  → (h : C → D) → (g : B → C) → (f : A → B)\n  -----------------------------------------\n  → (h ∘ (g ∘ f)) == ((h ∘ g) ∘ f)\n\n∘-lassoc h g f = idp {a = (λ x → h (g (f x)))}\n\\end{code}\n\n- Right associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\n∘-rassoc\n  : ∀ {ℓ} {A B C D : Type ℓ}\n  → (h : C → D) → (g : B → C) → (f : A → B)\n  -----------------------------------------\n  → ((h ∘ g) ∘ f) == (h ∘ (g ∘ f))\n\n∘-rassoc h g f = (∘-lassoc h g f) ⁻¹\n\\end{code}\n\n### Heterogeneous equality\n\n\\begin{code}\ndata HEq {ℓ} (A : Type ℓ)\n           : (B : Type ℓ)\n           → (α : A == B) (a : A) (b : B)\n           → Type ℓ where\n  idp : ∀ {a : A} → HEq A A idp a a\n\\end{code}\n\n## Equational reasoning\n\nEquational reasoning is a way to write readable chains of equalities.\n\n\n```agda\n  t : a == e\n  t = a =⟨ p ⟩\n      b =⟨ q ⟩\n      c =⟨ r ⟩\n      d =⟨ s ⟩\n      e ∎\n```\n\n\nwhere `p` is a path from `a` to `b`, `q` is a path from `b` to `c`, and so on.\n\n\\begin{code}\nmodule EquationalReasoning {ℓᵢ} {A : Type ℓᵢ} where\n\\end{code}\n\nDefinitional equals:\n\n\\begin{code}\n  _==⟨⟩_\n    : ∀ (x {y} : A)\n    → x == y → x == y\n\n  _ ==⟨⟩ p = p\n\n  -- synonyms for _==⟨⟩\n  _==⟨idp⟩_  = _==⟨⟩_\n  _==⟨refl⟩_ = _==⟨⟩_\n\n  infixr 2 _==⟨⟩_\n\\end{code}\n\n\\begin{code}\n  -- chain\n  _==⟨_⟩_\n    : (x : A) {y z : A}\n    → x == y\n    → y == z\n    → x == z\n\n  _ ==⟨ thm ⟩ q = thm · q\n\n  infixr 2 _==⟨_⟩_\n\\end{code}\n\n\\begin{code}\n  -- Q.E.D\n  infix 3 _∎\n  _∎\n    : (x : A)\n    → x == x\n\n  _∎ = λ x → idp\n\\end{code}\n\n\\begin{code}\n  -- Begin\n  infix 1 begin_\n  begin_\n    : {x y : A}\n    → x == y\n    → x == y\n\n  begin_ p = p\n\\end{code}\n\n\\begin{code}\nopen EquationalReasoning public\n\\end{code}\n## Actions on paths\n\nFunctions are functors to equalities.  In other words, functions\npreserve equalities.\n\n{: .foldable until=\"6\" }\n\\begin{code}\nap\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ}\n  → (f : A → B) {a₁ a₂ : A}\n  → a₁ == a₂\n  --------------\n  → f a₁ == f a₂\n\nap f idp = idp\n\\end{code}\n\nNow, we can define a convenient syntax sugar for `ap` in\nequational reasoning.\n\n\\begin{code}\ninfixl 40 ap\nsyntax ap f p = p |in-ctx f\n\\end{code}\n\nLet's suppose we have a lemma:\n\n```agda\n  lemma : a == b\n  lemma = _\n```\n\nused in an equational reasoning like:\n\n```agda\n  t : a == e\n  t = f a =⟨ ap f lemma ⟩\n      f b\n      ∎\n```\n\n\nThen, we can now put the lemma in front:\n\n```agda\n  t : a == e\n  t = f a =⟨ lemma |in-ctx f ⟩\n      f b\n      ∎\n```\n\n\nLastly, we can also define actions on two paths:\n\n{: .foldable until=\"7\" }\n\\begin{code}\nap₂\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {C : Type ℓₖ}  {b₁ b₂ : B}\n  → (f : A → B → C)\n  → {a₁ a₂ : A} → (a₁ == a₂)\n  → {b₁ b₂ : B} → (b₁ == b₂)\n  --------------------------\n  → f a₁ b₁  == f a₂ b₂\n\nap₂ f idp idp = idp\n\\end{code}\n\n### Lemmas\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-·\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {a b c : A}\n  → (f : A → B) → (p : a == b) → (q : b == c)\n  -------------------------------------------\n  → ap f (p · q) == ap f p · ap f q\n\nap-· f idp q = refl (ap f q)\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-inv\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {a b : A}\n  → (f : A → B) → (p : a == b)\n  ----------------------------\n  → ap f (p ⁻¹) == (ap f p) ⁻¹\n\nap-inv f idp = idp\n\n-- synonyms\nap-! = ap-inv\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\nap-comp\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {C : Type ℓₖ} {a b : A}\n  → (f : A → B)\n  → (g : B → C)\n  → (p : a == b)\n  -------------------------------\n  → ap g (ap f p) == ap (g ∘ f) p\n\nap-comp f g idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-id\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a b : A}\n  → (p : a == b)\n  --------------\n  → ap id p == p\n\nap-id idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-const\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {C : Type ℓⱼ} {a b : A} {c : C}\n  → (p : a == b)\n  -----------------------\n  → ap (λ _ → c) p == idp\n\nap-const {c = c} idp = refl (refl c)\n\\end{code}\n\n## Properties on the groupoid\n\nSome properties on the groupoid structure of equalities\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-runit\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  --------------\n  → p == p · idp\n\n·-runit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-lunit\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  --------------\n  → p == idp · p\n\n·-lunit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-linv\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  ----------------\n  → ! p · p == idp\n\n·-linv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-rinv\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  ----------------\n  → p · ! p == idp\n\n·-rinv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ninvolution\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → {p : a == b}\n  ---------------\n  → ! (! p) == p\n\ninvolution {p = idp} = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-assoc\n  : ∀ {ℓ} {A : Type ℓ} {a b c d : A}\n  → (p : a == b) → (q : b == c) → (r : c == d)\n  --------------------------------------------\n  → p · q · r == p · (q · r)\n\n·-assoc idp q r = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\n·-cancellation\n  : ∀ {ℓ} {A : Type ℓ} {a : A}\n  → (p : a == a) → (q : a == a)\n  → p · q == p\n  -----------------------------\n  → q == refl a\n\n·-cancellation {a = a} p q α =\n    begin\n      q             ==⟨ ap (_· q) (! (·-linv p)) ⟩\n      ! p · p · q   ==⟨ (·-assoc (! p) _ _) ⟩\n      ! p · (p · q) ==⟨ (ap (! p ·_) α) ⟩\n      ! p · p       ==⟨ ·-linv p ⟩\n      refl a\n    ∎\n\\end{code}\n\nMoving a term from one side to the other is a common task,\nso let's define some handy functions for that.\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-left-to-right-l\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  → p · q == r\n  ------------------\n  →     q == ! p · r\n\n·-left-to-right-l {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    q\n      ==⟨ ·-lunit q ⟩\n    refl b · q\n      ==⟨ ap (_· q) (! (·-linv p)) ⟩\n    (! p · p) · q\n      ==⟨ ·-assoc (! p) p q ⟩\n    ! p · (p · q)\n      ==⟨ ap (! p ·_) α ⟩\n    ! p · r\n  ∎\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-left-to-right-r\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  → p · q == r\n  -------------------\n  →      p == r · ! q\n\n·-left-to-right-r {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    p\n      ==⟨ ·-runit p ⟩\n    p · refl b\n      ==⟨ ap (p ·_) (! (·-rinv q)) ⟩\n    p · (q · ! q)\n      ==⟨ ! (·-assoc p q (! q)) ⟩\n    (p · q) · ! q\n      ==⟨ ap (_· ! q) α ⟩\n    r · ! q\n  ∎\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-right-to-left-r\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  →       p == q · r\n  -------------------\n  → p · ! r == q\n\n·-right-to-left-r {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    p · ! r\n      ==⟨ ap (_· ! r) α ⟩\n    (q · r) · ! r\n      ==⟨ ·-assoc q r (! r) ⟩\n    q · (r · ! r)\n      ==⟨ ap (q ·_) (·-rinv r) ⟩\n    q · refl b\n      ==⟨ ! (·-runit q) ⟩\n    q\n    ∎\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-right-to-left-l\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  →       p == q · r\n  ------------------\n  → ! q · p == r\n\n·-right-to-left-l {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    ! q · p\n      ==⟨ ap (! q ·_) α ⟩\n    ! q · (q · r)\n      ==⟨ ! (·-assoc (! q) q r) ⟩\n    ! q · q · r\n      ==⟨ ap (_· r) (·-linv q) ⟩\n    refl b · r\n      ==⟨ ! (·-lunit r) ⟩\n    r\n  ∎\n\\end{code}\n\nFinally, when we invert a path composition this is what we got.\n\n{: .foldable until=\"6\" }\n\\begin{code}\n!-·\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  → (q : b == a)\n  --------------------------\n  → ! (p · q) == ! q · ! p\n\n!-· idp q = ·-runit (! q)\n\\end{code}\n\n## Transport\n\n![path](/assets/ipe-images/transport-fiber-minihott.png){: width=\"60%\" }\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ}\n  → (C : A → Type ℓⱼ) {a₁ a₂ : A}\n  → (p : a₁ == a₂)\n  -------------------------------\n  → (C a₁ → C a₂)\n\ntransport C idp = (λ x → x)\n\\end{code}\n\n\\begin{code}\n-- synonyms\ntr     = transport\ntransp = transport\n\\end{code}\n\nStar notation for transport\n\n{: .foldable until=\"5\" }\n\\begin{code}\n_✶\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {C : A → Type ℓⱼ} {a₁ a₂ : A}\n  → (p : a₁ == a₂)\n  ----------------\n  → (C a₁ → C a₂)\n\n_✶ {ℓᵢ}{ℓⱼ}{C = C} = transport {ℓᵢ = ℓᵢ} {ℓⱼ = ℓⱼ} C\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ncoe\n  : ∀ {ℓ} {A B : Type ℓ}\n  → A == B\n  ---------\n  → (A → B)\n\ncoe p A = transport (λ X → X) p A\n\\end{code}\n\n### Pathover\n\nLet be `A : Type`, `a₁, a₂ : A`, `C : A → Type`, `c₁ : C a₁` and `c₂ : C a₂`.\nUsing the same notation from <a href=\"#hottbook\">(Univalent Foundations Program, 2013)</a>, one of the definitions for the\nPathover type is as the shorthand for the path between the transport along a\npath `α : a₁ = a₂` of the point `c₁ : C a₁` and the point `c₂` in the fiber `C\na₂`. That is, a pathover is a term that inhabit the type `transport C α c₁ = c₂`\nalso denoted by `PathOver C α c₁ c₂`.\n\n![path](/assets/ipe-images/pathover-3-minihott.png){: width=\"60%\" }\n\n\\begin{code}\nPathOver\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ}(C : A → Type ℓⱼ) {a₁ a₂ : A}\n  → (α : a₁ == a₂) (c₁ : C a₁) (c₂ : C a₂)\n  ----------------------------------------\n  → Type ℓⱼ\n\nPathOver C α c₁ c₂ = tr C α c₁ == c₂\n\\end{code}\n\n\\begin{code}\ninfix 30 PathOver\nsyntax PathOver B p u v = u == v [ B ↓ p ]\n\\end{code}\n\n### Lemmas\n\nSome lemmas on the transport operation\n\n{: .foldable until=\"6\" }\n\\begin{code}\nlift\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a₁ a₂ : A} {ℓⱼ} {C : A → Type ℓⱼ}\n  → (u : C a₁)\n  → (α : a₁ == a₂)\n  -----------------------------\n  → (a₁ , u) == (a₂ , tr C α u)\n\nlift {a₁ = a₁} u idp = refl (a₁ , u)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-const\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a₁  a₂ : A} {ℓⱼ} {B : Type ℓⱼ}\n  → (p : a₁ == a₂)\n  → (b : B)\n  -----------------------\n  → tr (λ _ → B) p b == b\n\ntransport-const idp b = refl b\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-r\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a : A} {x y : A}\n  → (p : x == y)\n  → (q : a == x)\n  ---------------------------------\n  →  tr (λ x → a == x) p q == q · p\n\ntransport-concat-r idp q = ·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-l\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a : A} {x y : A}\n  → (p : x == y)\n  → (q : x == a)\n  ----------------------------------\n  → tr (λ x → x == a) p q == ! p · q\n\ntransport-concat-l idp q = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {x y : A}\n  → (p : x == y)\n  → (q : x == x)\n  ---------------------------------------\n  → tr (λ x → x == x) p q == ! p · q · p\n\ntransport-concat idp q = ·-runit q\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {ℓⱼ} {B : Type ℓⱼ}\n  → (f g : A → B) {x y : A}\n  → (p : x == y)\n  → (q : f x == g x)\n  --------------------------------------------------------\n  → tr (λ z → f z == g z) p q == ! (ap f p) · q · (ap g p)\n\ntransport-eq-fun f g idp q = ·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-comp\n  : ∀ {ℓᵢ} {A : Type ℓᵢ}{ℓⱼ} {a b c : A} {P : A → Type ℓⱼ}\n  → (p : a == b)\n  → (q : b == c)\n  ---------------------------------------\n  → ((tr P q) ∘ (tr P p)) == tr P (p · q)\n\ntransport-comp {P = P} idp q = refl (transport P q)\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-comp-h\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {ℓⱼ} {a b c : A} {P : A → Type ℓⱼ}\n  → (p : a == b)\n  → (q : b == c)\n  → (x : P a)\n  -------------------------------------------\n  → ((tr P q) ∘ (tr P p)) x == tr P (p · q) x\n\ntransport-comp-h {P = P} idp q x = refl (transport P q x)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-eq-fun-l\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {b : B} (f : A → B) {x y : A}\n  → (p : x == y)\n  → (q : f x == b)\n  -------------------------------------------\n  → tr (λ z → f z == b) p q == ! (ap f p) · q\n\ntransport-eq-fun-l {b = b} f p q =\n  begin\n    transport (λ z → f z == b) p q   ==⟨ transport-eq-fun f (λ _ → b) p q ⟩\n    ! (ap f p) · q · ap (λ _ → b) p  ==⟨ ap (! (ap f p) · q ·_) (ap-const p) ⟩\n    ! (ap f p) · q · idp             ==⟨ ! (·-runit _) ⟩\n    ! (ap f p) · q\n  ∎\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun-r\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {b : B}\n  → (g : A → B) {x y : A}\n  → (p : x == y)\n  → (q : b == g x)\n  ------------------------------------------------\n  → tr (λ z → b == g z) p q == q · (ap g p)\n\ntransport-eq-fun-r {b = b} g p q =\n  begin\n    transport (λ z → b == g z) p q    ==⟨ transport-eq-fun (λ _ → b) g p q ⟩\n    ! (ap (λ _ → b) p) · q · ap g p   ==⟨ ·-assoc (! (ap (λ _ → b) p)) q (ap g p) ⟩\n    ! (ap (λ _ → b) p) · (q · ap g p) ==⟨ ap (λ u → ! u · (q · ap g p)) (ap-const p) ⟩\n    (q · ap g p)\n  ∎\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-inv\n  : ∀ {ℓᵢ ℓⱼ} {X : Type ℓᵢ}{A : X → Type ℓⱼ}{x y : X}\n  → (p : x == y)\n  → {a : A y}\n  --------------------------------------\n  → tr (λ v → A v) p (tr A (! p) a) == a\n\ntransport-inv {A = A}  idp {a = a} =\n  begin\n    tr (λ v → A v) idp (tr A (! idp) a)\n      ==⟨ idp ⟩\n    tr A (! idp · idp) a\n      ==⟨⟩\n    tr A idp a\n      ==⟨ idp ⟩\n    a\n  ∎\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-l\n  : ∀ {ℓ} {A B : Type ℓ}\n  → (p : A == B)\n  → (b : B)\n  --------------------------------------------\n  → tr (λ v → v) p (tr (λ v → v) (! p) b) == b\n\ncoe-inv-l idp b = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-r\n  : ∀ {ℓ} {A B : Type ℓ}\n  → (p : A == B)\n  → (a : A)\n  -----------------------------------------------------------\n  → tr (λ v → v) (! p) (tr (λ v → v) p a) == a\n\ncoe-inv-r idp b = idp\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-family\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {P : B → Type ℓₖ}\n  → {f : A → B} → {x y : A}\n  → (p : x == y)\n  → (u : P (f x))\n  -----------------------------------\n  → tr (P ∘ f) p u == tr P (ap f p) u\n\ntransport-family idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-family-id\n  : ∀ {ℓᵢ ℓₖ} {A : Type ℓᵢ} {P : A → Type ℓₖ} → {x y : A}\n  → (p : x == y)\n  → (u : P x)\n  ----------------------------------------------\n  → transport (λ a → P a) p u == transport P p u\n\ntransport-family-id idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-fun\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {x y : X} {A : X → Type ℓⱼ} {B : X → Type ℓₖ}\n  → (p : x == y)\n  → (f : A x → B x)\n  -----------------------------------------------------------------\n  → tr (λ x → (A x → B x)) p f == (λ x → tr B p (f (tr A (! p) x)))\n\ntransport-fun idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth = transport-fun\n\\end{code}\n\n![path](/assets/ipe-images/transport-fun.png){: width=\"100%\" }\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-fun-h\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {A : X → Type ℓⱼ} {B : X → Type ℓₖ}\n  → {x y : X}\n  → (p : x == y) → (f : A x → B x)\n  → (b : A y)\n  --------------------------------------------------------------\n  → (tr (λ x → (A x → B x)) p f) b == tr B p (f (tr A (! p) b))\n\ntransport-fun-h idp f b = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth-h = transport-fun-h\n\\end{code}\n\nNow, when we transport dependent functions this is what we got:\n\n![path](/assets/ipe-images/transport-fun-dependent.png){: width=\"100%\" }\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent-h\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}\n  → {B : (x : X) → (a : A x) → Type ℓₖ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  ---------------------------------------------------------------------\n  → (a' : A y)\n  → (tr (λ x → (a : A x) → B x a) p f) a'\n    == tr (λ w → B (π₁ w) (π₂ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent-h idp f a' = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth-h = transport-fun-dependent-h\n\\end{code}\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}\n  → {B : (x : X) → (a : A x) → Type ℓₖ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  ---------------------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f)\n    == λ (a' : A y)\n      → tr (λ w → B (π₁ w) (π₂ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth = transport-fun-dependent\n\\end{code}\n\nAction on PathOvers, this was suggested by Fredrik Nordvall:\n\n{: .foldable until=\"9\"}\n\\begin{code}\napOver\n  : {A A' : Type₀} {C : A → Type₀} {C' : A' → Type₀}  -- types\n  → {a a' : A} {b : C a} {b' : C a'}                  -- points\n  → (f : A → A')\n  → (g : {x : A} → C x → C' (f x))\n  → (p : a == a')\n  → b == b' [ C ↓ p ]\n  --------------------------------\n  → g b == g b' [ C' ↓ ap f p ]\n\napOver f g idp q = ap g q\n\\end{code}\n\n## Basic type lemmas\n\n### Sigma type\n\nOur context:\n\n\\begin{code}\nmodule Sigma {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : A → Type ℓⱼ} where\n\\end{code}\n\nTwo dependent pairs are equal if they are componentwise equal.\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Σ-componentwise\n    : {v w : Σ A P}\n    → v == w\n    ----------------------------------------------\n    → Σ (π₁ v == π₁ w) (λ p → (p ✶) (π₂ v) == π₂ w)\n\n  Σ-componentwise  idp = (idp , idp)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Σ-bycomponents\n    : {v w : Σ A P}\n    → Σ (π₁ v == π₁ w) (λ p → (p ✶) (π₂ v) == π₂ w)\n    -----------------------------------------------\n    → v == w\n\n  Σ-bycomponents (idp , idp) = idp\n\n  -- synonym of Σ-bycomponents\n  pair= = Σ-bycomponents\n\\end{code}\n\nA trivial consequence is the following identification:\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  lift-pair=\n    : ∀ {x y : A} {u : P x}\n    → (p : x == y)\n    --------------------------------------------------------\n    → lift {A = A}{C = P} u p == pair= (p , refl (tr P p u))\n\n  lift-pair= idp = idp\n\\end{code}\n\n\\begin{code}\n-- Uniqueness principle property for products\n  uppt : (x : Σ A P) → (π₁ x , π₂ x) == x\n  uppt (a , b) = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  Σ-ap-π₁\n    : {a₁ a₂ : A} {b₁ : P a₁} {b₂ : P a₂}\n    → (α : a₁ == a₂)\n    → (γ : transport P α b₁ == b₂)\n    ------------------------------\n    → ap π₁ (pair= (α , γ)) == α\n\n  Σ-ap-π₁ idp idp = idp\n\n  -- synonym for this lemma\n  ap-π₁-pair= = Σ-ap-π₁\n\\end{code}\n\n\\begin{code}\nopen Sigma public\n\\end{code}\n\n{: .foldable until=\"10\"}\n\\begin{code}\ntransport-fun-dependent-bezem\n  : ∀ {ℓᵢ ℓⱼ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}\n      {B : (x : X) → (a : A x) → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (a' : A y)\n  ----------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f) a'\n    == tr (λ w → B (π₁ w) (π₂ w))\n          (pair= (p , transport-inv p )) (f (tr A (! p) a'))\n\ntransport-fun-dependent-bezem idp f a' = idp\n\\end{code}\n\n### Cartesian product\n\n\\begin{code}\nmodule CartesianProduct {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodComponentwise\n    : {x y : A × B}\n    → (x == y)\n    ---------------------------------\n    → (π₁ x == π₁ y) × (π₂ x == π₂ y)\n\n  prodComponentwise {x = x} idp = refl (π₁ x) , refl (π₂ x)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByComponents\n    : {x y : A × B}\n    → (π₁ x == π₁ y) × (π₂ x == π₂ y)\n    ---------------------------------\n    → (x == y)\n\n  prodByComponents {x = a , b} (idp , idp) = refl (a , b)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodCompInverse\n    : {x y : A × B}\n    → (b : (π₁ x == π₁ y) × (π₂ x == π₂ y))\n    ---------------------------------------------\n    → prodComponentwise (prodByComponents b) == b\n\n  prodCompInverse {x} (idp , idp) = refl (refl (π₁ x) , refl (π₂ x))\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByCompInverse\n    : {x y : A × B}\n    → (b : x == y)\n    ---------------------------------------------\n    → prodByComponents (prodComponentwise b) == b\n\n  prodByCompInverse {x = x} idp = refl (refl x)\n\\end{code}\n\n\\begin{code}\nopen CartesianProduct\n\\end{code}\n\n## Action on dependent paths\n\n{: .foldable until=\"5\"}\n\\begin{code}\napd\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ}  {P : A → Type ℓⱼ} {a b : A}\n  → (f : (a : A) → P a) → (p : a == b)\n  ------------------------------------\n  → transport P p (f a) == f b\n\napd f idp = idp\n\\end{code}\n\n## Homotopy\n\n&gt; In a type-theoretical sense, a homotopy between two\n&gt; functions is a family of equalities between their applications.\n\nThe context:\n\\begin{code}\nmodule Homotopy {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : A → Type ℓⱼ} where\n\\end{code}\n\nLet $$f , g : \\prod\\limits_{(x:A)} P(x)$$ be two sections of a\ntype family $$P : A \\to \\mathcal{U}$$. A **homotopy** from $$f$$ to $$g$$\nis a dependent function of type\n\n{: .equation }\n  $$ (f \\sim g) :\\equiv \\prod\\limits_{x : A} (f(x) = g(x)). $$\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Lemma.\n  homotopy\n    : (f g : Π A P)\n    ---------------\n    → Type (ℓᵢ ⊔ ℓⱼ)\n\n  homotopy f g = ∀ (x : A) → f x == g x\n\\end{code}\n\n\\begin{code}\n  -- Usual notation for homotopy\n  _∼_ : (f g : ((x : A) → P x)) → Type (ℓᵢ ⊔ ℓⱼ)\n  f ∼ g = homotopy f g\n\\end{code}\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Homotopy is an equivalence relation\n  h-refl\n    : (f : Π A P)\n    -------------\n    → f ∼ f\n\n  h-refl f x = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  h-sym\n    : (f g : Π A P)\n    → f ∼ g\n    -------\n    → g ∼ f\n\n  h-sym _ _ e x = ! (e x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-comp\n    : {f g h : Π A P}\n    → f ∼ g\n    → g ∼ h\n    -------\n    → f ∼ h\n\n  h-comp u v x = (u x) · (v x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- synonym for h-comp\n  _●_\n    : {f g h : Π A P}\n    → f ∼ g\n    → g ∼ h\n    -------\n    → f ∼ h\n\n  α ● β = h-comp α β\n\\end{code}\n\n\\begin{code}\nopen Homotopy public\n\\end{code}\n\n### Composition with homotopies\n\n\\begin{code}\nmodule HomotopyComposition {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {C : Type ℓₖ} where\n\\end{code}\n\n{: .foldable until=\"8\"}\n\\begin{code}\n  -- Lemma.\n  hl-comp\n    : {f g : A → B}\n    → {j k : B → C}\n    → f ∼ g\n    → j ∼ k\n    -------------------\n    → (j ∘ f) ∼ (k ∘ g)\n\n  hl-comp {g = g}{j = j} f-g j-k = λ x → ap j (f-g x) · j-k (g x)\n\\end{code}\n\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  rcomp-∼\n    : (f : A → B)\n    → {j k : B → C}\n    → j ∼ k\n    -------------------\n    → (j ∘ f) ∼ (k ∘ f)\n\n  rcomp-∼ f j-k = hl-comp (h-refl f) j-k\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  lcomp-∼\n    : {f g : A → B}\n    → (j : B → C)\n    → f ∼ g\n    -------------------\n    → (j ∘ f) ∼ (j ∘ g)\n\n  lcomp-∼ j α = hl-comp α (h-refl j)\n\\end{code}\n\n\\begin{code}\nopen HomotopyComposition\n\\end{code}\n\n### Naturality\n\n\\begin{code}\nmodule Naturality {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\\end{code}\n\nHomotopy is natural, meaning that it satisfies the following\nsquare commutative diagram.\n\n![path](/assets/ipe-images/h-naturality.png){: width=\"40%\" }\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-naturality\n    : {f g : A → B} → {x y : A}\n    → (H : f ∼ g)\n    → (p : x == y)\n    ------------------------------\n    → H x · ap g p == ap f p · H y\n\n  h-naturality {x = x} H idp = ! (·-runit (H x))\nopen Naturality\n\\end{code}\n\nA particular case of naturality on the identity function.\n\n{: .foldable until=\"5\"}\n\\begin{code}\nh-naturality-id\n  : ∀ {ℓ} {A : Type ℓ} {f : A → A} → {x : A}\n  → (H : f ∼ id)\n  -----------------------\n  → H (f x) == ap f (H x)\n\nh-naturality-id {f = f} {x = x} H =\n  begin\n    H (f x)\n      ==⟨ ·-runit (H (f x)) ⟩\n    H (f x) · refl (f x)\n      ==⟨ ap (H (f x) ·_) (! (·-rinv (H x))) ⟩\n    H (f x) · ((H x) · (! (H x)))\n      ==⟨ ap (H (f x) ·_) (ap (_· (! (H x))) (! ap-id (H x))) ⟩\n    H (f x) · (ap id (H x) · ! (H x))\n      ==⟨ ! (·-assoc (H (f x)) (ap id (H x)) (! (H x))) ⟩\n    (H (f x) · ap id (H x)) · ! (H x)\n      ==⟨ ·-right-to-left-r (h-naturality H (H x)) ⟩\n    ap f (H x)\n  ∎\n\\end{code}\n\n## .... REVIWING .... BELOW\n\n## Fibers\n\nContractible types with a center of contraction.\n\n\\begin{code}\nmodule Fibers {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ}  where\n\n  -- The fiber of a map over a point is given by\n  fib\n    : (f : A → B)\n    → (b : B)\n    ---------------\n    → Type (ℓᵢ ⊔ ℓⱼ)\n\n  fib f b = Σ A (λ a → f a == b)\n\n\n  -- A function applied over the fiber returns the original point\n  fib-eq : {f : A → B} → {b : B} → (h : fib f b) → f (π₁ h) == b\n  fib-eq (a , α) = α\n\n  -- Each point is on the fiber of its image\n  fib-image : {f : A → B} → {a : A} → fib f (f a)\n  fib-image {f} {a} = a , refl (f a)\n\nopen Fibers public\n\\end{code}\n\n## Contractible types\n\n\\begin{code}\n-- Contractible.  Contractible types with a center of contraction.\nmodule Contractible where\n\n  -- Contractible types. A contractible type is a type such that every\n  -- element is equal to a center of contraction.\n  isContr : ∀ {ℓ}  (A : Type ℓ) → Type ℓ\n  isContr A = Σ A (λ a → ((x : A) → a == x))\nopen Contractible public\n\n\\end{code}\n\n## Equivalence\n\n\\begin{code}\nmodule Equivalence where\n\n  module DefinitionOfEquivalence {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n    -- Contractible maps. A map is contractible if the fiber in any\n    -- point is contractible, that is, each element has a unique\n    -- preimage.\n    isContrMap : (f : A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n    isContrMap f = (b : B) → isContr (fib f b)\n\\end{code}\n\n\\begin{code}\n    -- There exists an equivalence between two types if there exists a\n    -- contractible function between them.\n    isEquiv : (f : A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n    isEquiv = isContrMap\n  open DefinitionOfEquivalence public\n\\end{code}\n\n\\begin{code}\n  -- Equivalence of types.\n  _≃_ : ∀ {ℓᵢ ℓⱼ}  (A : Type ℓᵢ) (B : Type ℓⱼ) → Type (ℓᵢ ⊔ ℓⱼ)\n  A ≃ B = Σ (A → B) isEquiv\n\\end{code}\n\n\\begin{code}\n  module EquivalenceMaps {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n    -- Maps of an equivalence\n    lemap : A ≃ B → (A → B)\n    lemap = π₁\n\n    ≃-to-→ = lemap\n    fun≃   = lemap\n\n    remap : A ≃ B → (B → A)\n    remap (f , contrf) b = π₁ (π₁ (contrf b))\n\n    -- The maps of an equivalence are inverses in particular\n    lrmap-inverse : (eq : A ≃ B) → {b : B} → (lemap eq) ((remap eq) b) == b\n    lrmap-inverse (f , eqf) {b} = fib-eq (π₁ (eqf b))\n\n    rlmap-inverse : (eq : A ≃ B) → {a : A} → (remap eq) ((lemap eq) a) == a\n    rlmap-inverse (f , eqf) {a} = ap π₁ ((π₂ (eqf (f a))) fib-image)\n\n    lrmap-inverse-h : (eq : A ≃ B) → ((lemap eq) ∘ (remap eq)) ∼ id\n    lrmap-inverse-h eq = λ x → lrmap-inverse eq {x}\n\n    rlmap-inverse-h : (eq : A ≃ B) → ((remap eq) ∘ (lemap eq)) ∼ id\n    rlmap-inverse-h eq = λ x → rlmap-inverse eq {x}\n  open EquivalenceMaps public\n\\end{code}\n\n\\begin{code}\nopen Equivalence public\n\\end{code}\n\n## Function extensionality\n\n\\begin{code}\n\nmodule FunExt {ℓᵢ ℓⱼ} {A : Type ℓᵢ}\n  {B : A → Type ℓⱼ} {f g : (a : A) → B a} where\n\\end{code}\n\n\\begin{code}\n  -- Application of an homotopy\n  happly : f == g → ((x : A) → f x == g x)\n  happly idp x = refl (f x)\n\\end{code}\n\n\\begin{code}\n  -- The axiom of function extensionality postulates that the\n  -- application of homotopies is an equivalence.\n  postulate axiomFunExt : isEquiv happly\n\\end{code}\n\n\\begin{code}\n  eqFunExt : (f == g) ≃ ((x : A) → f x == g x)\n  eqFunExt = happly , axiomFunExt\n\\end{code}\n\n\\begin{code}\n  -- From this, the usual notion of function extensionality follows.\n  funext : ((x : A) → f x == g x) → f == g\n  funext = remap eqFunExt\n\\end{code}\n\n\\begin{code}\n  -- Beta and eta rules for function extensionality\n  funext-β : (h : ((x : A) → f x == g x)) → happly (funext h) == h\n  funext-β h = lrmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-η : (p : f == g) → funext (happly p) == p\n  funext-η p = rlmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\nopen FunExt public\n\\end{code}\n\n- Function extensionality in the transport case\n\n\\begin{code}\nmodule FunExt-Transport\n  {ℓᵢ ℓⱼ} {X : Type ℓᵢ} {A B : X → Type ℓⱼ} {x y : X} where\n\\end{code}\n\n\\begin{code}\n  funext-transport\n    : (p : x == y) → (f : A x → B x) → (g : A y → B y)\n    ------------------------------------------------------------\n    → ((p ✶) f == g) ≃ ((a : A(x)) → (p ✶) (f a) == g ((p ✶) a))\n\n  funext-transport idp f g = eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-transport-l\n    : (p : x == y)\n    → (f : A x → B x)\n    → (g : A y → B y)\n    → ((p ✶) f == g)\n    -------------------------------------------\n    → ((a : A(x)) → (p ✶) (f a) == g ((p ✶) a))\n\n  funext-transport-l p f g = lemap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\n  funext-transport-r\n    : (p : x == y)\n    → (f : A x → B x)\n    → (g : A y → B y)\n    → ((a : A(x)) → (p ✶) (f a) == g ((p ✶) a))\n    -------------------------------------------\n    → ((p ✶) f == g)\n\n  funext-transport-r p f g = remap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\nopen FunExt-Transport public\n\\end{code}\n\n\\begin{code}\nmodule FunExt-Transport-DFun\n  {ℓᵢ ℓⱼ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ}{x y : X}\n  where\n\n  -- Lemma 2.9.7\n  funext-transport-dfun\n    : (p : x == y)\n    → (f : (a : A x) → B x a)\n    → (g : (a : A y) → B y a)\n    ----------------------------------------------------------------------------\n    → ((p ✶) f == g)\n      ≃ ((a : A x) → tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ✶) a))\n\n  funext-transport-dfun idp f g = eqFunExt\n\n  funext-transport-dfun-l\n    : (p : x == y) → (f : (a : A x) → B x a) → (g : (a : A y) → B y a)\n    → ((p ✶) f == g)\n    ---------------------------------------------------------------------------\n    → ((a : A x) → tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ✶) a))\n\n  funext-transport-dfun-l p f g = lemap (funext-transport-dfun p _ _)\n\n  funext-transport-dfun-r\n    : (p : x == y)\n    → (f : (a : A x) → B x a)\n    → (g : (a : A y) → B y a)\n    → ((a : A x) → tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ✶) a))\n    --------------------------------------------------------------------------\n    → ((p ✶) f == g)\n\n  funext-transport-dfun-r p f g = remap (funext-transport-dfun p _ _)\nopen FunExt-Transport-DFun public\n\\end{code}\n\n## Decidable equality\n\nA type has decidable equality if any two of its\nelements are equal or different. This would be a particular\ninstance of the Law of Excluded Middle that holds even if we do not\nassume Excluded Middle.\n\n\\begin{code}\nmodule DecidableEquality {ℓ} where\n\n  -- A type has decidable equality if we can prove that any two of its\n  -- elements are equal or different.\n  decEq : (A : Type ℓ) → Type ℓ\n  decEq A = (a b : A) → (a == b) + ¬ (a == b)\n\n  -- The product of types with decidable equality is a type with\n  -- decidable equality.\n  decEqProd : {A B : Type ℓ} → decEq A → decEq B → decEq (A × B)\n  decEqProd da db (a1 , b1) (a2 , b2) with (da a1 a2) | (db b1 b2)\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inl beq = inl (prodByComponents (aeq , beq))\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inr bnq = inr λ b → bnq (ap π₂ b)\n  decEqProd da db (a1 , b1) (a2 , b2) | inr anq | u       = inr λ b → anq (ap π₁ b)\n\nopen DecidableEquality\n\\end{code}\n\n## Hlevels\n\n### Propositions\n\nPropositions as described on the main text. A type\nis a proposition if we can create a function making any two of its\nelements equal. We create a type of propositions.\n\n\\begin{code}\n\nmodule Propositions where\n\n  -- A type is a mere proposition if any two inhabitants of the type\n  -- are equal\n  isProp : ∀ {ℓ}  (A : Type ℓ) → Type ℓ\n  isProp A = ((x y : A) → x == y)\n\n  -- The type of mere propositions\n  hProp : ∀ {ℓ} → Type (lsuc ℓ)\n  hProp {ℓ} = Σ (Type ℓ) isProp\n\n\n  -- The dependent function type to proposition types is itself a\n  -- proposition.\n  piProp : ∀ {ℓᵢ ℓⱼ} → {A : Type ℓᵢ} → {B : A → Type ℓⱼ}\n         → ((a : A) → isProp (B a)) → isProp ((a : A) → B a)\n  piProp props f g = funext λ a → props a (f a) (g a)\n\n  -- The product of propositions is itself a proposition.\n  isProp-prod : ∀ {ℓᵢ ℓⱼ} → {A : Type ℓᵢ} → {B : Type ℓⱼ}\n              → isProp A → isProp B → isProp (A × B)\n  isProp-prod p q x y = prodByComponents ((p _ _) , (q _ _))\n\nopen Propositions public\n\\end{code}\n\n### Sets\n\nSets are types without any higher dimensional structure, all\nparallel paths are homotopic and the homotopy is given by a\ncontinuous function on the two paths.\n\n\\begin{code}\nmodule Sets where\n\n  -- A type is a \"set\" by definition if any two equalities on the type\n  -- are equal.\n  isSet : ∀ {ℓ}  (A : Type ℓ) → Type ℓ\n  isSet A = (x y : A) → isProp (x == y)\n\n  -- The type of sets.\n  hSet : ∀ {ℓ} → Type (lsuc ℓ)\n  hSet {ℓ} = Σ (Type ℓ) isSet\n\n  -- Product of sets is a set.\n  isSet-prod : ∀ {ℓᵢ ℓⱼ}  {A : Type ℓᵢ} → {B : Type ℓⱼ}\n             → isSet A → isSet B → isSet (A × B)\n  isSet-prod sa sb (a , b) (c , d) p q = begin\n     p\n      ==⟨ inv (prodByCompInverse p) ⟩\n     prodByComponents (prodComponentwise p)\n      ==⟨ ap prodByComponents (prodByComponents (sa a c _ _ , sb b d _ _)) ⟩\n     prodByComponents (prodComponentwise q)\n      ==⟨ prodByCompInverse q ⟩\n     q\n    ∎\n\nopen Sets public\n\\end{code}\n\n### Lemmas\n\nHigher levels of the homotopical structure, where the\nfirst levels are:\n\n- Contractible types (0)\n- Propositions (1)\n- Sets (2)\n\nThey would correspond to homotopy levels. We only work with\nthese first levels.\n\n\\begin{code}\n\nmodule HLevels where\n\n  -- Propositions are Sets.\n  propIsSet : ∀ {ℓ} {A : Type ℓ} → isProp A → isSet A\n  propIsSet {A = A} f a _ p q = lemma p · inv (lemma q)\n    where\n      triang : {y z : A} {p : y == z} → (f a y) · p == f a z\n      triang {y}{p = idp} = inv (·-runit (f a y))\n\n      lemma : {y z : A} (p : y == z) → p == ! (f a y) · (f a z)\n      lemma {y} {z} p =\n        begin\n          p                       ==⟨ ap (_· p) (inv (·-linv (f a y))) ⟩\n          ! (f a y) · f a y · p   ==⟨ ·-assoc (! (f a y)) (f a y) p ⟩\n          ! (f a y) · (f a y · p) ==⟨ ap (! (f a y) ·_) triang ⟩\n          ! (f a y) · (f a z)\n        ∎\n\n  -- Contractible types are Propositions.\n  contrIsProp : ∀ {ℓ}  {A : Type ℓ} → isContr A → isProp A\n  contrIsProp (a , p) x y = ! (p x) · p y\n\n  -- To be contractible is itself a proposition.\n  isContrIsProp : ∀ {ℓ}  {A : Type ℓ} → isProp (isContr A)\n  isContrIsProp {_} {A} (a , p) (b , q) = Σ-bycomponents (inv (q a) , piProp (AisSet b) _ q)\n    where\n      AisSet : isSet A\n      AisSet = propIsSet (contrIsProp (a , p))\n\nopen HLevels public\n\\end{code}\n\n\nEquivalence of two types is a proposition\nMoreover, equivalences preserve propositions.\n\n\\begin{code}\n\nmodule EquivalenceProp {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n  -- Contractible maps are propositions\n  isContrMapIsProp : (f : A → B) → isProp (isContrMap f)\n  isContrMapIsProp f = piProp λ a → isContrIsProp\n\n  isEquivIsProp : (f : A → B) → isProp (isEquiv f)\n  isEquivIsProp = isContrMapIsProp\n\n  -- Equality of same-morphism equivalences\n  sameEqv : {α β : A ≃ B} → π₁ α == π₁ β → α == β\n  sameEqv {(f , σ)} {(g , τ)} p = Σ-bycomponents (p , (isEquivIsProp g _ τ))\n\n  -- Equivalences preserve propositions\n  isProp-≃ : (A ≃ B) → isProp A → isProp B\n  isProp-≃ eq prop x y =\n    begin\n      x                       ==⟨ inv (lrmap-inverse eq) ⟩\n      lemap eq ((remap eq) x) ==⟨ ap (λ u → lemap eq u) (prop _ _) ⟩\n      lemap eq ((remap eq) y) ==⟨ lrmap-inverse eq ⟩\n      y\n    ∎\n\nopen EquivalenceProp public\n\\end{code}\n\n\n### Half-adjoints\n\nHalf-adjoints are an auxiliary notion that helps us\nto define a suitable notion of equivalence, meaning that it is a\nproposition and that it captures the usual notion of equivalence.\n\n\\begin{code}\nmodule Halfadjoints {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n  -- Half adjoint equivalence.\n  record ishae (f : A → B) : Type (ℓᵢ ⊔ ℓⱼ) where\n    constructor hae\n    field\n      g : B → A\n      η : (g ∘ f) ∼ id\n      ε : (f ∘ g) ∼ id\n      τ : (a : A) → ap f (η a) == ε (f a)\n\n  -- Half adjoint equivalences give contractible fibers.\n  ishae-contr : (f : A → B) → ishae f → isContrMap f\n  ishae-contr f (hae g η ε τ) y = ((g y) , (ε y)) , contra\n    where\n      lemma : (c c' : fib f y) → Σ (π₁ c == π₁ c') (λ γ → (ap f γ) · π₂ c' == π₂ c) → c == c'\n      lemma c c' (p , q) = Σ-bycomponents (p , lemma2)\n        where\n          lemma2 : transport (λ z → f z == y) p (π₂ c) == π₂ c'\n          lemma2 =\n            begin\n              transport (λ z → f z == y) p (π₂ c)\n                ==⟨ transport-eq-fun-l f p (π₂ c) ⟩\n              inv (ap f p) · (π₂ c)\n                ==⟨ ap (inv (ap f p) ·_) (inv q) ⟩\n              inv (ap f p) · ((ap f p) · (π₂ c'))\n                ==⟨ inv (·-assoc (inv (ap f p)) (ap f p) (π₂ c')) ⟩\n              inv (ap f p) · (ap f p) · (π₂ c')\n                ==⟨ ap (_· (π₂ c')) (·-linv (ap f p)) ⟩\n              π₂ c'\n            ∎\n\n      contra : (x : fib f y) → (g y , ε y) == x\n      contra (x , p) = lemma (g y , ε y) (x , p) (γ , lemma3)\n        where\n          γ : g y == x\n          γ = inv (ap g p) · η x\n\n          lemma3 : (ap f γ · p) == ε y\n          lemma3 =\n            begin\n              ap f γ · p\n                ==⟨ ap (_· p) (ap-· f (inv (ap g p)) (η x)) ⟩\n              ap f (inv (ap g p)) · ap f (η x) · p\n                ==⟨ ·-assoc (ap f (inv (ap g p))) _ p ⟩\n              ap f (inv (ap g p)) · (ap f (η x) · p)\n                ==⟨ ap (_· (ap f (η x) · p)) (ap-inv f (ap g p)) ⟩\n              inv (ap f (ap g p)) · (ap f (η x) · p)\n                ==⟨ ap (λ u → inv (ap f (ap g p)) · (u · p)) (τ x) ⟩\n              inv (ap f (ap g p)) · (ε (f x) · p)\n                ==⟨ ap (λ u → inv (ap f (ap g p)) · (ε (f x) · u)) (inv (ap-id p)) ⟩\n              inv (ap f (ap g p)) · (ε (f x) · ap id p)\n                ==⟨ ap (inv (ap f (ap g p)) ·_) (h-naturality ε p) ⟩\n              inv (ap f (ap g p)) · (ap (f ∘ g) p · ε y)\n                ==⟨ ap (λ u → inv u · (ap (f ∘ g) p · ε y)) (ap-comp g f p) ⟩\n              inv (ap (f ∘ g) p) · (ap (f ∘ g) p · ε y)\n                ==⟨ inv (·-assoc (inv (ap (f ∘ g) p)) _ (ε y)) ⟩\n              (inv (ap (f ∘ g) p) · ap (f ∘ g) p) · ε y\n                ==⟨ ap (_· ε y) (·-linv (ap (λ z → f (g z)) p)) ⟩\n              ε y\n            ∎\n\n  -- Half-adjointness implies equivalence.\n  ishae-≃ : {f : A → B} → ishae f → A ≃ B\n  ishae-≃ ishaef = _ , (ishae-contr _ ishaef)\n\nopen Halfadjoints public\n\\end{code}\n\n### Quasiinverses\n\nTwo functions are quasi-inverses if we can construct a function providing\n`(g ∘ f) x = x` and `(f ∘ g) y = y` for any given `x` and `y`.\n\n\\begin{code}\nmodule Quasiinverses {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n  -- Definitions for quasi-inverses, left-inverses, right-inverses and\n  -- biinverses.\n  qinv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  qinv f = Σ (B → A) (λ g → ((f ∘ g) ∼ id) × ((g ∘ f) ∼ id))\n\n  linv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  linv f = Σ (B → A) (λ g → (g ∘ f) ∼ id)\n\n  rinv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  rinv f = Σ (B → A) λ g → (f ∘ g) ∼ id\n\n  biinv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  biinv f = linv f × rinv f\n\n  qinv-biinv : (f : A → B) → qinv f → biinv f\n  qinv-biinv f (g , (u1 , u2)) = (g , u2) , (g , u1)\n\n  biinv-qinv : (f : A → B) → biinv f → qinv f\n  biinv-qinv f ((h , α) , (g , β)) = g , (β , δ)\n    where\n      γ1 : g ∼ ((h ∘ f) ∘ g)\n      γ1 = rcomp-∼ g (h-sym (h ∘ f) id α)\n\n      γ2 : ((h ∘ f) ∘ g) ∼ (h ∘ (f ∘ g))\n      γ2 x = idp\n\n      γ : g ∼ h\n      γ = γ1 ● (γ2 ● (lcomp-∼ h β))\n\n      δ : (g ∘ f) ∼ id\n      δ = (rcomp-∼ f γ) ● α\n\n  equiv-biinv : (f : A → B) → isContrMap f → biinv f\n  equiv-biinv f contrf =\n    (remap eq , rlmap-inverse-h eq) , (remap eq , lrmap-inverse-h eq)\n    where\n      eq : A ≃ B\n      eq = f , contrf\n\n  -- Quasiinverses are halfadjoint equivalences.\n  qinv-ishae : {f : A → B} → qinv f → ishae f\n  qinv-ishae {f} (g , (ε , η)) = record {\n      g = g ;\n      η = η ;\n      ε = λ b → inv (ε (f (g b))) · ap f (η (g b)) · ε b ;\n      τ = τ\n    }\n    where\n      aux-lemma : (a : A) → ap f (η (g (f a))) · ε (f a) == ε (f (g (f a))) · ap f (η a)\n      aux-lemma a =\n        begin\n          ap f (η ((g ∘ f) a)) · ε (f a)\n            ==⟨ ap (λ u → ap f u · ε (f a)) (h-naturality-id η) ⟩\n          ap f (ap (g ∘ f) (η a)) · ε (f a)\n            ==⟨ ap (_· ε (f a)) (ap-comp (g ∘ f) f (η a)) ⟩\n          ap (f ∘ (g ∘ f)) (η a) · ε (f a)\n            ==⟨ inv (h-naturality (λ x → ε (f x)) (η a)) ⟩\n          ε (f (g (f a))) · ap f (η a)\n        ∎\n\n      τ : (a : A) → ap f (η a) == (inv (ε (f (g (f a)))) · ap f (η (g (f a))) · ε (f a))\n      τ a =\n        begin\n          ap f (η a)\n            ==⟨ ap (_· ap f (η a)) (inv (·-linv (ε (f (g (f a)))))) ⟩\n          inv (ε (f (g (f a)))) · ε (f (g (f a))) · ap f (η a)\n            ==⟨ ·-assoc (inv (ε (f (g (f a))))) _ (ap f (η a)) ⟩\n          inv (ε (f (g (f a)))) · (ε (f (g (f a))) · ap f (η a))\n            ==⟨ ap (inv (ε (f (g (f a)))) ·_) (inv (aux-lemma a)) ⟩\n          inv (ε (f (g (f a)))) · (ap f (η (g (f a))) · ε (f a))\n            ==⟨ inv (·-assoc (inv (ε (f (g (f a))))) _ (ε (f a))) ⟩\n          inv (ε (f (g (f a)))) · ap f (η (g (f a))) · ε (f a)\n        ∎\n\n  -- Quasiinverses create equivalences.\n  qinv-≃ : (f : A → B) → qinv f → A ≃ B\n  qinv-≃ f = ishae-≃ ∘ qinv-ishae\n\n  ≃-qinv : A ≃ B → Σ (A → B) qinv\n  ≃-qinv eq =\n    lemap eq , (remap eq , (lrmap-inverse-h eq , rlmap-inverse-h eq))\n\n  -- Half-adjoint equivalences are quasiinverses.\n  ishae-qinv : {f : A → B} → ishae f → qinv f\n  ishae-qinv {f} (hae g η ε τ) = g , (ε , η)\n\n  ≃-ishae : (e : A ≃ B)→ ishae (lemap e)\n  ≃-ishae e = qinv-ishae (π₂ (≃-qinv e))\n\nopen Quasiinverses public\n\\end{code}\n\n## Equivalence composition\n\nComposition of equivalences and properties of that composition.\n\n\\begin{code}\nmodule EquivalenceComposition where\n\n  -- Composition of quasiinverses\n  qinv-comp : ∀ {ℓ} {A B C : Type ℓ} → Σ (A → B) qinv → Σ (B → C) qinv → Σ (A → C) qinv\n  qinv-comp (f , (if , (εf , ηf))) (g , (ig , (εg , ηg))) = (g ∘ f) , ((if ∘ ig) ,\n     ( (λ x → ap g (εf (ig x)) · εg x)\n     ,  λ x → ap if (ηg (f x)) · ηf x))\n\n  qinv-inv : ∀ {ℓ} {A B : Type ℓ} → Σ (A → B) qinv → Σ (B → A) qinv\n  qinv-inv (f , (g , (ε , η))) = g , (f , (η , ε))\n\n  -- Composition of equivalences\n  idEqv : ∀ {ℓ} {A : Type ℓ} → A ≃ A\n  idEqv = id , λ a → (a , refl a) , λ { (_ , idp) → refl (a , refl a) }\n\\end{code}\n\n\\begin{code}\n--\n  compEqv\n    : ∀ {ℓ} {A B C : Type ℓ}\n    → A ≃ B\n    → B ≃ C\n    -------\n    → A ≃ C\n\n  compEqv {A = A} {C = C} eq-f eq-g = qinv-≃ (π₁ qcomp) (π₂ qcomp)\n   where\n     qcomp : Σ (A → C) qinv\n     qcomp = qinv-comp (≃-qinv eq-f) (≃-qinv eq-g)\n\n  -- synonym:\n  ≃-trans = compEqv\n\\end{code}\n\n\\begin{code}\n  invEqv : ∀ {ℓ} {A B : Type ℓ} → A ≃ B → B ≃ A\n  invEqv {ℓ} {A} {B} eq-f = qinv-≃ (π₁ qcinv) (π₂ qcinv)\n   where\n     qcinv : Σ (B → A) qinv\n     qcinv = qinv-inv (≃-qinv eq-f)\n\n  -- Lemmas about composition\n  compEqv-inv : ∀ {ℓ} {A B : Type ℓ} → (α : A ≃ B) → compEqv α (invEqv α) == idEqv\n  compEqv-inv {_} {A} {B} α = sameEqv (\n   begin\n     π₁ (compEqv α (invEqv α)) ==⟨ refl _ ⟩\n     π₁ (invEqv α) ∘ π₁ α     ==⟨ funext (rlmap-inverse-h α) ⟩\n     id\n   ∎)\n\nopen EquivalenceComposition public\n\\end{code}\n\n\n## Equivalence reasoning\n\n\\begin{code}\nmodule EquivalenceReasoning where\n\n  infixr 2 _≃⟨⟩_\n  _≃⟨⟩_ : ∀ {ℓ} (A {B} : Type ℓ) → A ≃ B → A ≃ B\n  _ ≃⟨⟩ e = e\n\n  infixr 2 _≃⟨_⟩_\n  _≃⟨_⟩_ : ∀ {ℓ} (A : Type ℓ) {B C : Type ℓ} → A ≃ B → B ≃ C → A ≃ C\n  _ ≃⟨ e₁ ⟩ e₂ = compEqv e₁ e₂\n  --\n  infix  3 _≃∎\n  _≃∎ :  ∀ {ℓ} (A : Type ℓ) → A ≃ A\n  _≃∎ = λ A → idEqv {A = A}\n\n  infix  1 begin≃_\n  begin≃_ : ∀ {ℓ} {A B : Type ℓ} → A ≃ B → A ≃ B\n  begin≃_ e = e\n\nopen EquivalenceReasoning public\n\\end{code}\n\n## Equivalence with Sigma type\n\n\\begin{code}\nmodule SigmaEquivalence {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : A → Type ℓⱼ} where\n\n  pair=Equiv : {v w : Σ A P}\n    → Σ (π₁ v == π₁ w) (λ p → tr (λ a → P a) p (π₂ v) == π₂ w) ≃ v == w\n  pair=Equiv = qinv-≃ Σ-bycomponents (Σ-componentwise , HΣ₁ , HΣ₂)\n    where\n      HΣ₁ : Σ-bycomponents ∘ Σ-componentwise ∼ id\n      HΣ₁ idp = idp\n\n      HΣ₂ : Σ-componentwise ∘ Σ-bycomponents ∼ id\n      HΣ₂ (idp , idp) = idp\n\n  private\n    f : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → ap π₁ (pair= (β , γ)) == α → β == α\n    f {β = idp} {γ = idp} idp = idp\n\n    g : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → β == α → ap π₁ (pair= (β , γ)) == α\n    g {β = idp} {γ = idp} idp = idp\n\n    f-g : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → f {α = α}{β = β}{γ} ∘ g {α = α}{β = β} ∼ id\n    f-g {β = idp} {γ = idp} idp = idp\n\n    g-f : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → g {α = α}{β = β}{γ} ∘ f {α = α}{β = β}{γ} ∼ id\n    g-f {β = idp} {γ = idp} idp = idp\n\n  ap-π₁-pair=Equiv : {a₁ a₂ : A} {c₁ : P a₁} {c₂ : P a₂}\n    → (α : a₁ == a₂)\n    → (γ : Σ (a₁ == a₂) (λ α' → transport P α' c₁ == c₂))\n    → (ap π₁ (pair= γ) == α) ≃ π₁ γ == α\n  ap-π₁-pair=Equiv {a₁ = a₁} α (β , γ) = qinv-≃ f (g , f-g , g-f)\n\nopen SigmaEquivalence public\n\\end{code}\n\n## Univalence\n\nVoevodsky's univalence axiom is postulated. It induces\nan equality between any two equivalent types. Some β and η rules\nare provided.\n\n\\begin{code}\nmodule Univalence where\n\n  -- Voevodsky's Univalence Axiom.\n  module UnivalenceAxiom {ℓ} {A B : Type ℓ} where\n\n    idtoeqv : A == B → A ≃ B\n    idtoeqv p = qinv-≃\n      (transport (λ X → X) p)\n      (transport (λ X → X) (inv p) , (coe-inv-l p , coe-inv-r p))\n\n    -- The Univalence axiom induces an equivalence between equalities\n    -- and equivalences.\n    postulate axiomUnivalence : isEquiv idtoeqv\n    eqvUnivalence : (A == B) ≃ (A ≃ B)\n    eqvUnivalence = idtoeqv , axiomUnivalence\n\n    -- Introduction rule for equalities.\n    ua : A ≃ B → A == B\n    ua = remap eqvUnivalence\n\n    -- Computation rules\n    ua-β : (eqv : A ≃ B) → idtoeqv (ua eqv) == eqv\n    ua-β eqv = lrmap-inverse eqvUnivalence\n\n    ua-η : (p : A == B) → ua (idtoeqv p) == p\n    ua-η p = rlmap-inverse eqvUnivalence\n  open UnivalenceAxiom public\nopen Univalence public\n\\end{code}\n\n### Univalence lemmas\n\n\\begin{code}\nmodule UnivalenceLemmas {ℓ} where\n\\end{code}\n\n- The identity equivalence creates the trivial path.\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-id : {A : Type ℓ} → ua idEqv == refl A\n    -- ua-id {A} =\n    --   begin\n    --     ua idEqv              ==⟨ ap ua (sameEqv (refl id)) ⟩\n    --     ua (idtoeqv (refl A)) ==⟨ ua-η (refl A) ⟩\n    --     refl A\n    --   ∎\n\n    -- The composition of equivalences is preserved into composition\n    -- of equalities.\n\\end{code}\n-\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-comp : {A B C : Type ℓ} → (α : A ≃ B) → (β : B ≃ C) → ua (compEqv α β) == ua α · ua β\n    -- ua-comp α β =\n    --   begin\n    --     ua (compEqv α β)                               ==⟨ ap (λ x → ua (compEqv x β)) (inv (ua-β α)) ⟩\n    --     ua (compEqv (idtoeqv (ua α)) β)                ==⟨ ap (λ x → ua (compEqv (idtoeqv (ua α)) x))\n    --                                                        (inv (ua-β β)) ⟩\n    --     ua (compEqv (idtoeqv (ua α)) (idtoeqv (ua β))) ==⟨ ap ua lemma ⟩\n    --     ua (idtoeqv (ua α · ua β))                     ==⟨ ua-η (ua α · ua β) ⟩\n    --     ua α · ua β\n    --   ∎\n    --   where\n    --     lemma : compEqv (idtoeqv (ua α)) (idtoeqv (ua β)) == idtoeqv (ua α · ua β)\n    --     lemma = sameEqv (\n    --       begin\n    --         π₁ (idtoeqv (ua β)) ∘ π₁ (idtoeqv (ua α))                 ==⟨ refl _ ⟩\n    --         (transport (λ x → x) (ua β)) ∘ (transport (λ x → x) (ua α)) ==⟨ transport-comp (ua α) (ua β) ⟩\n    --         transport (λ x → x) (ua α · ua β)                           ==⟨ refl _ ⟩\n    --         π₁ (idtoeqv (ua α · ua β))\n    --       ∎)\n\\end{code}\n\n- Inverses are preserved\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv-r : {A B : Type ℓ} → (α : A ≃ B) → ua α · ua (invEqv α) == refl A\n    -- ua-inv-r α =\n    --   begin\n    --     ua α · ua (invEqv α)      ==⟨ inv (ua-comp α (invEqv α)) ⟩\n    --     ua (compEqv α (invEqv α)) ==⟨ ap ua (compEqv-inv α) ⟩\n    --     ua idEqv                  ==⟨ ua-id ⟩\n    --     refl _\n    --   ∎\n\\end{code}\n\n- Missing description\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv : {A B : Type ℓ} → (α : A ≃ B) → ua (invEqv α) == inv (ua α)\n    -- ua-inv α =\n    --   begin\n    --     ua (invEqv α)                       ==⟨ ap (_· ua (invEqv α)) (inv (·-linv (ua α))) ⟩\n    --     inv (ua α) · ua α · ua (invEqv α)   ==⟨ ·-assoc (inv (ua α)) _ _ ⟩\n    --     inv (ua α) · (ua α · ua (invEqv α)) ==⟨ ap (inv (ua α) ·_) (ua-inv-r α) ⟩\n    --     inv (ua α) · refl _                 ==⟨ inv (·-runit (inv ((ua α)))) ⟩\n    --     inv (ua α)\n    --   ∎\nopen UnivalenceLemmas public\n\\end{code}\n\n### Transport and Univalence\n\n\\begin{code}\nmodule TransportUA where\n\n  transport-family-ap\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (u : B x)\n    ---------------------------------------------------\n    → transport B p u == transport (λ X → X) (ap B p) u\n  transport-family-ap B idp u = idp\n\n  transport-family-idtoeqv\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (u : B x)\n    ---------------------------------------------------\n    → transport B p u == fun≃ (idtoeqv (ap B p)) u\n  transport-family-idtoeqv B idp u = idp\n\n  transport-ua\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (e : B x ≃ B y)\n    → ap B p == ua e\n    -----------------\n    → (u : B x) → transport B p u == (fun≃ e) u\n  transport-ua B idp e q u =\n    begin\n      transport B idp u\n        ==⟨ transport-family-idtoeqv B idp u ⟩\n      fun≃ (idtoeqv (ap B idp)) u\n        ==⟨ ap (λ r → fun≃ (idtoeqv r) u) q ⟩\n      fun≃ (idtoeqv (ua e)) u\n        ==⟨ ap (λ r → fun≃ r u) (ua-β e) ⟩\n      fun≃ e u\n    ∎\n\n\n  funext-transport-ua\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (e : B x ≃ B y)\n    → ap B p == ua e\n    -----------------\n    → transport B p == (fun≃ e)\n  funext-transport-ua B p e x₁ = funext (transport-ua B p e x₁)\nopen TransportUA public\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem\n  : ∀ {ℓᵢ ℓⱼ}{X : Type ℓᵢ}{A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (g : (a : A y) → B y a)\n  → (a : A y)\n  ------------------------------------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f) a == g a\n  ≃  tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , transport-inv p)) (f (((! p) ✶) a)) == g a\n\nfunext-transport-dfun-bezem idp f g a = idEqv\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-l\n  : ∀ {ℓᵢ ℓⱼ}{X : Type ℓᵢ}{A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (g : (a : A y) → B y a)\n  → (a : A y)\n  → (tr (λ x → (a : A x) → B x a) p f) a == g a\n  ------------------------------------------------------------------------------------\n  →  tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , transport-inv p)) (f (((! p) ✶) a)) == g a\n\nfunext-transport-dfun-bezem-l p f g a x₁ = lemap (funext-transport-dfun-bezem p f g a) x₁\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-r\n  : ∀ {ℓᵢ ℓⱼ}{X : Type ℓᵢ}{A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (g : (a : A y) → B y a)\n  → (a : A y)\n  →  tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , transport-inv p)) (f (((! p) ✶) a)) == g a\n  ------------------------------------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f) a == g a\n\nfunext-transport-dfun-bezem-r p f g a x₁ = remap (funext-transport-dfun-bezem p f g a) x₁\n\\end{code}\n\n## Truncation\n\n\\begin{code}\nmodule Truncation where\n\n  private\n    -- Higher inductive type, defined with equalities between any two\n    -- members.\n    data !∥_∥ {ℓ} (A : Type ℓ) : Type ℓ where\n      !∣_∣ : A → !∥ A ∥\n\n  ∥_∥ : ∀ {ℓ} (A : Type ℓ) → Type ℓ\n  ∥ A ∥ = !∥ A ∥\n\n  ∣_∣ : ∀ {ℓ} {X : Type ℓ} → X → ∥ X ∥\n  ∣ x ∣ = !∣ x ∣\n\n  -- Any two elements of the truncated type are equal\n  postulate trunc : ∀ {ℓ} {A : Type ℓ} → isProp ∥ A ∥\n\n  -- Recursion principle\n  trunc-rec : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : Type ℓⱼ}\n            → isProp P\n            → (A → P)\n            ---------\n            → ∥ A ∥ → P\n  trunc-rec _ f !∣ x ∣ = f x\n\\end{code}\n\n## Set truncation\n\nAn analogous form of truncation for Sets instead of\nPropositions. It truncates any higher-dimensional homothopical\nstructure.\n\n\\begin{code}\nmodule SetTruncation where\n\n  private\n    -- Higher inductive type\n    data !∥_∥₀ {ℓ} (A : Type ℓ) : Type ℓ where\n      !∣_∣₀ : A → !∥ A ∥₀\n\n  ∥_∥₀ : ∀ {ℓ} (A : Type ℓ) → Type ℓ\n  ∥ A ∥₀ = !∥ A ∥₀\n\n  ∣_∣₀ : ∀ {ℓ} {X : Type ℓ} → X → ∥ X ∥₀\n  ∣ x ∣₀ = !∣ x ∣₀\n\n  -- Any two equalities on the truncated type are equal\n  postulate strunc : ∀ {ℓ} {A : Type ℓ} → isSet ∥ A ∥₀\n\n  -- Recursion principle\n  strunc-rec : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : Type ℓⱼ} → isSet P → (A → P) → ∥ A ∥₀ → P\n  strunc-rec _ f !∣ x ∣₀ = f x\n\n  -- Induction principle\n  strunc-ind : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : ∥ A ∥₀ → Type ℓⱼ} → ((a : ∥ A ∥₀) → isSet (B a))\n             → (g : (a : A) → B ∣ a ∣₀) → (a : ∥ A ∥₀) → B a\n  strunc-ind _ g !∣ x ∣₀ = g x\n\\end{code}\n\n## Quotients\n\n\\begin{code}\nmodule Quotients where\n\n  record QRel {ℓ} (A : Type ℓ) : Type (lsuc ℓ) where\n    field\n      R : A → A → Type ℓ\n      Aset : isSet A\n      Rprop : (a b : A) → isProp (R a b)\n  open QRel  public\n\n  private\n    -- Higher inductive type\n    data _!/_ {ℓ} (A : Type ℓ) (r : QRel A) : Type (lsuc ℓ) where\n      ![_] : A → (A !/ r)\n\n  _/_ : ∀ {ℓ} (A : Type ℓ) (r : QRel A) → Type (lsuc ℓ)\n  A / r = (A !/ r)\n\n  [_] : ∀ {ℓ} {A : Type ℓ} → A → {r : QRel A} → (A / r)\n  [ a ] = ![ a ]\n\n  -- Equalities induced by the relation\n  postulate Req : ∀ {ℓ} {A : Type ℓ} {r : QRel A}\n                 → {a b : A} → R  a b → [ a ] {r} == [ b ]\n\n  -- The quotient of a set is again a set\n  postulate Rtrunc : ∀ {ℓ} {A : Type ℓ} {r : QRel A} → isSet (A / r)\n\n  -- Recursion principle\n  QRel-rec : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {r : QRel A} {B : Type ℓⱼ}\n            → (f : A → B) → ((x y : A) → R  x y → f x == f y) → A / r → B\n  QRel-rec f p ![ x ] = f x\n\n  -- Induction principle\n  QRel-ind : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {r : QRel A} {B : A / r → Type ℓⱼ}\n            → (f : ((a : A) → B [ a ]))\n            → ((x y : A) → (o : R  x y) → (transport B (Req o) (f x)) == f y)\n            → (z : A / r) → B z\n  QRel-ind f p ![ x ] = f x\n\n  -- Recursion in two arguments\n  QRel-rec-bi : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {r : QRel A} {B : Type ℓⱼ}\n              → (f : A → A → B) → ((x y z t : A) → R  x y → R  z t → f x z == f y t)\n              → A / r → A / r → B\n  QRel-rec-bi f p ![ x ] ![ y ] = f x y\n\n\n  Qrel-prod : ∀ {ℓᵢ}{A : Type ℓᵢ} (r : QRel A) → QRel (A × A)\n  Qrel-prod r = record { R = λ { (a , b) (c , d) → (R  a c) × (R  b d) }\n                       ; Aset = isSet-prod (Aset ) (Aset )\n                       ; Rprop = λ { (x , y) (z , w) → isProp-prod (Rprop  x z) (Rprop  y w)} }\n\\end{code}\n\n## Relation\n\n\\begin{code}\nmodule Relation where\n\n  record Rel {ℓ} (A : Type ℓ) : Type (lsuc ℓ) where\n    field\n      R     : A → A → Type ℓ\n      Rprop : (a b : A) → isProp (R a b)\n  open Rel  public\n\nopen Relation public\n\\end{code}\n\n\n## Hedberg\n\n\\begin{code}\nmodule Hedberg {ℓ} where\n\n  module HedbergLemmas (A : Type ℓ) where\n\n    -- A set is a type satisfiying axiom K.\n    axiomKisSet : ((a : A) → (p : a == a) → p == refl a) → isSet A\n    axiomKisSet k x _ p idp = k x p\n\n    -- Lemma: a reflexive relation on X implying the identity proves\n    -- that X is a set.\n    reflRelIsSet :  (r : Rel A) →\n      ((x y : A) → R  x y → x == y) →\n      (ρ : (a : A) → R  a a) →\n      isSet A\n    reflRelIsSet r f ρ x .x p idp = lemma p\n      where\n        lemma2 : {a : A} (p : a == a) → (o : R  a a) →\n          transport (λ x → a == x) p (f a a o) == f a a (transport (R  a) p o)\n        lemma2 {a} p = funext-transport-l p (f a a) (f a a) (apd (f a) p)\n\n        lemma3 : {a : A} (p : a == a) →\n          (f a a (ρ a)) · p == (f a a (ρ a))\n        lemma3 {a} p = inv (transport-concat-r p _) · lemma2 p (ρ a) ·\n                       ap (f a a) (Rprop  a a _ (ρ a))\n\n        lemma : {a : A} (p : a == a) → p == refl a\n        lemma {a} p = ·-cancellation ((f a a (ρ a))) p (lemma3 p)\n\n    -- Lemma: if a type is decidable, then ¬¬A is actually A.\n    lemDoubleNeg : (A + ¬ A) → (¬ (¬ A) → A)\n    lemDoubleNeg (inl x) _ = x\n    lemDoubleNeg (inr f) n = exfalso (n f)\n\n  open HedbergLemmas public\n\n  -- Hedberg's theorem. A type with decidable equality is a set.\n  hedberg : {A : Type ℓ} → ((a b : A) → (a == b) + ¬ (a == b)) → isSet A\n  hedberg {A} f = reflRelIsSet A\n                (record { R = λ a b → ¬ (¬ (a == b)) ; Rprop = isPropNeg })\n                doubleNegEq (λ a z → z (refl a))\n    where\n      doubleNegEq : (a b : A) → ¬ (¬ (a == b)) → (a == b)\n      doubleNegEq a b = lemDoubleNeg (a == b) (f a b)\n\n      isPropNeg : (a b : A) → isProp (¬ (¬ (a == b)))\n      isPropNeg a b x y = funext λ u → exfalso (x u)\n\nopen Hedberg public\n\\end{code}\n\n\n## Algebra\n\n### Monoid\n\nDefinition of the algebraic structure of a monoid.\n\n\\begin{code}\nmodule Monoids {ℓ} where\n\n  record Monoid : Type (lsuc ℓ) where\n    field\n      -- Operations of a monoid\n      G : Type ℓ\n      GisSet : isSet G\n      _&lt;&gt;_ : G → G → G  -- Multiplication function\n      e : G             -- Unit element\n\n      -- Axioms of a monoid\n      lunit : (x : G) → (e &lt;&gt; x) == x\n      runit : (x : G) → (x &lt;&gt; e) == x\n      assoc : (x y z : G) → (x &lt;&gt; (y &lt;&gt; z)) == ((x &lt;&gt; y) &lt;&gt; z)\nopen Monoids\n\\end{code}\n\n### Groups\n\n\\begin{code}\nmodule Groups where\n  record GroupStructure {ℓ} (M : Type ℓ) : Type ℓ where\n    constructor group-structure\n    field\n      -- A group is a monoid\n      _*_   : M → M → M\n      e     : M\n      lunit : ∀ x → (e * x) == x\n      runit : ∀ x → (x * e) == x\n      assoc : ∀ x y z → (x * (y * z)) == ((x * y) * z)\n\n      -- With inverses\n      ginv : M → M\n      glinv : ∀ g → (g * ginv g) == e\n      grinv : ∀ g → (ginv g * g) == e\n\n  record Group {ℓ} : Type (lsuc ℓ) where\n    constructor group\n    field\n      M : Type ℓ\n      str : GroupStructure M\n  open Group  public\nopen Groups\n\\end{code}\n\n### Naturals\n\n\\begin{code}\nmodule Naturals where\n\n  -- Addition of natural numbers\n  plus : ℕ → ℕ → ℕ\n  plus zero y = y\n  plus (succ x) y = succ (plus x y)\n\n  infixl 60 _+ₙ_\n  _+ₙ_ : ℕ → ℕ → ℕ\n  _+ₙ_ = plus\n\n  -- Lemmas about addition\n  plus-lunit : (n : ℕ) → zero +ₙ n == n\n  plus-lunit n = refl n\n\n  plus-runit : (n : ℕ) → n +ₙ zero == n\n  plus-runit zero = refl zero\n  plus-runit (succ n) = ap succ (plus-runit n)\n\n  plus-succ : (n m : ℕ) → succ (n +ₙ m) == (n +ₙ (succ m))\n  plus-succ zero     m = refl (succ m)\n  plus-succ (succ n) m = ap succ (plus-succ n m)\n\n  plus-succ-rs : (n m o p : ℕ) → n +ₙ m == o +ₙ p → n +ₙ (succ m) == o +ₙ (succ p)\n  plus-succ-rs n m o p α = inv (plus-succ n m) · ap succ α · (plus-succ o p)\n\n  -- Commutativity\n  plus-comm : (n m : ℕ) → n +ₙ m == m +ₙ n\n  plus-comm zero     m = inv (plus-runit m)\n  plus-comm (succ n) m = ap succ (plus-comm n m) · plus-succ m n\n\n  -- Associativity\n  plus-assoc : (n m p : ℕ) → n +ₙ (m +ₙ p) == (n +ₙ m) +ₙ p\n  plus-assoc zero     m p = refl (m +ₙ p)\n  plus-assoc (succ n) m p = ap succ (plus-assoc n m p)\n\n\n  -- Decidable equality\n  -- Encode-decode technique for natural numbers\n  private\n    code : ℕ → ℕ → Type₀\n    code 0        0        = ⊤\n    code 0        (succ m) = ⊥\n    code (succ n) 0        = ⊥\n    code (succ n) (succ m) = code n m\n\n  crefl : (n : ℕ) → code n n\n  crefl zero     = ★\n  crefl (succ n) = crefl n\n\n  private\n    encode : (n m : ℕ) → (n == m) → code n m\n    encode n m p = transport (code n) p (crefl n)\n\n    decode : (n m : ℕ) → code n m → n == m\n    decode zero zero c = refl zero\n    decode zero (succ m) ()\n    decode (succ n) zero ()\n    decode (succ n) (succ m) c = ap succ (decode n m c)\n\n  zero-not-succ : (n : ℕ) → ¬ (succ n == zero)\n  zero-not-succ n = encode (succ n) 0\n\n  -- The successor function is injective\n  succ-inj : {n m : ℕ} → (succ n == succ m) → n == m\n  succ-inj {n} {m} p = decode n m (encode (succ n) (succ m) p)\n\n  +-inj : (k : ℕ) {n m : ℕ} → (k +ₙ n == k +ₙ m) → n == m\n  +-inj zero   p = p\n  +-inj (succ k) p = +-inj k (succ-inj p)\n\n  nat-decEq : decEq ℕ\n  nat-decEq zero zero = inl (refl zero)\n  nat-decEq zero (succ m) = inr (λ ())\n  nat-decEq (succ n) zero = inr (λ ())\n  nat-decEq (succ n) (succ m) with (nat-decEq n m)\n  nat-decEq (succ n) (succ m) | inl p = inl (ap succ p)\n  nat-decEq (succ n) (succ m) | inr f = inr λ p → f (succ-inj p)\n\n  nat-isSet : isSet ℕ\n  nat-isSet = hedberg nat-decEq\n\n  -- Naturals form a monoid with addition\n  ℕ-plus-monoid : Monoid\n  ℕ-plus-monoid = record\n    { G = ℕ\n    ; GisSet = nat-isSet\n    ; _&lt;&gt;_ = plus\n    ; e = zero\n    ; lunit = plus-lunit\n    ; runit = plus-runit\n    ; assoc = plus-assoc\n    }\n\n  -- Ordering\n  _</p>",
  "content": "## Introduction\n\nThis is a basic overview of homotopy type theory (HoTT) formalized in Agda. It's\nonly one file and has been type-checked by Agda 2.5.4. No other libraries are\nrequired to type-check this file.\n\n{: .only-website }\n\n  **URL link**: [https://tinyurl.com/mini-hott](https://tinyurl.com/mini-hott).\n\nTo be consistent with homotopy type theory, we tell Agda to not use Axiom K for\ntype-checking by using the option `without-K`. Without Axiom K, Agda's `Set` is\nnot a good name for universes in HoTT and we rename `Set` to `Type`.\n\nThis code is working in progress and it's for my own learning purposes.\nPlease check out the references at the end of this article.\n\n\\begin{code}\n{-# OPTIONS --without-K #-}\n\nopen import Agda.Primitive using ( Level ; lsuc; lzero; _⊔_ ) public\n\nType : (ℓ : Level) → Set (lsuc ℓ)\nType ℓ = Set ℓ\n\nType₀ : Type (lsuc lzero)\nType₀ = Type lzero\n\\end{code}\n\n## Basic types\n\n### Empty type\n\nThe Empty type, representing falsehood.\n\n\\begin{code}\n-- A datatype without constructors is the empty type.\ndata ⊥ {ℓᵢ} : Type ℓᵢ where\n\n-- synonyms of ⊥\nEmpty = ⊥\n𝟘     = ⊥\n\\end{code}\n\nIts eliminator:\n\n\\begin{code}\n-- Ex falso quodlibet\nexfalso\n  : ∀ {ℓ ℓᵢ} {A : Type ℓ} → ⊥ {ℓᵢ} → A\n\nexfalso ()\n\n-- synonyms of exfalso\nEmpty-elim = exfalso\n⊥-elim     = exfalso\n\\end{code}\n\nA useful convention\n\\begin{code}\n-- Negation\n¬\n  : ∀ {ℓ} → Type ℓ → Type ℓ\n\n¬ A = (A → ⊥ {lzero})\n\\end{code}\n\n### Unit type\n\nThe unit type is defined as record so that we also get the η-rule\ndefinitionally.\n\nNo elimination rule.\n\\begin{code}\nrecord ⊤ : Type₀ where\n  constructor ★\n\n{-# BUILTIN UNIT ⊤ #-}\n\n-- synonyms for the data constructor\nunit = ★\n\n-- synonyms for the Unit type\nUnit = ⊤\n𝟙    = ⊤\n\\end{code}\n\n### Σ-type\n\nSigma types are a particular case of records, but records can be constructed\nusing only sigma types. Note that l ⊔ q is the maximum of two hierarchy levels l\nand q. This way, we define sigma types in full generality, at each universe.\n\n\\begin{code}\ninfixr 60 _,_\nrecord Σ {ℓᵢ ℓⱼ} (A : Type ℓᵢ)(C : A → Type ℓⱼ) : Type (ℓᵢ ⊔ ℓⱼ) where\n  constructor _,_\n  field\n    π₁ : A\n    π₂ : C π₁\n\n  -- synonyms for data constructors\n  proj₁ = π₁\n  proj₂ = π₂\n  fst   = π₁\n  snd   = π₂\nopen Σ public\n\\end{code}\n\n### Π-types\nShorter notation for Π-types.\n\n\\begin{code}\nΠ\n  : ∀ {ℓᵢ ℓⱼ}\n  → (A : Type ℓᵢ) (P : A → Type ℓⱼ)\n  --------------------------------\n  → Type (ℓᵢ ⊔ ℓⱼ)\n\nΠ A P = (x : A) → P x\n\\end{code}\n\n### Product type\n\nProduct type as a particular case of the sigma\n\n\\begin{code}\n_×_\n  : ∀ {ℓᵢ ℓⱼ}\n  → (A : Type ℓᵢ) (B : Type ℓⱼ)\n  ----------------------------\n  → Type (ℓᵢ ⊔ ℓⱼ)\n\nA × B = Σ A (λ _ → B)\n\\end{code}\n\n### Coproduct\n\nSum types as inductive types\n\n\\begin{code}\ninfixr 80 _+_\ndata _+_ {ℓᵢ ℓⱼ} (A : Type ℓᵢ) (B : Type ℓⱼ) : Type (ℓᵢ ⊔ ℓⱼ) where\n  inl : A → A + B\n  inr : B → A + B\n\\end{code}\n\n### Boolean\n\nBoolean type, two constants true and false\n\n\\begin{code}\ndata Bool : Type₀ where\n  true  : Bool\n  false : Bool\n\\end{code}\n\n*Booleans can be also defined using the coproduct.*\n\n### Natural numbers\n\nNatural numbers are the initial algebra for a constant and a\nsuccessor function. The `BUILTIN` declaration allows us to use\nnatural numbers in Arabic notation.\n\n\\begin{code}\ndata ℕ : Type₀ where\n  zero : ℕ\n  succ : ℕ → ℕ\n\n{-# BUILTIN NATURAL ℕ #-}\n\n-- synonyms for natural numbers\nNat = ℕ\n\\end{code}\n\n## Functions\n\n### Identity function\n\nThe identity function with implicit type.\n\\begin{code}\nid\n  : ∀ {ℓ} {A : Type ℓ}\n  → A → A\n\nid = λ x → x\n\\end{code}\n\nThe identity function on a type `A` is `idf A`.\n\n\\begin{code}\nidf\n  : ∀ {ℓᵢ}\n  → (A : Type ℓᵢ)\n  ---------------\n  → (A → A)\n\nidf A = λ x → x\n\\end{code}\n\n### Constant function\n\nConstant function at some point `b` is `cst b`\n\n\\begin{code}\ncst\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ}\n  → (b : B)\n  ---------\n  → (A → B)\n\ncst b = λ _ → b\n\\end{code}\n\n### Composition\n\nA more sophisticated composition function that can handle dependent functions.\n\n\\begin{code}\n_∘_\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : A → Type ℓⱼ} {C : (a : A) → (B a → Type ℓₖ)}\n  → (g : {a : A} → Π (B a) (C a))\n  → (f : Π A B)\n  -------------------------------\n  → Π A (λ a → C a (f a))\n\ng ∘ f = λ x → g (f x)\ninfixr 80 _∘_\n\\end{code}\n\nSynonym for composition (diagrammatic version)\n\\begin{code}\n_//_\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : A → Type ℓⱼ} {C : (a : A) → (B a → Type ℓₖ)}\n  → (f : Π A B)\n  → (g : {a : A} → Π (B a) (C a))\n  -------------------------------\n  → Π A (λ a → C a (f a))\n\nf // g = g ∘ f\n\\end{code}\n\n### Application\n\n\\begin{code}\ninfixr 0 _$_\n_$_\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : A → Type ℓⱼ}\n  → (∀ x → B x)\n  -------------\n  → (∀ x → B x)\n\nf $ x = f x\n\\end{code}\n\n### Curryfication\n\n\\begin{code}\ncurry\n  : ∀ {i j k} {A : Type i} {B : A → Type j} {C : Σ A B → Type k}\n  → (∀ s → C s)\n  ---------------------\n  → (∀ x y → C (x , y))\n\ncurry f x y = f (x , y)\n\\end{code}\n\n### Uncurryfication\n\n\\begin{code}\nuncurry\n  : ∀ {i j k} {A : Type i} {B : A → Type j} {C : ∀ x → B x → Type k}\n  → (∀ x y → C x y)\n  -------------------------\n  → (∀ s → C (π₁ s) (π₂ s))\n\nuncurry f (x , y) = f x y\n\\end{code}\n\n### Instance search\n\n\\begin{code}\n-- how to use it ❓\n⟨⟩\n  : ∀ {i} {A : Type i}  → A\n\n⟨⟩  = a\n\\end{code}\n\n## Equality type\n\nIn HoTT, we have a different interpretation of type theory in which the\nset-theoretical notion of *sets* for *types* is replaced by the topological\nnotion of *spaces*. A type judgment like `x : A` means that the point `x`‌‌ is\n*in* the topological space `A`‌‌. Furthermore, we include the *Identity type* as\na primary type. The inhabitants of these identity types will not be longer\ninterpreted as *proofs of equalities* but as *paths* in a Path space, an\nIdentity type.\n\n### Homogeneous equality\n\nThe Identity type is defined as an inductive type. Its induction principle is\nthe J-eliminator.\n\n\\begin{code}\ndata _==_ {ℓᵢ} {A : Type ℓᵢ} (a : A) : A → Type ℓᵢ where\n  idp : a == a\n\ninfix 30 _==_\n{-# BUILTIN EQUALITY _==_ #-}\n\n-- synonyms for identity type\nPath = _==_\n\\end{code}\n\n\\begin{code}\nrefl\n  : ∀ {ℓᵢ} {A : Type ℓᵢ}\n  → (a : A)\n  ---------\n  → a == a\n\nrefl {ℓᵢ}{A} a = idp {ℓᵢ = ℓᵢ}{A = A}\n\\end{code}\n\n#### J eliminator\n\nThe elimination principle for the identity type is the path induction. It allows\nus to define an outgoing function from the identity type to a dependent type ‌‌\nas we see in the `J` definition below.\n\n*Paulin-Mohring J rule*\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {a : A}\n  → (B : (a' : A) (p : a == a') → Type ℓⱼ)\n  → (d : B a idp)\n  ----------------------------------------\n  → {a' : A} (p : a == a') → B a' p\n\nJ {a = a} B d idp = d\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ'\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {a : A}\n  → (B : (a' : A) (p : a' == a) → Type ℓⱼ)\n  → (d : B a idp)\n  ----------------------------------------\n  → {a' : A} (p : a' == a) → B a' p\n\nJ' {a = a} B d idp = d\n\\end{code}\n\n#### Composition of paths\n\n{: .foldable until=\"6\" }\n\\begin{code}\n_·_\n  : ∀ {ℓ} {A : Type ℓ} {x y z : A}\n  → (p : x == y)\n  → (q : y == z)\n  --------------\n  → x == z\n\n_·_ idp q = q\n\ninfixl 50 _·_\n\\end{code}\n\n![path](/assets/ipe-images/path-concatenation.png){: width=\"60%\" }\n\n#### Inverse of paths\n\n\\begin{code}\ninv\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → a == b\n  --------\n  → b == a\n\ninv idp = idp\n\n-- synonyms for inverse path\ninfixl 60 _⁻¹\n_⁻¹ = inv\n\ninfixr 60 !_\n!_  = inv\n\\end{code}\n\n#### Associativity of composition\n\n- Left associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\n∘-lassoc\n  : ∀ {ℓ} {A B C D : Type ℓ}\n  → (h : C → D) → (g : B → C) → (f : A → B)\n  -----------------------------------------\n  → (h ∘ (g ∘ f)) == ((h ∘ g) ∘ f)\n\n∘-lassoc h g f = idp {a = (λ x → h (g (f x)))}\n\\end{code}\n\n- Right associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\n∘-rassoc\n  : ∀ {ℓ} {A B C D : Type ℓ}\n  → (h : C → D) → (g : B → C) → (f : A → B)\n  -----------------------------------------\n  → ((h ∘ g) ∘ f) == (h ∘ (g ∘ f))\n\n∘-rassoc h g f = (∘-lassoc h g f) ⁻¹\n\\end{code}\n\n### Heterogeneous equality\n\n\\begin{code}\ndata HEq {ℓ} (A : Type ℓ)\n           : (B : Type ℓ)\n           → (α : A == B) (a : A) (b : B)\n           → Type ℓ where\n  idp : ∀ {a : A} → HEq A A idp a a\n\\end{code}\n\n## Equational reasoning\n\nEquational reasoning is a way to write readable chains of equalities.\n\n\n```agda\n  t : a == e\n  t = a =⟨ p ⟩\n      b =⟨ q ⟩\n      c =⟨ r ⟩\n      d =⟨ s ⟩\n      e ∎\n```\n\n\nwhere `p` is a path from `a` to `b`, `q` is a path from `b` to `c`, and so on.\n\n\\begin{code}\nmodule EquationalReasoning {ℓᵢ} {A : Type ℓᵢ} where\n\\end{code}\n\nDefinitional equals:\n\n\\begin{code}\n  _==⟨⟩_\n    : ∀ (x {y} : A)\n    → x == y → x == y\n\n  _ ==⟨⟩ p = p\n\n  -- synonyms for _==⟨⟩\n  _==⟨idp⟩_  = _==⟨⟩_\n  _==⟨refl⟩_ = _==⟨⟩_\n\n  infixr 2 _==⟨⟩_\n\\end{code}\n\n\\begin{code}\n  -- chain\n  _==⟨_⟩_\n    : (x : A) {y z : A}\n    → x == y\n    → y == z\n    → x == z\n\n  _ ==⟨ thm ⟩ q = thm · q\n\n  infixr 2 _==⟨_⟩_\n\\end{code}\n\n\\begin{code}\n  -- Q.E.D\n  infix 3 _∎\n  _∎\n    : (x : A)\n    → x == x\n\n  _∎ = λ x → idp\n\\end{code}\n\n\\begin{code}\n  -- Begin\n  infix 1 begin_\n  begin_\n    : {x y : A}\n    → x == y\n    → x == y\n\n  begin_ p = p\n\\end{code}\n\n\\begin{code}\nopen EquationalReasoning public\n\\end{code}\n## Actions on paths\n\nFunctions are functors to equalities.  In other words, functions\npreserve equalities.\n\n{: .foldable until=\"6\" }\n\\begin{code}\nap\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ}\n  → (f : A → B) {a₁ a₂ : A}\n  → a₁ == a₂\n  --------------\n  → f a₁ == f a₂\n\nap f idp = idp\n\\end{code}\n\nNow, we can define a convenient syntax sugar for `ap` in\nequational reasoning.\n\n\\begin{code}\ninfixl 40 ap\nsyntax ap f p = p |in-ctx f\n\\end{code}\n\nLet's suppose we have a lemma:\n\n```agda\n  lemma : a == b\n  lemma = _\n```\n\nused in an equational reasoning like:\n\n```agda\n  t : a == e\n  t = f a =⟨ ap f lemma ⟩\n      f b\n      ∎\n```\n\n\nThen, we can now put the lemma in front:\n\n```agda\n  t : a == e\n  t = f a =⟨ lemma |in-ctx f ⟩\n      f b\n      ∎\n```\n\n\nLastly, we can also define actions on two paths:\n\n{: .foldable until=\"7\" }\n\\begin{code}\nap₂\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {C : Type ℓₖ}  {b₁ b₂ : B}\n  → (f : A → B → C)\n  → {a₁ a₂ : A} → (a₁ == a₂)\n  → {b₁ b₂ : B} → (b₁ == b₂)\n  --------------------------\n  → f a₁ b₁  == f a₂ b₂\n\nap₂ f idp idp = idp\n\\end{code}\n\n### Lemmas\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-·\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {a b c : A}\n  → (f : A → B) → (p : a == b) → (q : b == c)\n  -------------------------------------------\n  → ap f (p · q) == ap f p · ap f q\n\nap-· f idp q = refl (ap f q)\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-inv\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {a b : A}\n  → (f : A → B) → (p : a == b)\n  ----------------------------\n  → ap f (p ⁻¹) == (ap f p) ⁻¹\n\nap-inv f idp = idp\n\n-- synonyms\nap-! = ap-inv\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\nap-comp\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {C : Type ℓₖ} {a b : A}\n  → (f : A → B)\n  → (g : B → C)\n  → (p : a == b)\n  -------------------------------\n  → ap g (ap f p) == ap (g ∘ f) p\n\nap-comp f g idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-id\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a b : A}\n  → (p : a == b)\n  --------------\n  → ap id p == p\n\nap-id idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-const\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {C : Type ℓⱼ} {a b : A} {c : C}\n  → (p : a == b)\n  -----------------------\n  → ap (λ _ → c) p == idp\n\nap-const {c = c} idp = refl (refl c)\n\\end{code}\n\n## Properties on the groupoid\n\nSome properties on the groupoid structure of equalities\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-runit\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  --------------\n  → p == p · idp\n\n·-runit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-lunit\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  --------------\n  → p == idp · p\n\n·-lunit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-linv\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  ----------------\n  → ! p · p == idp\n\n·-linv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-rinv\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  ----------------\n  → p · ! p == idp\n\n·-rinv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ninvolution\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → {p : a == b}\n  ---------------\n  → ! (! p) == p\n\ninvolution {p = idp} = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-assoc\n  : ∀ {ℓ} {A : Type ℓ} {a b c d : A}\n  → (p : a == b) → (q : b == c) → (r : c == d)\n  --------------------------------------------\n  → p · q · r == p · (q · r)\n\n·-assoc idp q r = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\n·-cancellation\n  : ∀ {ℓ} {A : Type ℓ} {a : A}\n  → (p : a == a) → (q : a == a)\n  → p · q == p\n  -----------------------------\n  → q == refl a\n\n·-cancellation {a = a} p q α =\n    begin\n      q             ==⟨ ap (_· q) (! (·-linv p)) ⟩\n      ! p · p · q   ==⟨ (·-assoc (! p) _ _) ⟩\n      ! p · (p · q) ==⟨ (ap (! p ·_) α) ⟩\n      ! p · p       ==⟨ ·-linv p ⟩\n      refl a\n    ∎\n\\end{code}\n\nMoving a term from one side to the other is a common task,\nso let's define some handy functions for that.\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-left-to-right-l\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  → p · q == r\n  ------------------\n  →     q == ! p · r\n\n·-left-to-right-l {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    q\n      ==⟨ ·-lunit q ⟩\n    refl b · q\n      ==⟨ ap (_· q) (! (·-linv p)) ⟩\n    (! p · p) · q\n      ==⟨ ·-assoc (! p) p q ⟩\n    ! p · (p · q)\n      ==⟨ ap (! p ·_) α ⟩\n    ! p · r\n  ∎\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-left-to-right-r\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  → p · q == r\n  -------------------\n  →      p == r · ! q\n\n·-left-to-right-r {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    p\n      ==⟨ ·-runit p ⟩\n    p · refl b\n      ==⟨ ap (p ·_) (! (·-rinv q)) ⟩\n    p · (q · ! q)\n      ==⟨ ! (·-assoc p q (! q)) ⟩\n    (p · q) · ! q\n      ==⟨ ap (_· ! q) α ⟩\n    r · ! q\n  ∎\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-right-to-left-r\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  →       p == q · r\n  -------------------\n  → p · ! r == q\n\n·-right-to-left-r {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    p · ! r\n      ==⟨ ap (_· ! r) α ⟩\n    (q · r) · ! r\n      ==⟨ ·-assoc q r (! r) ⟩\n    q · (r · ! r)\n      ==⟨ ap (q ·_) (·-rinv r) ⟩\n    q · refl b\n      ==⟨ ! (·-runit q) ⟩\n    q\n    ∎\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\n·-right-to-left-l\n  : ∀ {ℓ} {A : Type ℓ} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  →       p == q · r\n  ------------------\n  → ! q · p == r\n\n·-right-to-left-l {a = a}{b = b}{c = c} {p} {q} {r} α =\n  begin\n    ! q · p\n      ==⟨ ap (! q ·_) α ⟩\n    ! q · (q · r)\n      ==⟨ ! (·-assoc (! q) q r) ⟩\n    ! q · q · r\n      ==⟨ ap (_· r) (·-linv q) ⟩\n    refl b · r\n      ==⟨ ! (·-lunit r) ⟩\n    r\n  ∎\n\\end{code}\n\nFinally, when we invert a path composition this is what we got.\n\n{: .foldable until=\"6\" }\n\\begin{code}\n!-·\n  : ∀ {ℓ} {A : Type ℓ} {a b : A}\n  → (p : a == b)\n  → (q : b == a)\n  --------------------------\n  → ! (p · q) == ! q · ! p\n\n!-· idp q = ·-runit (! q)\n\\end{code}\n\n## Transport\n\n![path](/assets/ipe-images/transport-fiber-minihott.png){: width=\"60%\" }\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ}\n  → (C : A → Type ℓⱼ) {a₁ a₂ : A}\n  → (p : a₁ == a₂)\n  -------------------------------\n  → (C a₁ → C a₂)\n\ntransport C idp = (λ x → x)\n\\end{code}\n\n\\begin{code}\n-- synonyms\ntr     = transport\ntransp = transport\n\\end{code}\n\nStar notation for transport\n\n{: .foldable until=\"5\" }\n\\begin{code}\n_✶\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {C : A → Type ℓⱼ} {a₁ a₂ : A}\n  → (p : a₁ == a₂)\n  ----------------\n  → (C a₁ → C a₂)\n\n_✶ {ℓᵢ}{ℓⱼ}{C = C} = transport {ℓᵢ = ℓᵢ} {ℓⱼ = ℓⱼ} C\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ncoe\n  : ∀ {ℓ} {A B : Type ℓ}\n  → A == B\n  ---------\n  → (A → B)\n\ncoe p A = transport (λ X → X) p A\n\\end{code}\n\n### Pathover\n\nLet be `A : Type`, `a₁, a₂ : A`, `C : A → Type`, `c₁ : C a₁` and `c₂ : C a₂`.\nUsing the same notation from (Univalent Foundations Program, 2013), one of the definitions for the\nPathover type is as the shorthand for the path between the transport along a\npath `α : a₁ = a₂` of the point `c₁ : C a₁` and the point `c₂` in the fiber `C\na₂`. That is, a pathover is a term that inhabit the type `transport C α c₁ = c₂`\nalso denoted by `PathOver C α c₁ c₂`.\n\n![path](/assets/ipe-images/pathover-3-minihott.png){: width=\"60%\" }\n\n\\begin{code}\nPathOver\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ}(C : A → Type ℓⱼ) {a₁ a₂ : A}\n  → (α : a₁ == a₂) (c₁ : C a₁) (c₂ : C a₂)\n  ----------------------------------------\n  → Type ℓⱼ\n\nPathOver C α c₁ c₂ = tr C α c₁ == c₂\n\\end{code}\n\n\\begin{code}\ninfix 30 PathOver\nsyntax PathOver B p u v = u == v [ B ↓ p ]\n\\end{code}\n\n### Lemmas\n\nSome lemmas on the transport operation\n\n{: .foldable until=\"6\" }\n\\begin{code}\nlift\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a₁ a₂ : A} {ℓⱼ} {C : A → Type ℓⱼ}\n  → (u : C a₁)\n  → (α : a₁ == a₂)\n  -----------------------------\n  → (a₁ , u) == (a₂ , tr C α u)\n\nlift {a₁ = a₁} u idp = refl (a₁ , u)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-const\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a₁  a₂ : A} {ℓⱼ} {B : Type ℓⱼ}\n  → (p : a₁ == a₂)\n  → (b : B)\n  -----------------------\n  → tr (λ _ → B) p b == b\n\ntransport-const idp b = refl b\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-r\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a : A} {x y : A}\n  → (p : x == y)\n  → (q : a == x)\n  ---------------------------------\n  →  tr (λ x → a == x) p q == q · p\n\ntransport-concat-r idp q = ·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-l\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {a : A} {x y : A}\n  → (p : x == y)\n  → (q : x == a)\n  ----------------------------------\n  → tr (λ x → x == a) p q == ! p · q\n\ntransport-concat-l idp q = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {x y : A}\n  → (p : x == y)\n  → (q : x == x)\n  ---------------------------------------\n  → tr (λ x → x == x) p q == ! p · q · p\n\ntransport-concat idp q = ·-runit q\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {ℓⱼ} {B : Type ℓⱼ}\n  → (f g : A → B) {x y : A}\n  → (p : x == y)\n  → (q : f x == g x)\n  --------------------------------------------------------\n  → tr (λ z → f z == g z) p q == ! (ap f p) · q · (ap g p)\n\ntransport-eq-fun f g idp q = ·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-comp\n  : ∀ {ℓᵢ} {A : Type ℓᵢ}{ℓⱼ} {a b c : A} {P : A → Type ℓⱼ}\n  → (p : a == b)\n  → (q : b == c)\n  ---------------------------------------\n  → ((tr P q) ∘ (tr P p)) == tr P (p · q)\n\ntransport-comp {P = P} idp q = refl (transport P q)\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-comp-h\n  : ∀ {ℓᵢ} {A : Type ℓᵢ} {ℓⱼ} {a b c : A} {P : A → Type ℓⱼ}\n  → (p : a == b)\n  → (q : b == c)\n  → (x : P a)\n  -------------------------------------------\n  → ((tr P q) ∘ (tr P p)) x == tr P (p · q) x\n\ntransport-comp-h {P = P} idp q x = refl (transport P q x)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-eq-fun-l\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {b : B} (f : A → B) {x y : A}\n  → (p : x == y)\n  → (q : f x == b)\n  -------------------------------------------\n  → tr (λ z → f z == b) p q == ! (ap f p) · q\n\ntransport-eq-fun-l {b = b} f p q =\n  begin\n    transport (λ z → f z == b) p q   ==⟨ transport-eq-fun f (λ _ → b) p q ⟩\n    ! (ap f p) · q · ap (λ _ → b) p  ==⟨ ap (! (ap f p) · q ·_) (ap-const p) ⟩\n    ! (ap f p) · q · idp             ==⟨ ! (·-runit _) ⟩\n    ! (ap f p) · q\n  ∎\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun-r\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} {b : B}\n  → (g : A → B) {x y : A}\n  → (p : x == y)\n  → (q : b == g x)\n  ------------------------------------------------\n  → tr (λ z → b == g z) p q == q · (ap g p)\n\ntransport-eq-fun-r {b = b} g p q =\n  begin\n    transport (λ z → b == g z) p q    ==⟨ transport-eq-fun (λ _ → b) g p q ⟩\n    ! (ap (λ _ → b) p) · q · ap g p   ==⟨ ·-assoc (! (ap (λ _ → b) p)) q (ap g p) ⟩\n    ! (ap (λ _ → b) p) · (q · ap g p) ==⟨ ap (λ u → ! u · (q · ap g p)) (ap-const p) ⟩\n    (q · ap g p)\n  ∎\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-inv\n  : ∀ {ℓᵢ ℓⱼ} {X : Type ℓᵢ}{A : X → Type ℓⱼ}{x y : X}\n  → (p : x == y)\n  → {a : A y}\n  --------------------------------------\n  → tr (λ v → A v) p (tr A (! p) a) == a\n\ntransport-inv {A = A}  idp {a = a} =\n  begin\n    tr (λ v → A v) idp (tr A (! idp) a)\n      ==⟨ idp ⟩\n    tr A (! idp · idp) a\n      ==⟨⟩\n    tr A idp a\n      ==⟨ idp ⟩\n    a\n  ∎\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-l\n  : ∀ {ℓ} {A B : Type ℓ}\n  → (p : A == B)\n  → (b : B)\n  --------------------------------------------\n  → tr (λ v → v) p (tr (λ v → v) (! p) b) == b\n\ncoe-inv-l idp b = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-r\n  : ∀ {ℓ} {A B : Type ℓ}\n  → (p : A == B)\n  → (a : A)\n  -----------------------------------------------------------\n  → tr (λ v → v) (! p) (tr (λ v → v) p a) == a\n\ncoe-inv-r idp b = idp\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-family\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {P : B → Type ℓₖ}\n  → {f : A → B} → {x y : A}\n  → (p : x == y)\n  → (u : P (f x))\n  -----------------------------------\n  → tr (P ∘ f) p u == tr P (ap f p) u\n\ntransport-family idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-family-id\n  : ∀ {ℓᵢ ℓₖ} {A : Type ℓᵢ} {P : A → Type ℓₖ} → {x y : A}\n  → (p : x == y)\n  → (u : P x)\n  ----------------------------------------------\n  → transport (λ a → P a) p u == transport P p u\n\ntransport-family-id idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-fun\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {x y : X} {A : X → Type ℓⱼ} {B : X → Type ℓₖ}\n  → (p : x == y)\n  → (f : A x → B x)\n  -----------------------------------------------------------------\n  → tr (λ x → (A x → B x)) p f == (λ x → tr B p (f (tr A (! p) x)))\n\ntransport-fun idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth = transport-fun\n\\end{code}\n\n![path](/assets/ipe-images/transport-fun.png){: width=\"100%\" }\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-fun-h\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {A : X → Type ℓⱼ} {B : X → Type ℓₖ}\n  → {x y : X}\n  → (p : x == y) → (f : A x → B x)\n  → (b : A y)\n  --------------------------------------------------------------\n  → (tr (λ x → (A x → B x)) p f) b == tr B p (f (tr A (! p) b))\n\ntransport-fun-h idp f b = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth-h = transport-fun-h\n\\end{code}\n\nNow, when we transport dependent functions this is what we got:\n\n![path](/assets/ipe-images/transport-fun-dependent.png){: width=\"100%\" }\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent-h\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}\n  → {B : (x : X) → (a : A x) → Type ℓₖ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  ---------------------------------------------------------------------\n  → (a' : A y)\n  → (tr (λ x → (a : A x) → B x a) p f) a'\n    == tr (λ w → B (π₁ w) (π₂ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent-h idp f a' = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth-h = transport-fun-dependent-h\n\\end{code}\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent\n  : ∀ {ℓᵢ ℓⱼ ℓₖ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}\n  → {B : (x : X) → (a : A x) → Type ℓₖ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  ---------------------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f)\n    == λ (a' : A y)\n      → tr (λ w → B (π₁ w) (π₂ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth = transport-fun-dependent\n\\end{code}\n\nAction on PathOvers, this was suggested by Fredrik Nordvall:\n\n{: .foldable until=\"9\"}\n\\begin{code}\napOver\n  : {A A' : Type₀} {C : A → Type₀} {C' : A' → Type₀}  -- types\n  → {a a' : A} {b : C a} {b' : C a'}                  -- points\n  → (f : A → A')\n  → (g : {x : A} → C x → C' (f x))\n  → (p : a == a')\n  → b == b' [ C ↓ p ]\n  --------------------------------\n  → g b == g b' [ C' ↓ ap f p ]\n\napOver f g idp q = ap g q\n\\end{code}\n\n## Basic type lemmas\n\n### Sigma type\n\nOur context:\n\n\\begin{code}\nmodule Sigma {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : A → Type ℓⱼ} where\n\\end{code}\n\nTwo dependent pairs are equal if they are componentwise equal.\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Σ-componentwise\n    : {v w : Σ A P}\n    → v == w\n    ----------------------------------------------\n    → Σ (π₁ v == π₁ w) (λ p → (p ✶) (π₂ v) == π₂ w)\n\n  Σ-componentwise  idp = (idp , idp)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Σ-bycomponents\n    : {v w : Σ A P}\n    → Σ (π₁ v == π₁ w) (λ p → (p ✶) (π₂ v) == π₂ w)\n    -----------------------------------------------\n    → v == w\n\n  Σ-bycomponents (idp , idp) = idp\n\n  -- synonym of Σ-bycomponents\n  pair= = Σ-bycomponents\n\\end{code}\n\nA trivial consequence is the following identification:\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  lift-pair=\n    : ∀ {x y : A} {u : P x}\n    → (p : x == y)\n    --------------------------------------------------------\n    → lift {A = A}{C = P} u p == pair= (p , refl (tr P p u))\n\n  lift-pair= idp = idp\n\\end{code}\n\n\\begin{code}\n-- Uniqueness principle property for products\n  uppt : (x : Σ A P) → (π₁ x , π₂ x) == x\n  uppt (a , b) = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  Σ-ap-π₁\n    : {a₁ a₂ : A} {b₁ : P a₁} {b₂ : P a₂}\n    → (α : a₁ == a₂)\n    → (γ : transport P α b₁ == b₂)\n    ------------------------------\n    → ap π₁ (pair= (α , γ)) == α\n\n  Σ-ap-π₁ idp idp = idp\n\n  -- synonym for this lemma\n  ap-π₁-pair= = Σ-ap-π₁\n\\end{code}\n\n\\begin{code}\nopen Sigma public\n\\end{code}\n\n{: .foldable until=\"10\"}\n\\begin{code}\ntransport-fun-dependent-bezem\n  : ∀ {ℓᵢ ℓⱼ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}\n      {B : (x : X) → (a : A x) → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (a' : A y)\n  ----------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f) a'\n    == tr (λ w → B (π₁ w) (π₂ w))\n          (pair= (p , transport-inv p )) (f (tr A (! p) a'))\n\ntransport-fun-dependent-bezem idp f a' = idp\n\\end{code}\n\n### Cartesian product\n\n\\begin{code}\nmodule CartesianProduct {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodComponentwise\n    : {x y : A × B}\n    → (x == y)\n    ---------------------------------\n    → (π₁ x == π₁ y) × (π₂ x == π₂ y)\n\n  prodComponentwise {x = x} idp = refl (π₁ x) , refl (π₂ x)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByComponents\n    : {x y : A × B}\n    → (π₁ x == π₁ y) × (π₂ x == π₂ y)\n    ---------------------------------\n    → (x == y)\n\n  prodByComponents {x = a , b} (idp , idp) = refl (a , b)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodCompInverse\n    : {x y : A × B}\n    → (b : (π₁ x == π₁ y) × (π₂ x == π₂ y))\n    ---------------------------------------------\n    → prodComponentwise (prodByComponents b) == b\n\n  prodCompInverse {x} (idp , idp) = refl (refl (π₁ x) , refl (π₂ x))\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByCompInverse\n    : {x y : A × B}\n    → (b : x == y)\n    ---------------------------------------------\n    → prodByComponents (prodComponentwise b) == b\n\n  prodByCompInverse {x = x} idp = refl (refl x)\n\\end{code}\n\n\\begin{code}\nopen CartesianProduct\n\\end{code}\n\n## Action on dependent paths\n\n{: .foldable until=\"5\"}\n\\begin{code}\napd\n  : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ}  {P : A → Type ℓⱼ} {a b : A}\n  → (f : (a : A) → P a) → (p : a == b)\n  ------------------------------------\n  → transport P p (f a) == f b\n\napd f idp = idp\n\\end{code}\n\n## Homotopy\n\n> In a type-theoretical sense, a homotopy between two\n> functions is a family of equalities between their applications.\n\nThe context:\n\\begin{code}\nmodule Homotopy {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : A → Type ℓⱼ} where\n\\end{code}\n\nLet $$f , g : \\prod\\limits_{(x:A)} P(x)$$ be two sections of a\ntype family $$P : A \\to \\mathcal{U}$$. A **homotopy** from $$f$$ to $$g$$\nis a dependent function of type\n\n{: .equation }\n  $$ (f \\sim g) :\\equiv \\prod\\limits_{x : A} (f(x) = g(x)). $$\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Lemma.\n  homotopy\n    : (f g : Π A P)\n    ---------------\n    → Type (ℓᵢ ⊔ ℓⱼ)\n\n  homotopy f g = ∀ (x : A) → f x == g x\n\\end{code}\n\n\\begin{code}\n  -- Usual notation for homotopy\n  _∼_ : (f g : ((x : A) → P x)) → Type (ℓᵢ ⊔ ℓⱼ)\n  f ∼ g = homotopy f g\n\\end{code}\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Homotopy is an equivalence relation\n  h-refl\n    : (f : Π A P)\n    -------------\n    → f ∼ f\n\n  h-refl f x = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  h-sym\n    : (f g : Π A P)\n    → f ∼ g\n    -------\n    → g ∼ f\n\n  h-sym _ _ e x = ! (e x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-comp\n    : {f g h : Π A P}\n    → f ∼ g\n    → g ∼ h\n    -------\n    → f ∼ h\n\n  h-comp u v x = (u x) · (v x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- synonym for h-comp\n  _●_\n    : {f g h : Π A P}\n    → f ∼ g\n    → g ∼ h\n    -------\n    → f ∼ h\n\n  α ● β = h-comp α β\n\\end{code}\n\n\\begin{code}\nopen Homotopy public\n\\end{code}\n\n### Composition with homotopies\n\n\\begin{code}\nmodule HomotopyComposition {ℓᵢ ℓⱼ ℓₖ} {A : Type ℓᵢ} {B : Type ℓⱼ} {C : Type ℓₖ} where\n\\end{code}\n\n{: .foldable until=\"8\"}\n\\begin{code}\n  -- Lemma.\n  hl-comp\n    : {f g : A → B}\n    → {j k : B → C}\n    → f ∼ g\n    → j ∼ k\n    -------------------\n    → (j ∘ f) ∼ (k ∘ g)\n\n  hl-comp {g = g}{j = j} f-g j-k = λ x → ap j (f-g x) · j-k (g x)\n\\end{code}\n\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  rcomp-∼\n    : (f : A → B)\n    → {j k : B → C}\n    → j ∼ k\n    -------------------\n    → (j ∘ f) ∼ (k ∘ f)\n\n  rcomp-∼ f j-k = hl-comp (h-refl f) j-k\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  lcomp-∼\n    : {f g : A → B}\n    → (j : B → C)\n    → f ∼ g\n    -------------------\n    → (j ∘ f) ∼ (j ∘ g)\n\n  lcomp-∼ j α = hl-comp α (h-refl j)\n\\end{code}\n\n\\begin{code}\nopen HomotopyComposition\n\\end{code}\n\n### Naturality\n\n\\begin{code}\nmodule Naturality {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\\end{code}\n\nHomotopy is natural, meaning that it satisfies the following\nsquare commutative diagram.\n\n![path](/assets/ipe-images/h-naturality.png){: width=\"40%\" }\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-naturality\n    : {f g : A → B} → {x y : A}\n    → (H : f ∼ g)\n    → (p : x == y)\n    ------------------------------\n    → H x · ap g p == ap f p · H y\n\n  h-naturality {x = x} H idp = ! (·-runit (H x))\nopen Naturality\n\\end{code}\n\nA particular case of naturality on the identity function.\n\n{: .foldable until=\"5\"}\n\\begin{code}\nh-naturality-id\n  : ∀ {ℓ} {A : Type ℓ} {f : A → A} → {x : A}\n  → (H : f ∼ id)\n  -----------------------\n  → H (f x) == ap f (H x)\n\nh-naturality-id {f = f} {x = x} H =\n  begin\n    H (f x)\n      ==⟨ ·-runit (H (f x)) ⟩\n    H (f x) · refl (f x)\n      ==⟨ ap (H (f x) ·_) (! (·-rinv (H x))) ⟩\n    H (f x) · ((H x) · (! (H x)))\n      ==⟨ ap (H (f x) ·_) (ap (_· (! (H x))) (! ap-id (H x))) ⟩\n    H (f x) · (ap id (H x) · ! (H x))\n      ==⟨ ! (·-assoc (H (f x)) (ap id (H x)) (! (H x))) ⟩\n    (H (f x) · ap id (H x)) · ! (H x)\n      ==⟨ ·-right-to-left-r (h-naturality H (H x)) ⟩\n    ap f (H x)\n  ∎\n\\end{code}\n\n## .... REVIWING .... BELOW\n\n## Fibers\n\nContractible types with a center of contraction.\n\n\\begin{code}\nmodule Fibers {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ}  where\n\n  -- The fiber of a map over a point is given by\n  fib\n    : (f : A → B)\n    → (b : B)\n    ---------------\n    → Type (ℓᵢ ⊔ ℓⱼ)\n\n  fib f b = Σ A (λ a → f a == b)\n\n\n  -- A function applied over the fiber returns the original point\n  fib-eq : {f : A → B} → {b : B} → (h : fib f b) → f (π₁ h) == b\n  fib-eq (a , α) = α\n\n  -- Each point is on the fiber of its image\n  fib-image : {f : A → B} → {a : A} → fib f (f a)\n  fib-image {f} {a} = a , refl (f a)\n\nopen Fibers public\n\\end{code}\n\n## Contractible types\n\n\\begin{code}\n-- Contractible.  Contractible types with a center of contraction.\nmodule Contractible where\n\n  -- Contractible types. A contractible type is a type such that every\n  -- element is equal to a center of contraction.\n  isContr : ∀ {ℓ}  (A : Type ℓ) → Type ℓ\n  isContr A = Σ A (λ a → ((x : A) → a == x))\nopen Contractible public\n\n\\end{code}\n\n## Equivalence\n\n\\begin{code}\nmodule Equivalence where\n\n  module DefinitionOfEquivalence {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n    -- Contractible maps. A map is contractible if the fiber in any\n    -- point is contractible, that is, each element has a unique\n    -- preimage.\n    isContrMap : (f : A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n    isContrMap f = (b : B) → isContr (fib f b)\n\\end{code}\n\n\\begin{code}\n    -- There exists an equivalence between two types if there exists a\n    -- contractible function between them.\n    isEquiv : (f : A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n    isEquiv = isContrMap\n  open DefinitionOfEquivalence public\n\\end{code}\n\n\\begin{code}\n  -- Equivalence of types.\n  _≃_ : ∀ {ℓᵢ ℓⱼ}  (A : Type ℓᵢ) (B : Type ℓⱼ) → Type (ℓᵢ ⊔ ℓⱼ)\n  A ≃ B = Σ (A → B) isEquiv\n\\end{code}\n\n\\begin{code}\n  module EquivalenceMaps {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n    -- Maps of an equivalence\n    lemap : A ≃ B → (A → B)\n    lemap = π₁\n\n    ≃-to-→ = lemap\n    fun≃   = lemap\n\n    remap : A ≃ B → (B → A)\n    remap (f , contrf) b = π₁ (π₁ (contrf b))\n\n    -- The maps of an equivalence are inverses in particular\n    lrmap-inverse : (eq : A ≃ B) → {b : B} → (lemap eq) ((remap eq) b) == b\n    lrmap-inverse (f , eqf) {b} = fib-eq (π₁ (eqf b))\n\n    rlmap-inverse : (eq : A ≃ B) → {a : A} → (remap eq) ((lemap eq) a) == a\n    rlmap-inverse (f , eqf) {a} = ap π₁ ((π₂ (eqf (f a))) fib-image)\n\n    lrmap-inverse-h : (eq : A ≃ B) → ((lemap eq) ∘ (remap eq)) ∼ id\n    lrmap-inverse-h eq = λ x → lrmap-inverse eq {x}\n\n    rlmap-inverse-h : (eq : A ≃ B) → ((remap eq) ∘ (lemap eq)) ∼ id\n    rlmap-inverse-h eq = λ x → rlmap-inverse eq {x}\n  open EquivalenceMaps public\n\\end{code}\n\n\\begin{code}\nopen Equivalence public\n\\end{code}\n\n## Function extensionality\n\n\\begin{code}\n\nmodule FunExt {ℓᵢ ℓⱼ} {A : Type ℓᵢ}\n  {B : A → Type ℓⱼ} {f g : (a : A) → B a} where\n\\end{code}\n\n\\begin{code}\n  -- Application of an homotopy\n  happly : f == g → ((x : A) → f x == g x)\n  happly idp x = refl (f x)\n\\end{code}\n\n\\begin{code}\n  -- The axiom of function extensionality postulates that the\n  -- application of homotopies is an equivalence.\n  postulate axiomFunExt : isEquiv happly\n\\end{code}\n\n\\begin{code}\n  eqFunExt : (f == g) ≃ ((x : A) → f x == g x)\n  eqFunExt = happly , axiomFunExt\n\\end{code}\n\n\\begin{code}\n  -- From this, the usual notion of function extensionality follows.\n  funext : ((x : A) → f x == g x) → f == g\n  funext = remap eqFunExt\n\\end{code}\n\n\\begin{code}\n  -- Beta and eta rules for function extensionality\n  funext-β : (h : ((x : A) → f x == g x)) → happly (funext h) == h\n  funext-β h = lrmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-η : (p : f == g) → funext (happly p) == p\n  funext-η p = rlmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\nopen FunExt public\n\\end{code}\n\n- Function extensionality in the transport case\n\n\\begin{code}\nmodule FunExt-Transport\n  {ℓᵢ ℓⱼ} {X : Type ℓᵢ} {A B : X → Type ℓⱼ} {x y : X} where\n\\end{code}\n\n\\begin{code}\n  funext-transport\n    : (p : x == y) → (f : A x → B x) → (g : A y → B y)\n    ------------------------------------------------------------\n    → ((p ✶) f == g) ≃ ((a : A(x)) → (p ✶) (f a) == g ((p ✶) a))\n\n  funext-transport idp f g = eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-transport-l\n    : (p : x == y)\n    → (f : A x → B x)\n    → (g : A y → B y)\n    → ((p ✶) f == g)\n    -------------------------------------------\n    → ((a : A(x)) → (p ✶) (f a) == g ((p ✶) a))\n\n  funext-transport-l p f g = lemap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\n  funext-transport-r\n    : (p : x == y)\n    → (f : A x → B x)\n    → (g : A y → B y)\n    → ((a : A(x)) → (p ✶) (f a) == g ((p ✶) a))\n    -------------------------------------------\n    → ((p ✶) f == g)\n\n  funext-transport-r p f g = remap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\nopen FunExt-Transport public\n\\end{code}\n\n\\begin{code}\nmodule FunExt-Transport-DFun\n  {ℓᵢ ℓⱼ} {X : Type ℓᵢ} {A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ}{x y : X}\n  where\n\n  -- Lemma 2.9.7\n  funext-transport-dfun\n    : (p : x == y)\n    → (f : (a : A x) → B x a)\n    → (g : (a : A y) → B y a)\n    ----------------------------------------------------------------------------\n    → ((p ✶) f == g)\n      ≃ ((a : A x) → tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ✶) a))\n\n  funext-transport-dfun idp f g = eqFunExt\n\n  funext-transport-dfun-l\n    : (p : x == y) → (f : (a : A x) → B x a) → (g : (a : A y) → B y a)\n    → ((p ✶) f == g)\n    ---------------------------------------------------------------------------\n    → ((a : A x) → tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ✶) a))\n\n  funext-transport-dfun-l p f g = lemap (funext-transport-dfun p _ _)\n\n  funext-transport-dfun-r\n    : (p : x == y)\n    → (f : (a : A x) → B x a)\n    → (g : (a : A y) → B y a)\n    → ((a : A x) → tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ✶) a))\n    --------------------------------------------------------------------------\n    → ((p ✶) f == g)\n\n  funext-transport-dfun-r p f g = remap (funext-transport-dfun p _ _)\nopen FunExt-Transport-DFun public\n\\end{code}\n\n## Decidable equality\n\nA type has decidable equality if any two of its\nelements are equal or different. This would be a particular\ninstance of the Law of Excluded Middle that holds even if we do not\nassume Excluded Middle.\n\n\\begin{code}\nmodule DecidableEquality {ℓ} where\n\n  -- A type has decidable equality if we can prove that any two of its\n  -- elements are equal or different.\n  decEq : (A : Type ℓ) → Type ℓ\n  decEq A = (a b : A) → (a == b) + ¬ (a == b)\n\n  -- The product of types with decidable equality is a type with\n  -- decidable equality.\n  decEqProd : {A B : Type ℓ} → decEq A → decEq B → decEq (A × B)\n  decEqProd da db (a1 , b1) (a2 , b2) with (da a1 a2) | (db b1 b2)\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inl beq = inl (prodByComponents (aeq , beq))\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inr bnq = inr λ b → bnq (ap π₂ b)\n  decEqProd da db (a1 , b1) (a2 , b2) | inr anq | u       = inr λ b → anq (ap π₁ b)\n\nopen DecidableEquality\n\\end{code}\n\n## Hlevels\n\n### Propositions\n\nPropositions as described on the main text. A type\nis a proposition if we can create a function making any two of its\nelements equal. We create a type of propositions.\n\n\\begin{code}\n\nmodule Propositions where\n\n  -- A type is a mere proposition if any two inhabitants of the type\n  -- are equal\n  isProp : ∀ {ℓ}  (A : Type ℓ) → Type ℓ\n  isProp A = ((x y : A) → x == y)\n\n  -- The type of mere propositions\n  hProp : ∀ {ℓ} → Type (lsuc ℓ)\n  hProp {ℓ} = Σ (Type ℓ) isProp\n\n\n  -- The dependent function type to proposition types is itself a\n  -- proposition.\n  piProp : ∀ {ℓᵢ ℓⱼ} → {A : Type ℓᵢ} → {B : A → Type ℓⱼ}\n         → ((a : A) → isProp (B a)) → isProp ((a : A) → B a)\n  piProp props f g = funext λ a → props a (f a) (g a)\n\n  -- The product of propositions is itself a proposition.\n  isProp-prod : ∀ {ℓᵢ ℓⱼ} → {A : Type ℓᵢ} → {B : Type ℓⱼ}\n              → isProp A → isProp B → isProp (A × B)\n  isProp-prod p q x y = prodByComponents ((p _ _) , (q _ _))\n\nopen Propositions public\n\\end{code}\n\n### Sets\n\nSets are types without any higher dimensional structure, all\nparallel paths are homotopic and the homotopy is given by a\ncontinuous function on the two paths.\n\n\\begin{code}\nmodule Sets where\n\n  -- A type is a \"set\" by definition if any two equalities on the type\n  -- are equal.\n  isSet : ∀ {ℓ}  (A : Type ℓ) → Type ℓ\n  isSet A = (x y : A) → isProp (x == y)\n\n  -- The type of sets.\n  hSet : ∀ {ℓ} → Type (lsuc ℓ)\n  hSet {ℓ} = Σ (Type ℓ) isSet\n\n  -- Product of sets is a set.\n  isSet-prod : ∀ {ℓᵢ ℓⱼ}  {A : Type ℓᵢ} → {B : Type ℓⱼ}\n             → isSet A → isSet B → isSet (A × B)\n  isSet-prod sa sb (a , b) (c , d) p q = begin\n     p\n      ==⟨ inv (prodByCompInverse p) ⟩\n     prodByComponents (prodComponentwise p)\n      ==⟨ ap prodByComponents (prodByComponents (sa a c _ _ , sb b d _ _)) ⟩\n     prodByComponents (prodComponentwise q)\n      ==⟨ prodByCompInverse q ⟩\n     q\n    ∎\n\nopen Sets public\n\\end{code}\n\n### Lemmas\n\nHigher levels of the homotopical structure, where the\nfirst levels are:\n\n- Contractible types (0)\n- Propositions (1)\n- Sets (2)\n\nThey would correspond to homotopy levels. We only work with\nthese first levels.\n\n\\begin{code}\n\nmodule HLevels where\n\n  -- Propositions are Sets.\n  propIsSet : ∀ {ℓ} {A : Type ℓ} → isProp A → isSet A\n  propIsSet {A = A} f a _ p q = lemma p · inv (lemma q)\n    where\n      triang : {y z : A} {p : y == z} → (f a y) · p == f a z\n      triang {y}{p = idp} = inv (·-runit (f a y))\n\n      lemma : {y z : A} (p : y == z) → p == ! (f a y) · (f a z)\n      lemma {y} {z} p =\n        begin\n          p                       ==⟨ ap (_· p) (inv (·-linv (f a y))) ⟩\n          ! (f a y) · f a y · p   ==⟨ ·-assoc (! (f a y)) (f a y) p ⟩\n          ! (f a y) · (f a y · p) ==⟨ ap (! (f a y) ·_) triang ⟩\n          ! (f a y) · (f a z)\n        ∎\n\n  -- Contractible types are Propositions.\n  contrIsProp : ∀ {ℓ}  {A : Type ℓ} → isContr A → isProp A\n  contrIsProp (a , p) x y = ! (p x) · p y\n\n  -- To be contractible is itself a proposition.\n  isContrIsProp : ∀ {ℓ}  {A : Type ℓ} → isProp (isContr A)\n  isContrIsProp {_} {A} (a , p) (b , q) = Σ-bycomponents (inv (q a) , piProp (AisSet b) _ q)\n    where\n      AisSet : isSet A\n      AisSet = propIsSet (contrIsProp (a , p))\n\nopen HLevels public\n\\end{code}\n\n\nEquivalence of two types is a proposition\nMoreover, equivalences preserve propositions.\n\n\\begin{code}\n\nmodule EquivalenceProp {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n  -- Contractible maps are propositions\n  isContrMapIsProp : (f : A → B) → isProp (isContrMap f)\n  isContrMapIsProp f = piProp λ a → isContrIsProp\n\n  isEquivIsProp : (f : A → B) → isProp (isEquiv f)\n  isEquivIsProp = isContrMapIsProp\n\n  -- Equality of same-morphism equivalences\n  sameEqv : {α β : A ≃ B} → π₁ α == π₁ β → α == β\n  sameEqv {(f , σ)} {(g , τ)} p = Σ-bycomponents (p , (isEquivIsProp g _ τ))\n\n  -- Equivalences preserve propositions\n  isProp-≃ : (A ≃ B) → isProp A → isProp B\n  isProp-≃ eq prop x y =\n    begin\n      x                       ==⟨ inv (lrmap-inverse eq) ⟩\n      lemap eq ((remap eq) x) ==⟨ ap (λ u → lemap eq u) (prop _ _) ⟩\n      lemap eq ((remap eq) y) ==⟨ lrmap-inverse eq ⟩\n      y\n    ∎\n\nopen EquivalenceProp public\n\\end{code}\n\n\n### Half-adjoints\n\nHalf-adjoints are an auxiliary notion that helps us\nto define a suitable notion of equivalence, meaning that it is a\nproposition and that it captures the usual notion of equivalence.\n\n\\begin{code}\nmodule Halfadjoints {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n  -- Half adjoint equivalence.\n  record ishae (f : A → B) : Type (ℓᵢ ⊔ ℓⱼ) where\n    constructor hae\n    field\n      g : B → A\n      η : (g ∘ f) ∼ id\n      ε : (f ∘ g) ∼ id\n      τ : (a : A) → ap f (η a) == ε (f a)\n\n  -- Half adjoint equivalences give contractible fibers.\n  ishae-contr : (f : A → B) → ishae f → isContrMap f\n  ishae-contr f (hae g η ε τ) y = ((g y) , (ε y)) , contra\n    where\n      lemma : (c c' : fib f y) → Σ (π₁ c == π₁ c') (λ γ → (ap f γ) · π₂ c' == π₂ c) → c == c'\n      lemma c c' (p , q) = Σ-bycomponents (p , lemma2)\n        where\n          lemma2 : transport (λ z → f z == y) p (π₂ c) == π₂ c'\n          lemma2 =\n            begin\n              transport (λ z → f z == y) p (π₂ c)\n                ==⟨ transport-eq-fun-l f p (π₂ c) ⟩\n              inv (ap f p) · (π₂ c)\n                ==⟨ ap (inv (ap f p) ·_) (inv q) ⟩\n              inv (ap f p) · ((ap f p) · (π₂ c'))\n                ==⟨ inv (·-assoc (inv (ap f p)) (ap f p) (π₂ c')) ⟩\n              inv (ap f p) · (ap f p) · (π₂ c')\n                ==⟨ ap (_· (π₂ c')) (·-linv (ap f p)) ⟩\n              π₂ c'\n            ∎\n\n      contra : (x : fib f y) → (g y , ε y) == x\n      contra (x , p) = lemma (g y , ε y) (x , p) (γ , lemma3)\n        where\n          γ : g y == x\n          γ = inv (ap g p) · η x\n\n          lemma3 : (ap f γ · p) == ε y\n          lemma3 =\n            begin\n              ap f γ · p\n                ==⟨ ap (_· p) (ap-· f (inv (ap g p)) (η x)) ⟩\n              ap f (inv (ap g p)) · ap f (η x) · p\n                ==⟨ ·-assoc (ap f (inv (ap g p))) _ p ⟩\n              ap f (inv (ap g p)) · (ap f (η x) · p)\n                ==⟨ ap (_· (ap f (η x) · p)) (ap-inv f (ap g p)) ⟩\n              inv (ap f (ap g p)) · (ap f (η x) · p)\n                ==⟨ ap (λ u → inv (ap f (ap g p)) · (u · p)) (τ x) ⟩\n              inv (ap f (ap g p)) · (ε (f x) · p)\n                ==⟨ ap (λ u → inv (ap f (ap g p)) · (ε (f x) · u)) (inv (ap-id p)) ⟩\n              inv (ap f (ap g p)) · (ε (f x) · ap id p)\n                ==⟨ ap (inv (ap f (ap g p)) ·_) (h-naturality ε p) ⟩\n              inv (ap f (ap g p)) · (ap (f ∘ g) p · ε y)\n                ==⟨ ap (λ u → inv u · (ap (f ∘ g) p · ε y)) (ap-comp g f p) ⟩\n              inv (ap (f ∘ g) p) · (ap (f ∘ g) p · ε y)\n                ==⟨ inv (·-assoc (inv (ap (f ∘ g) p)) _ (ε y)) ⟩\n              (inv (ap (f ∘ g) p) · ap (f ∘ g) p) · ε y\n                ==⟨ ap (_· ε y) (·-linv (ap (λ z → f (g z)) p)) ⟩\n              ε y\n            ∎\n\n  -- Half-adjointness implies equivalence.\n  ishae-≃ : {f : A → B} → ishae f → A ≃ B\n  ishae-≃ ishaef = _ , (ishae-contr _ ishaef)\n\nopen Halfadjoints public\n\\end{code}\n\n### Quasiinverses\n\nTwo functions are quasi-inverses if we can construct a function providing\n`(g ∘ f) x = x` and `(f ∘ g) y = y` for any given `x` and `y`.\n\n\\begin{code}\nmodule Quasiinverses {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : Type ℓⱼ} where\n\n  -- Definitions for quasi-inverses, left-inverses, right-inverses and\n  -- biinverses.\n  qinv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  qinv f = Σ (B → A) (λ g → ((f ∘ g) ∼ id) × ((g ∘ f) ∼ id))\n\n  linv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  linv f = Σ (B → A) (λ g → (g ∘ f) ∼ id)\n\n  rinv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  rinv f = Σ (B → A) λ g → (f ∘ g) ∼ id\n\n  biinv : (A → B) → Type (ℓᵢ ⊔ ℓⱼ)\n  biinv f = linv f × rinv f\n\n  qinv-biinv : (f : A → B) → qinv f → biinv f\n  qinv-biinv f (g , (u1 , u2)) = (g , u2) , (g , u1)\n\n  biinv-qinv : (f : A → B) → biinv f → qinv f\n  biinv-qinv f ((h , α) , (g , β)) = g , (β , δ)\n    where\n      γ1 : g ∼ ((h ∘ f) ∘ g)\n      γ1 = rcomp-∼ g (h-sym (h ∘ f) id α)\n\n      γ2 : ((h ∘ f) ∘ g) ∼ (h ∘ (f ∘ g))\n      γ2 x = idp\n\n      γ : g ∼ h\n      γ = γ1 ● (γ2 ● (lcomp-∼ h β))\n\n      δ : (g ∘ f) ∼ id\n      δ = (rcomp-∼ f γ) ● α\n\n  equiv-biinv : (f : A → B) → isContrMap f → biinv f\n  equiv-biinv f contrf =\n    (remap eq , rlmap-inverse-h eq) , (remap eq , lrmap-inverse-h eq)\n    where\n      eq : A ≃ B\n      eq = f , contrf\n\n  -- Quasiinverses are halfadjoint equivalences.\n  qinv-ishae : {f : A → B} → qinv f → ishae f\n  qinv-ishae {f} (g , (ε , η)) = record {\n      g = g ;\n      η = η ;\n      ε = λ b → inv (ε (f (g b))) · ap f (η (g b)) · ε b ;\n      τ = τ\n    }\n    where\n      aux-lemma : (a : A) → ap f (η (g (f a))) · ε (f a) == ε (f (g (f a))) · ap f (η a)\n      aux-lemma a =\n        begin\n          ap f (η ((g ∘ f) a)) · ε (f a)\n            ==⟨ ap (λ u → ap f u · ε (f a)) (h-naturality-id η) ⟩\n          ap f (ap (g ∘ f) (η a)) · ε (f a)\n            ==⟨ ap (_· ε (f a)) (ap-comp (g ∘ f) f (η a)) ⟩\n          ap (f ∘ (g ∘ f)) (η a) · ε (f a)\n            ==⟨ inv (h-naturality (λ x → ε (f x)) (η a)) ⟩\n          ε (f (g (f a))) · ap f (η a)\n        ∎\n\n      τ : (a : A) → ap f (η a) == (inv (ε (f (g (f a)))) · ap f (η (g (f a))) · ε (f a))\n      τ a =\n        begin\n          ap f (η a)\n            ==⟨ ap (_· ap f (η a)) (inv (·-linv (ε (f (g (f a)))))) ⟩\n          inv (ε (f (g (f a)))) · ε (f (g (f a))) · ap f (η a)\n            ==⟨ ·-assoc (inv (ε (f (g (f a))))) _ (ap f (η a)) ⟩\n          inv (ε (f (g (f a)))) · (ε (f (g (f a))) · ap f (η a))\n            ==⟨ ap (inv (ε (f (g (f a)))) ·_) (inv (aux-lemma a)) ⟩\n          inv (ε (f (g (f a)))) · (ap f (η (g (f a))) · ε (f a))\n            ==⟨ inv (·-assoc (inv (ε (f (g (f a))))) _ (ε (f a))) ⟩\n          inv (ε (f (g (f a)))) · ap f (η (g (f a))) · ε (f a)\n        ∎\n\n  -- Quasiinverses create equivalences.\n  qinv-≃ : (f : A → B) → qinv f → A ≃ B\n  qinv-≃ f = ishae-≃ ∘ qinv-ishae\n\n  ≃-qinv : A ≃ B → Σ (A → B) qinv\n  ≃-qinv eq =\n    lemap eq , (remap eq , (lrmap-inverse-h eq , rlmap-inverse-h eq))\n\n  -- Half-adjoint equivalences are quasiinverses.\n  ishae-qinv : {f : A → B} → ishae f → qinv f\n  ishae-qinv {f} (hae g η ε τ) = g , (ε , η)\n\n  ≃-ishae : (e : A ≃ B)→ ishae (lemap e)\n  ≃-ishae e = qinv-ishae (π₂ (≃-qinv e))\n\nopen Quasiinverses public\n\\end{code}\n\n## Equivalence composition\n\nComposition of equivalences and properties of that composition.\n\n\\begin{code}\nmodule EquivalenceComposition where\n\n  -- Composition of quasiinverses\n  qinv-comp : ∀ {ℓ} {A B C : Type ℓ} → Σ (A → B) qinv → Σ (B → C) qinv → Σ (A → C) qinv\n  qinv-comp (f , (if , (εf , ηf))) (g , (ig , (εg , ηg))) = (g ∘ f) , ((if ∘ ig) ,\n     ( (λ x → ap g (εf (ig x)) · εg x)\n     ,  λ x → ap if (ηg (f x)) · ηf x))\n\n  qinv-inv : ∀ {ℓ} {A B : Type ℓ} → Σ (A → B) qinv → Σ (B → A) qinv\n  qinv-inv (f , (g , (ε , η))) = g , (f , (η , ε))\n\n  -- Composition of equivalences\n  idEqv : ∀ {ℓ} {A : Type ℓ} → A ≃ A\n  idEqv = id , λ a → (a , refl a) , λ { (_ , idp) → refl (a , refl a) }\n\\end{code}\n\n\\begin{code}\n--\n  compEqv\n    : ∀ {ℓ} {A B C : Type ℓ}\n    → A ≃ B\n    → B ≃ C\n    -------\n    → A ≃ C\n\n  compEqv {A = A} {C = C} eq-f eq-g = qinv-≃ (π₁ qcomp) (π₂ qcomp)\n   where\n     qcomp : Σ (A → C) qinv\n     qcomp = qinv-comp (≃-qinv eq-f) (≃-qinv eq-g)\n\n  -- synonym:\n  ≃-trans = compEqv\n\\end{code}\n\n\\begin{code}\n  invEqv : ∀ {ℓ} {A B : Type ℓ} → A ≃ B → B ≃ A\n  invEqv {ℓ} {A} {B} eq-f = qinv-≃ (π₁ qcinv) (π₂ qcinv)\n   where\n     qcinv : Σ (B → A) qinv\n     qcinv = qinv-inv (≃-qinv eq-f)\n\n  -- Lemmas about composition\n  compEqv-inv : ∀ {ℓ} {A B : Type ℓ} → (α : A ≃ B) → compEqv α (invEqv α) == idEqv\n  compEqv-inv {_} {A} {B} α = sameEqv (\n   begin\n     π₁ (compEqv α (invEqv α)) ==⟨ refl _ ⟩\n     π₁ (invEqv α) ∘ π₁ α     ==⟨ funext (rlmap-inverse-h α) ⟩\n     id\n   ∎)\n\nopen EquivalenceComposition public\n\\end{code}\n\n\n## Equivalence reasoning\n\n\\begin{code}\nmodule EquivalenceReasoning where\n\n  infixr 2 _≃⟨⟩_\n  _≃⟨⟩_ : ∀ {ℓ} (A {B} : Type ℓ) → A ≃ B → A ≃ B\n  _ ≃⟨⟩ e = e\n\n  infixr 2 _≃⟨_⟩_\n  _≃⟨_⟩_ : ∀ {ℓ} (A : Type ℓ) {B C : Type ℓ} → A ≃ B → B ≃ C → A ≃ C\n  _ ≃⟨ e₁ ⟩ e₂ = compEqv e₁ e₂\n  --\n  infix  3 _≃∎\n  _≃∎ :  ∀ {ℓ} (A : Type ℓ) → A ≃ A\n  _≃∎ = λ A → idEqv {A = A}\n\n  infix  1 begin≃_\n  begin≃_ : ∀ {ℓ} {A B : Type ℓ} → A ≃ B → A ≃ B\n  begin≃_ e = e\n\nopen EquivalenceReasoning public\n\\end{code}\n\n## Equivalence with Sigma type\n\n\\begin{code}\nmodule SigmaEquivalence {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : A → Type ℓⱼ} where\n\n  pair=Equiv : {v w : Σ A P}\n    → Σ (π₁ v == π₁ w) (λ p → tr (λ a → P a) p (π₂ v) == π₂ w) ≃ v == w\n  pair=Equiv = qinv-≃ Σ-bycomponents (Σ-componentwise , HΣ₁ , HΣ₂)\n    where\n      HΣ₁ : Σ-bycomponents ∘ Σ-componentwise ∼ id\n      HΣ₁ idp = idp\n\n      HΣ₂ : Σ-componentwise ∘ Σ-bycomponents ∼ id\n      HΣ₂ (idp , idp) = idp\n\n  private\n    f : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → ap π₁ (pair= (β , γ)) == α → β == α\n    f {β = idp} {γ = idp} idp = idp\n\n    g : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → β == α → ap π₁ (pair= (β , γ)) == α\n    g {β = idp} {γ = idp} idp = idp\n\n    f-g : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → f {α = α}{β = β}{γ} ∘ g {α = α}{β = β} ∼ id\n    f-g {β = idp} {γ = idp} idp = idp\n\n    g-f : {a₁ a₂ : A} {α : a₁ == a₂}{c₁ : P a₁} {c₂ : P a₂}\n      → {β : a₁ == a₂}\n      → {γ : transport P β c₁ == c₂}\n      → g {α = α}{β = β}{γ} ∘ f {α = α}{β = β}{γ} ∼ id\n    g-f {β = idp} {γ = idp} idp = idp\n\n  ap-π₁-pair=Equiv : {a₁ a₂ : A} {c₁ : P a₁} {c₂ : P a₂}\n    → (α : a₁ == a₂)\n    → (γ : Σ (a₁ == a₂) (λ α' → transport P α' c₁ == c₂))\n    → (ap π₁ (pair= γ) == α) ≃ π₁ γ == α\n  ap-π₁-pair=Equiv {a₁ = a₁} α (β , γ) = qinv-≃ f (g , f-g , g-f)\n\nopen SigmaEquivalence public\n\\end{code}\n\n## Univalence\n\nVoevodsky's univalence axiom is postulated. It induces\nan equality between any two equivalent types. Some β and η rules\nare provided.\n\n\\begin{code}\nmodule Univalence where\n\n  -- Voevodsky's Univalence Axiom.\n  module UnivalenceAxiom {ℓ} {A B : Type ℓ} where\n\n    idtoeqv : A == B → A ≃ B\n    idtoeqv p = qinv-≃\n      (transport (λ X → X) p)\n      (transport (λ X → X) (inv p) , (coe-inv-l p , coe-inv-r p))\n\n    -- The Univalence axiom induces an equivalence between equalities\n    -- and equivalences.\n    postulate axiomUnivalence : isEquiv idtoeqv\n    eqvUnivalence : (A == B) ≃ (A ≃ B)\n    eqvUnivalence = idtoeqv , axiomUnivalence\n\n    -- Introduction rule for equalities.\n    ua : A ≃ B → A == B\n    ua = remap eqvUnivalence\n\n    -- Computation rules\n    ua-β : (eqv : A ≃ B) → idtoeqv (ua eqv) == eqv\n    ua-β eqv = lrmap-inverse eqvUnivalence\n\n    ua-η : (p : A == B) → ua (idtoeqv p) == p\n    ua-η p = rlmap-inverse eqvUnivalence\n  open UnivalenceAxiom public\nopen Univalence public\n\\end{code}\n\n### Univalence lemmas\n\n\\begin{code}\nmodule UnivalenceLemmas {ℓ} where\n\\end{code}\n\n- The identity equivalence creates the trivial path.\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-id : {A : Type ℓ} → ua idEqv == refl A\n    -- ua-id {A} =\n    --   begin\n    --     ua idEqv              ==⟨ ap ua (sameEqv (refl id)) ⟩\n    --     ua (idtoeqv (refl A)) ==⟨ ua-η (refl A) ⟩\n    --     refl A\n    --   ∎\n\n    -- The composition of equivalences is preserved into composition\n    -- of equalities.\n\\end{code}\n-\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-comp : {A B C : Type ℓ} → (α : A ≃ B) → (β : B ≃ C) → ua (compEqv α β) == ua α · ua β\n    -- ua-comp α β =\n    --   begin\n    --     ua (compEqv α β)                               ==⟨ ap (λ x → ua (compEqv x β)) (inv (ua-β α)) ⟩\n    --     ua (compEqv (idtoeqv (ua α)) β)                ==⟨ ap (λ x → ua (compEqv (idtoeqv (ua α)) x))\n    --                                                        (inv (ua-β β)) ⟩\n    --     ua (compEqv (idtoeqv (ua α)) (idtoeqv (ua β))) ==⟨ ap ua lemma ⟩\n    --     ua (idtoeqv (ua α · ua β))                     ==⟨ ua-η (ua α · ua β) ⟩\n    --     ua α · ua β\n    --   ∎\n    --   where\n    --     lemma : compEqv (idtoeqv (ua α)) (idtoeqv (ua β)) == idtoeqv (ua α · ua β)\n    --     lemma = sameEqv (\n    --       begin\n    --         π₁ (idtoeqv (ua β)) ∘ π₁ (idtoeqv (ua α))                 ==⟨ refl _ ⟩\n    --         (transport (λ x → x) (ua β)) ∘ (transport (λ x → x) (ua α)) ==⟨ transport-comp (ua α) (ua β) ⟩\n    --         transport (λ x → x) (ua α · ua β)                           ==⟨ refl _ ⟩\n    --         π₁ (idtoeqv (ua α · ua β))\n    --       ∎)\n\\end{code}\n\n- Inverses are preserved\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv-r : {A B : Type ℓ} → (α : A ≃ B) → ua α · ua (invEqv α) == refl A\n    -- ua-inv-r α =\n    --   begin\n    --     ua α · ua (invEqv α)      ==⟨ inv (ua-comp α (invEqv α)) ⟩\n    --     ua (compEqv α (invEqv α)) ==⟨ ap ua (compEqv-inv α) ⟩\n    --     ua idEqv                  ==⟨ ua-id ⟩\n    --     refl _\n    --   ∎\n\\end{code}\n\n- Missing description\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv : {A B : Type ℓ} → (α : A ≃ B) → ua (invEqv α) == inv (ua α)\n    -- ua-inv α =\n    --   begin\n    --     ua (invEqv α)                       ==⟨ ap (_· ua (invEqv α)) (inv (·-linv (ua α))) ⟩\n    --     inv (ua α) · ua α · ua (invEqv α)   ==⟨ ·-assoc (inv (ua α)) _ _ ⟩\n    --     inv (ua α) · (ua α · ua (invEqv α)) ==⟨ ap (inv (ua α) ·_) (ua-inv-r α) ⟩\n    --     inv (ua α) · refl _                 ==⟨ inv (·-runit (inv ((ua α)))) ⟩\n    --     inv (ua α)\n    --   ∎\nopen UnivalenceLemmas public\n\\end{code}\n\n### Transport and Univalence\n\n\\begin{code}\nmodule TransportUA where\n\n  transport-family-ap\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (u : B x)\n    ---------------------------------------------------\n    → transport B p u == transport (λ X → X) (ap B p) u\n  transport-family-ap B idp u = idp\n\n  transport-family-idtoeqv\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (u : B x)\n    ---------------------------------------------------\n    → transport B p u == fun≃ (idtoeqv (ap B p)) u\n  transport-family-idtoeqv B idp u = idp\n\n  transport-ua\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (e : B x ≃ B y)\n    → ap B p == ua e\n    -----------------\n    → (u : B x) → transport B p u == (fun≃ e) u\n  transport-ua B idp e q u =\n    begin\n      transport B idp u\n        ==⟨ transport-family-idtoeqv B idp u ⟩\n      fun≃ (idtoeqv (ap B idp)) u\n        ==⟨ ap (λ r → fun≃ (idtoeqv r) u) q ⟩\n      fun≃ (idtoeqv (ua e)) u\n        ==⟨ ap (λ r → fun≃ r u) (ua-β e) ⟩\n      fun≃ e u\n    ∎\n\n\n  funext-transport-ua\n    : ∀ {ℓ} {A : Type ℓ}\n    → (B : A → Type ℓ)\n    → {x y : A}\n    → (p : x == y)\n    → (e : B x ≃ B y)\n    → ap B p == ua e\n    -----------------\n    → transport B p == (fun≃ e)\n  funext-transport-ua B p e x₁ = funext (transport-ua B p e x₁)\nopen TransportUA public\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem\n  : ∀ {ℓᵢ ℓⱼ}{X : Type ℓᵢ}{A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (g : (a : A y) → B y a)\n  → (a : A y)\n  ------------------------------------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f) a == g a\n  ≃  tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , transport-inv p)) (f (((! p) ✶) a)) == g a\n\nfunext-transport-dfun-bezem idp f g a = idEqv\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-l\n  : ∀ {ℓᵢ ℓⱼ}{X : Type ℓᵢ}{A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (g : (a : A y) → B y a)\n  → (a : A y)\n  → (tr (λ x → (a : A x) → B x a) p f) a == g a\n  ------------------------------------------------------------------------------------\n  →  tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , transport-inv p)) (f (((! p) ✶) a)) == g a\n\nfunext-transport-dfun-bezem-l p f g a x₁ = lemap (funext-transport-dfun-bezem p f g a) x₁\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-r\n  : ∀ {ℓᵢ ℓⱼ}{X : Type ℓᵢ}{A : X → Type ℓⱼ}{B : (x : X) → A x → Type ℓⱼ} {x y : X}\n  → (p : x == y)\n  → (f : (a : A x) → B x a)\n  → (g : (a : A y) → B y a)\n  → (a : A y)\n  →  tr (λ w → B (π₁ w) (π₂ w)) (pair= (p , transport-inv p)) (f (((! p) ✶) a)) == g a\n  ------------------------------------------------------------------------------------\n  → (tr (λ x → (a : A x) → B x a) p f) a == g a\n\nfunext-transport-dfun-bezem-r p f g a x₁ = remap (funext-transport-dfun-bezem p f g a) x₁\n\\end{code}\n\n## Truncation\n\n\\begin{code}\nmodule Truncation where\n\n  private\n    -- Higher inductive type, defined with equalities between any two\n    -- members.\n    data !∥_∥ {ℓ} (A : Type ℓ) : Type ℓ where\n      !∣_∣ : A → !∥ A ∥\n\n  ∥_∥ : ∀ {ℓ} (A : Type ℓ) → Type ℓ\n  ∥ A ∥ = !∥ A ∥\n\n  ∣_∣ : ∀ {ℓ} {X : Type ℓ} → X → ∥ X ∥\n  ∣ x ∣ = !∣ x ∣\n\n  -- Any two elements of the truncated type are equal\n  postulate trunc : ∀ {ℓ} {A : Type ℓ} → isProp ∥ A ∥\n\n  -- Recursion principle\n  trunc-rec : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : Type ℓⱼ}\n            → isProp P\n            → (A → P)\n            ---------\n            → ∥ A ∥ → P\n  trunc-rec _ f !∣ x ∣ = f x\n\\end{code}\n\n## Set truncation\n\nAn analogous form of truncation for Sets instead of\nPropositions. It truncates any higher-dimensional homothopical\nstructure.\n\n\\begin{code}\nmodule SetTruncation where\n\n  private\n    -- Higher inductive type\n    data !∥_∥₀ {ℓ} (A : Type ℓ) : Type ℓ where\n      !∣_∣₀ : A → !∥ A ∥₀\n\n  ∥_∥₀ : ∀ {ℓ} (A : Type ℓ) → Type ℓ\n  ∥ A ∥₀ = !∥ A ∥₀\n\n  ∣_∣₀ : ∀ {ℓ} {X : Type ℓ} → X → ∥ X ∥₀\n  ∣ x ∣₀ = !∣ x ∣₀\n\n  -- Any two equalities on the truncated type are equal\n  postulate strunc : ∀ {ℓ} {A : Type ℓ} → isSet ∥ A ∥₀\n\n  -- Recursion principle\n  strunc-rec : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {P : Type ℓⱼ} → isSet P → (A → P) → ∥ A ∥₀ → P\n  strunc-rec _ f !∣ x ∣₀ = f x\n\n  -- Induction principle\n  strunc-ind : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {B : ∥ A ∥₀ → Type ℓⱼ} → ((a : ∥ A ∥₀) → isSet (B a))\n             → (g : (a : A) → B ∣ a ∣₀) → (a : ∥ A ∥₀) → B a\n  strunc-ind _ g !∣ x ∣₀ = g x\n\\end{code}\n\n## Quotients\n\n\\begin{code}\nmodule Quotients where\n\n  record QRel {ℓ} (A : Type ℓ) : Type (lsuc ℓ) where\n    field\n      R : A → A → Type ℓ\n      Aset : isSet A\n      Rprop : (a b : A) → isProp (R a b)\n  open QRel  public\n\n  private\n    -- Higher inductive type\n    data _!/_ {ℓ} (A : Type ℓ) (r : QRel A) : Type (lsuc ℓ) where\n      ![_] : A → (A !/ r)\n\n  _/_ : ∀ {ℓ} (A : Type ℓ) (r : QRel A) → Type (lsuc ℓ)\n  A / r = (A !/ r)\n\n  [_] : ∀ {ℓ} {A : Type ℓ} → A → {r : QRel A} → (A / r)\n  [ a ] = ![ a ]\n\n  -- Equalities induced by the relation\n  postulate Req : ∀ {ℓ} {A : Type ℓ} {r : QRel A}\n                 → {a b : A} → R  a b → [ a ] {r} == [ b ]\n\n  -- The quotient of a set is again a set\n  postulate Rtrunc : ∀ {ℓ} {A : Type ℓ} {r : QRel A} → isSet (A / r)\n\n  -- Recursion principle\n  QRel-rec : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {r : QRel A} {B : Type ℓⱼ}\n            → (f : A → B) → ((x y : A) → R  x y → f x == f y) → A / r → B\n  QRel-rec f p ![ x ] = f x\n\n  -- Induction principle\n  QRel-ind : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {r : QRel A} {B : A / r → Type ℓⱼ}\n            → (f : ((a : A) → B [ a ]))\n            → ((x y : A) → (o : R  x y) → (transport B (Req o) (f x)) == f y)\n            → (z : A / r) → B z\n  QRel-ind f p ![ x ] = f x\n\n  -- Recursion in two arguments\n  QRel-rec-bi : ∀ {ℓᵢ ℓⱼ} {A : Type ℓᵢ} {r : QRel A} {B : Type ℓⱼ}\n              → (f : A → A → B) → ((x y z t : A) → R  x y → R  z t → f x z == f y t)\n              → A / r → A / r → B\n  QRel-rec-bi f p ![ x ] ![ y ] = f x y\n\n\n  Qrel-prod : ∀ {ℓᵢ}{A : Type ℓᵢ} (r : QRel A) → QRel (A × A)\n  Qrel-prod r = record { R = λ { (a , b) (c , d) → (R  a c) × (R  b d) }\n                       ; Aset = isSet-prod (Aset ) (Aset )\n                       ; Rprop = λ { (x , y) (z , w) → isProp-prod (Rprop  x z) (Rprop  y w)} }\n\\end{code}\n\n## Relation\n\n\\begin{code}\nmodule Relation where\n\n  record Rel {ℓ} (A : Type ℓ) : Type (lsuc ℓ) where\n    field\n      R     : A → A → Type ℓ\n      Rprop : (a b : A) → isProp (R a b)\n  open Rel  public\n\nopen Relation public\n\\end{code}\n\n\n## Hedberg\n\n\\begin{code}\nmodule Hedberg {ℓ} where\n\n  module HedbergLemmas (A : Type ℓ) where\n\n    -- A set is a type satisfiying axiom K.\n    axiomKisSet : ((a : A) → (p : a == a) → p == refl a) → isSet A\n    axiomKisSet k x _ p idp = k x p\n\n    -- Lemma: a reflexive relation on X implying the identity proves\n    -- that X is a set.\n    reflRelIsSet :  (r : Rel A) →\n      ((x y : A) → R  x y → x == y) →\n      (ρ : (a : A) → R  a a) →\n      isSet A\n    reflRelIsSet r f ρ x .x p idp = lemma p\n      where\n        lemma2 : {a : A} (p : a == a) → (o : R  a a) →\n          transport (λ x → a == x) p (f a a o) == f a a (transport (R  a) p o)\n        lemma2 {a} p = funext-transport-l p (f a a) (f a a) (apd (f a) p)\n\n        lemma3 : {a : A} (p : a == a) →\n          (f a a (ρ a)) · p == (f a a (ρ a))\n        lemma3 {a} p = inv (transport-concat-r p _) · lemma2 p (ρ a) ·\n                       ap (f a a) (Rprop  a a _ (ρ a))\n\n        lemma : {a : A} (p : a == a) → p == refl a\n        lemma {a} p = ·-cancellation ((f a a (ρ a))) p (lemma3 p)\n\n    -- Lemma: if a type is decidable, then ¬¬A is actually A.\n    lemDoubleNeg : (A + ¬ A) → (¬ (¬ A) → A)\n    lemDoubleNeg (inl x) _ = x\n    lemDoubleNeg (inr f) n = exfalso (n f)\n\n  open HedbergLemmas public\n\n  -- Hedberg's theorem. A type with decidable equality is a set.\n  hedberg : {A : Type ℓ} → ((a b : A) → (a == b) + ¬ (a == b)) → isSet A\n  hedberg {A} f = reflRelIsSet A\n                (record { R = λ a b → ¬ (¬ (a == b)) ; Rprop = isPropNeg })\n                doubleNegEq (λ a z → z (refl a))\n    where\n      doubleNegEq : (a b : A) → ¬ (¬ (a == b)) → (a == b)\n      doubleNegEq a b = lemDoubleNeg (a == b) (f a b)\n\n      isPropNeg : (a b : A) → isProp (¬ (¬ (a == b)))\n      isPropNeg a b x y = funext λ u → exfalso (x u)\n\nopen Hedberg public\n\\end{code}\n\n\n## Algebra\n\n### Monoid\n\nDefinition of the algebraic structure of a monoid.\n\n\\begin{code}\nmodule Monoids {ℓ} where\n\n  record Monoid : Type (lsuc ℓ) where\n    field\n      -- Operations of a monoid\n      G : Type ℓ\n      GisSet : isSet G\n      _<>_ : G → G → G  -- Multiplication function\n      e : G             -- Unit element\n\n      -- Axioms of a monoid\n      lunit : (x : G) → (e <> x) == x\n      runit : (x : G) → (x <> e) == x\n      assoc : (x y z : G) → (x <> (y <> z)) == ((x <> y) <> z)\nopen Monoids\n\\end{code}\n\n### Groups\n\n\\begin{code}\nmodule Groups where\n  record GroupStructure {ℓ} (M : Type ℓ) : Type ℓ where\n    constructor group-structure\n    field\n      -- A group is a monoid\n      _*_   : M → M → M\n      e     : M\n      lunit : ∀ x → (e * x) == x\n      runit : ∀ x → (x * e) == x\n      assoc : ∀ x y z → (x * (y * z)) == ((x * y) * z)\n\n      -- With inverses\n      ginv : M → M\n      glinv : ∀ g → (g * ginv g) == e\n      grinv : ∀ g → (ginv g * g) == e\n\n  record Group {ℓ} : Type (lsuc ℓ) where\n    constructor group\n    field\n      M : Type ℓ\n      str : GroupStructure M\n  open Group  public\nopen Groups\n\\end{code}\n\n### Naturals\n\n\\begin{code}\nmodule Naturals where\n\n  -- Addition of natural numbers\n  plus : ℕ → ℕ → ℕ\n  plus zero y = y\n  plus (succ x) y = succ (plus x y)\n\n  infixl 60 _+ₙ_\n  _+ₙ_ : ℕ → ℕ → ℕ\n  _+ₙ_ = plus\n\n  -- Lemmas about addition\n  plus-lunit : (n : ℕ) → zero +ₙ n == n\n  plus-lunit n = refl n\n\n  plus-runit : (n : ℕ) → n +ₙ zero == n\n  plus-runit zero = refl zero\n  plus-runit (succ n) = ap succ (plus-runit n)\n\n  plus-succ : (n m : ℕ) → succ (n +ₙ m) == (n +ₙ (succ m))\n  plus-succ zero     m = refl (succ m)\n  plus-succ (succ n) m = ap succ (plus-succ n m)\n\n  plus-succ-rs : (n m o p : ℕ) → n +ₙ m == o +ₙ p → n +ₙ (succ m) == o +ₙ (succ p)\n  plus-succ-rs n m o p α = inv (plus-succ n m) · ap succ α · (plus-succ o p)\n\n  -- Commutativity\n  plus-comm : (n m : ℕ) → n +ₙ m == m +ₙ n\n  plus-comm zero     m = inv (plus-runit m)\n  plus-comm (succ n) m = ap succ (plus-comm n m) · plus-succ m n\n\n  -- Associativity\n  plus-assoc : (n m p : ℕ) → n +ₙ (m +ₙ p) == (n +ₙ m) +ₙ p\n  plus-assoc zero     m p = refl (m +ₙ p)\n  plus-assoc (succ n) m p = ap succ (plus-assoc n m p)\n\n\n  -- Decidable equality\n  -- Encode-decode technique for natural numbers\n  private\n    code : ℕ → ℕ → Type₀\n    code 0        0        = ⊤\n    code 0        (succ m) = ⊥\n    code (succ n) 0        = ⊥\n    code (succ n) (succ m) = code n m\n\n  crefl : (n : ℕ) → code n n\n  crefl zero     = ★\n  crefl (succ n) = crefl n\n\n  private\n    encode : (n m : ℕ) → (n == m) → code n m\n    encode n m p = transport (code n) p (crefl n)\n\n    decode : (n m : ℕ) → code n m → n == m\n    decode zero zero c = refl zero\n    decode zero (succ m) ()\n    decode (succ n) zero ()\n    decode (succ n) (succ m) c = ap succ (decode n m c)\n\n  zero-not-succ : (n : ℕ) → ¬ (succ n == zero)\n  zero-not-succ n = encode (succ n) 0\n\n  -- The successor function is injective\n  succ-inj : {n m : ℕ} → (succ n == succ m) → n == m\n  succ-inj {n} {m} p = decode n m (encode (succ n) (succ m) p)\n\n  +-inj : (k : ℕ) {n m : ℕ} → (k +ₙ n == k +ₙ m) → n == m\n  +-inj zero   p = p\n  +-inj (succ k) p = +-inj k (succ-inj p)\n\n  nat-decEq : decEq ℕ\n  nat-decEq zero zero = inl (refl zero)\n  nat-decEq zero (succ m) = inr (λ ())\n  nat-decEq (succ n) zero = inr (λ ())\n  nat-decEq (succ n) (succ m) with (nat-decEq n m)\n  nat-decEq (succ n) (succ m) | inl p = inl (ap succ p)\n  nat-decEq (succ n) (succ m) | inr f = inr λ p → f (succ-inj p)\n\n  nat-isSet : isSet ℕ\n  nat-isSet = hedberg nat-decEq\n\n  -- Naturals form a monoid with addition\n  ℕ-plus-monoid : Monoid\n  ℕ-plus-monoid = record\n    { G = ℕ\n    ; GisSet = nat-isSet\n    ; _<>_ = plus\n    ; e = zero\n    ; lunit = plus-lunit\n    ; runit = plus-runit\n    ; assoc = plus-assoc\n    }\n\n  -- Ordering\n  _",
  "headings": [

  ],
  "custom_ranking": {
    "position": 0,
    "heading": 100
  },
  "title": "Mini HoTT library in Agda",
  "toc": true,
  "agda": true,
  "gallery": true,
  "latex": true,
  "references": true,
  "showcitation": true,
  "last_modified_at": "20-Sep-18",
  "git": {
    "authors": [
      {
        "commits": 1,
        "name": "Jonathan Prieto-Cubides",
        "email": "jcu043@uib.no"
      }
    ],
    "total_commits": 1,
    "total_additions": 3451,
    "total_subtractions": 0,
    "first_commit": {
      "short_sha": "c4f28f44",
      "long_sha": "c4f28f442c4609eb0fe2795033803790551d3f6b",
      "author_name": "Jonathan Prieto-Cubides",
      "author_email": "jcu043@uib.no",
      "author_date": "Thu Sep 20 20:23:14 2018 +0200",
      "commit_name": "Jonathan Prieto-Cubides",
      "commit_email": "jcu043@uib.no",
      "commit_date": "Thu Sep 20 20:23:14 2018 +0200",
      "message": "[ bitacora ] saving progress",
      "changed_files": [
        ".git-metadata/7b5fca1be20ca8347810317bb0eebf95b1529745.json",
        "_posts/2018-09-20-bitacora.md",
        "_src/notes/2018-09-20-bitacora.md",
        "assets/png-images/2018-07-06-mini-hott.lagda",
        "assets/png-images/2018-09-20-bitacora-485765ed.png",
        "assets/png-images/2018-09-20-bitacora-c68ebbd9.png"
      ]
    },
    "last_commit": {
      "short_sha": "c4f28f44",
      "long_sha": "c4f28f442c4609eb0fe2795033803790551d3f6b",
      "author_name": "Jonathan Prieto-Cubides",
      "author_email": "jcu043@uib.no",
      "author_date": "Thu Sep 20 20:23:14 2018 +0200",
      "commit_name": "Jonathan Prieto-Cubides",
      "commit_email": "jcu043@uib.no",
      "commit_date": "Thu Sep 20 20:23:14 2018 +0200",
      "message": "[ bitacora ] saving progress",
      "changed_files": [
        ".git-metadata/7b5fca1be20ca8347810317bb0eebf95b1529745.json",
        "_posts/2018-09-20-bitacora.md",
        "_src/notes/2018-09-20-bitacora.md",
        "assets/png-images/2018-07-06-mini-hott.lagda",
        "assets/png-images/2018-09-20-bitacora-485765ed.png",
        "assets/png-images/2018-09-20-bitacora-c68ebbd9.png"
      ]
    }
  },
  "tags": [

  ],
  "categories": "type-theory",
  "date": 1530828000,
  "slug": "2018-07-06-mini-hott",
  "type": "page",
  "url": "/assets/png-images/2018-07-06-mini-hott.lagda"
}
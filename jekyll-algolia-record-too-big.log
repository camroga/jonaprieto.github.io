{
  "html": "<p>## Introduction\n\nThis is a basic overview of homotopy type theory (HoTT) formalized in Agda. It's\nonly one file and has been type-checked by Agda 2.5.4. No other libraries are\nrequired to type-check this file.\n\n{: .only-website }\n\n  **URL link**: [https://tinyurl.com/mini-hott](https://tinyurl.com/mini-hott).\n\nTo be consistent with homotopy type theory, we tell Agda to not use Axiom K for\ntype-checking by using the option `without-K`. Without Axiom K, Agda's `Set` is\nnot a good name for universes in HoTT and we rename `Set` to `Type`.\n\nThis code is working in progress and it's for my own learning purposes.\nPlease check out the references at the end of this article.\n\n\\begin{code}\n{-# OPTIONS --without-K #-}\n\nopen import Agda.Primitive using ( Level ; lsuc; lzero; _âŠ”_ ) public\n\nType : (â„“ : Level) â†’ Set (lsuc â„“)\nType â„“ = Set â„“\n\nTypeâ‚€ : Type (lsuc lzero)\nTypeâ‚€ = Type lzero\n\\end{code}\n\n## Basic types\n\n### Empty type\n\nThe Empty type, representing falsehood.\n\n\\begin{code}\n-- A datatype without constructors is the empty type.\ndata âŠ¥ {â„“áµ¢} : Type â„“áµ¢ where\n\n-- synonyms of âŠ¥\nEmpty = âŠ¥\nğŸ˜     = âŠ¥\n\\end{code}\n\nIts eliminator:\n\n\\begin{code}\n-- Ex falso quodlibet\nexfalso\n  : âˆ€ {â„“ â„“áµ¢} {A : Type â„“} â†’ âŠ¥ {â„“áµ¢} â†’ A\n\nexfalso ()\n\n-- synonyms of exfalso\nEmpty-elim = exfalso\nâŠ¥-elim     = exfalso\n\\end{code}\n\nA useful convention\n\\begin{code}\n-- Negation\nÂ¬\n  : âˆ€ {â„“} â†’ Type â„“ â†’ Type â„“\n\nÂ¬ A = (A â†’ âŠ¥ {lzero})\n\\end{code}\n\n### Unit type\n\nThe unit type is defined as record so that we also get the Î·-rule\ndefinitionally.\n\nNo elimination rule.\n\\begin{code}\nrecord âŠ¤ : Typeâ‚€ where\n  constructor â˜…\n\n{-# BUILTIN UNIT âŠ¤ #-}\n\n-- synonyms for the data constructor\nunit = â˜…\n\n-- synonyms for the Unit type\nUnit = âŠ¤\nğŸ™    = âŠ¤\n\\end{code}\n\n### Î£-type\n\nSigma types are a particular case of records, but records can be constructed\nusing only sigma types. Note that l âŠ” q is the maximum of two hierarchy levels l\nand q. This way, we define sigma types in full generality, at each universe.\n\n\\begin{code}\ninfixr 60 _,_\nrecord Î£ {â„“áµ¢ â„“â±¼} (A : Type â„“áµ¢)(C : A â†’ Type â„“â±¼) : Type (â„“áµ¢ âŠ” â„“â±¼) where\n  constructor _,_\n  field\n    Ï€â‚ : A\n    Ï€â‚‚ : C Ï€â‚\n\n  -- synonyms for data constructors\n  projâ‚ = Ï€â‚\n  projâ‚‚ = Ï€â‚‚\n  fst   = Ï€â‚\n  snd   = Ï€â‚‚\nopen Î£ public\n\\end{code}\n\n### Î -types\nShorter notation for Î -types.\n\n\\begin{code}\nÎ \n  : âˆ€ {â„“áµ¢ â„“â±¼}\n  â†’ (A : Type â„“áµ¢) (P : A â†’ Type â„“â±¼)\n  --------------------------------\n  â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\nÎ  A P = (x : A) â†’ P x\n\\end{code}\n\n### Product type\n\nProduct type as a particular case of the sigma\n\n\\begin{code}\n_Ã—_\n  : âˆ€ {â„“áµ¢ â„“â±¼}\n  â†’ (A : Type â„“áµ¢) (B : Type â„“â±¼)\n  ----------------------------\n  â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\nA Ã— B = Î£ A (Î» _ â†’ B)\n\\end{code}\n\n### Coproduct\n\nSum types as inductive types\n\n\\begin{code}\ninfixr 80 _+_\ndata _+_ {â„“áµ¢ â„“â±¼} (A : Type â„“áµ¢) (B : Type â„“â±¼) : Type (â„“áµ¢ âŠ” â„“â±¼) where\n  inl : A â†’ A + B\n  inr : B â†’ A + B\n\\end{code}\n\n### Boolean\n\nBoolean type, two constants true and false\n\n\\begin{code}\ndata Bool : Typeâ‚€ where\n  true  : Bool\n  false : Bool\n\\end{code}\n\n*Booleans can be also defined using the coproduct.*\n\n### Natural numbers\n\nNatural numbers are the initial algebra for a constant and a\nsuccessor function. The `BUILTIN` declaration allows us to use\nnatural numbers in Arabic notation.\n\n\\begin{code}\ndata â„• : Typeâ‚€ where\n  zero : â„•\n  succ : â„• â†’ â„•\n\n{-# BUILTIN NATURAL â„• #-}\n\n-- synonyms for natural numbers\nNat = â„•\n\\end{code}\n\n## Functions\n\n### Identity function\n\nThe identity function with implicit type.\n\\begin{code}\nid\n  : âˆ€ {â„“} {A : Type â„“}\n  â†’ A â†’ A\n\nid = Î» x â†’ x\n\\end{code}\n\nThe identity function on a type `A` is `idf A`.\n\n\\begin{code}\nidf\n  : âˆ€ {â„“áµ¢}\n  â†’ (A : Type â„“áµ¢)\n  ---------------\n  â†’ (A â†’ A)\n\nidf A = Î» x â†’ x\n\\end{code}\n\n### Constant function\n\nConstant function at some point `b` is `cst b`\n\n\\begin{code}\ncst\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼}\n  â†’ (b : B)\n  ---------\n  â†’ (A â†’ B)\n\ncst b = Î» _ â†’ b\n\\end{code}\n\n### Composition\n\nA more sophisticated composition function that can handle dependent functions.\n\n\\begin{code}\n_âˆ˜_\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : A â†’ Type â„“â±¼} {C : (a : A) â†’ (B a â†’ Type â„“â‚–)}\n  â†’ (g : {a : A} â†’ Î  (B a) (C a))\n  â†’ (f : Î  A B)\n  -------------------------------\n  â†’ Î  A (Î» a â†’ C a (f a))\n\ng âˆ˜ f = Î» x â†’ g (f x)\ninfixr 80 _âˆ˜_\n\\end{code}\n\nSynonym for composition (diagrammatic version)\n\\begin{code}\n_//_\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : A â†’ Type â„“â±¼} {C : (a : A) â†’ (B a â†’ Type â„“â‚–)}\n  â†’ (f : Î  A B)\n  â†’ (g : {a : A} â†’ Î  (B a) (C a))\n  -------------------------------\n  â†’ Î  A (Î» a â†’ C a (f a))\n\nf // g = g âˆ˜ f\n\\end{code}\n\n### Application\n\n\\begin{code}\ninfixr 0 _$_\n_$_\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : A â†’ Type â„“â±¼}\n  â†’ (âˆ€ x â†’ B x)\n  -------------\n  â†’ (âˆ€ x â†’ B x)\n\nf $ x = f x\n\\end{code}\n\n### Curryfication\n\n\\begin{code}\ncurry\n  : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j} {C : Î£ A B â†’ Type k}\n  â†’ (âˆ€ s â†’ C s)\n  ---------------------\n  â†’ (âˆ€ x y â†’ C (x , y))\n\ncurry f x y = f (x , y)\n\\end{code}\n\n### Uncurryfication\n\n\\begin{code}\nuncurry\n  : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j} {C : âˆ€ x â†’ B x â†’ Type k}\n  â†’ (âˆ€ x y â†’ C x y)\n  -------------------------\n  â†’ (âˆ€ s â†’ C (Ï€â‚ s) (Ï€â‚‚ s))\n\nuncurry f (x , y) = f x y\n\\end{code}\n\n### Instance search\n\n\\begin{code}\n-- how to use it â“\nâŸ¨âŸ©\n  : âˆ€ {i} {A : Type i}  â†’ A\n\nâŸ¨âŸ©  = a\n\\end{code}\n\n## Equality type\n\nIn HoTT, we have a different interpretation of type theory in which the\nset-theoretical notion of *sets* for *types* is replaced by the topological\nnotion of *spaces*. A type judgment like `x : A` means that the point `x`â€Œâ€Œ is\n*in* the topological space `A`â€Œâ€Œ. Furthermore, we include the *Identity type* as\na primary type. The inhabitants of these identity types will not be longer\ninterpreted as *proofs of equalities* but as *paths* in a Path space, an\nIdentity type.\n\n### Homogeneous equality\n\nThe Identity type is defined as an inductive type. Its induction principle is\nthe J-eliminator.\n\n\\begin{code}\ndata _==_ {â„“áµ¢} {A : Type â„“áµ¢} (a : A) : A â†’ Type â„“áµ¢ where\n  idp : a == a\n\ninfix 30 _==_\n{-# BUILTIN EQUALITY _==_ #-}\n\n-- synonyms for identity type\nPath = _==_\n\\end{code}\n\n\\begin{code}\nrefl\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢}\n  â†’ (a : A)\n  ---------\n  â†’ a == a\n\nrefl {â„“áµ¢}{A} a = idp {â„“áµ¢ = â„“áµ¢}{A = A}\n\\end{code}\n\n#### J eliminator\n\nThe elimination principle for the identity type is the path induction. It allows\nus to define an outgoing function from the identity type to a dependent type â€Œâ€Œ\nas we see in the `J` definition below.\n\n*Paulin-Mohring J rule*\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {a : A}\n  â†’ (B : (a' : A) (p : a == a') â†’ Type â„“â±¼)\n  â†’ (d : B a idp)\n  ----------------------------------------\n  â†’ {a' : A} (p : a == a') â†’ B a' p\n\nJ {a = a} B d idp = d\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ'\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {a : A}\n  â†’ (B : (a' : A) (p : a' == a) â†’ Type â„“â±¼)\n  â†’ (d : B a idp)\n  ----------------------------------------\n  â†’ {a' : A} (p : a' == a) â†’ B a' p\n\nJ' {a = a} B d idp = d\n\\end{code}\n\n#### Composition of paths\n\n{: .foldable until=\"6\" }\n\\begin{code}\n_Â·_\n  : âˆ€ {â„“} {A : Type â„“} {x y z : A}\n  â†’ (p : x == y)\n  â†’ (q : y == z)\n  --------------\n  â†’ x == z\n\n_Â·_ idp q = q\n\ninfixl 50 _Â·_\n\\end{code}\n\n![path](/assets/ipe-images/path-concatenation.png){: width=\"60%\" }\n\n#### Inverse of paths\n\n\\begin{code}\ninv\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ a == b\n  --------\n  â†’ b == a\n\ninv idp = idp\n\n-- synonyms for inverse path\ninfixl 60 _â»Â¹\n_â»Â¹ = inv\n\ninfixr 60 !_\n!_  = inv\n\\end{code}\n\n#### Associativity of composition\n\n- Left associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\nâˆ˜-lassoc\n  : âˆ€ {â„“} {A B C D : Type â„“}\n  â†’ (h : C â†’ D) â†’ (g : B â†’ C) â†’ (f : A â†’ B)\n  -----------------------------------------\n  â†’ (h âˆ˜ (g âˆ˜ f)) == ((h âˆ˜ g) âˆ˜ f)\n\nâˆ˜-lassoc h g f = idp {a = (Î» x â†’ h (g (f x)))}\n\\end{code}\n\n- Right associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\nâˆ˜-rassoc\n  : âˆ€ {â„“} {A B C D : Type â„“}\n  â†’ (h : C â†’ D) â†’ (g : B â†’ C) â†’ (f : A â†’ B)\n  -----------------------------------------\n  â†’ ((h âˆ˜ g) âˆ˜ f) == (h âˆ˜ (g âˆ˜ f))\n\nâˆ˜-rassoc h g f = (âˆ˜-lassoc h g f) â»Â¹\n\\end{code}\n\n### Heterogeneous equality\n\n\\begin{code}\ndata HEq {â„“} (A : Type â„“)\n           : (B : Type â„“)\n           â†’ (Î± : A == B) (a : A) (b : B)\n           â†’ Type â„“ where\n  idp : âˆ€ {a : A} â†’ HEq A A idp a a\n\\end{code}\n\n## Equational reasoning\n\nEquational reasoning is a way to write readable chains of equalities.\n\n\n```agda\n  t : a == e\n  t = a =âŸ¨ p âŸ©\n      b =âŸ¨ q âŸ©\n      c =âŸ¨ r âŸ©\n      d =âŸ¨ s âŸ©\n      e âˆ\n```\n\n\nwhere `p` is a path from `a` to `b`, `q` is a path from `b` to `c`, and so on.\n\n\\begin{code}\nmodule EquationalReasoning {â„“áµ¢} {A : Type â„“áµ¢} where\n\\end{code}\n\nDefinitional equals:\n\n\\begin{code}\n  _==âŸ¨âŸ©_\n    : âˆ€ (x {y} : A)\n    â†’ x == y â†’ x == y\n\n  _ ==âŸ¨âŸ© p = p\n\n  -- synonyms for _==âŸ¨âŸ©\n  _==âŸ¨idpâŸ©_  = _==âŸ¨âŸ©_\n  _==âŸ¨reflâŸ©_ = _==âŸ¨âŸ©_\n\n  infixr 2 _==âŸ¨âŸ©_\n\\end{code}\n\n\\begin{code}\n  -- chain\n  _==âŸ¨_âŸ©_\n    : (x : A) {y z : A}\n    â†’ x == y\n    â†’ y == z\n    â†’ x == z\n\n  _ ==âŸ¨ thm âŸ© q = thm Â· q\n\n  infixr 2 _==âŸ¨_âŸ©_\n\\end{code}\n\n\\begin{code}\n  -- Q.E.D\n  infix 3 _âˆ\n  _âˆ\n    : (x : A)\n    â†’ x == x\n\n  _âˆ = Î» x â†’ idp\n\\end{code}\n\n\\begin{code}\n  -- Begin\n  infix 1 begin_\n  begin_\n    : {x y : A}\n    â†’ x == y\n    â†’ x == y\n\n  begin_ p = p\n\\end{code}\n\n\\begin{code}\nopen EquationalReasoning public\n\\end{code}\n## Actions on paths\n\nFunctions are functors to equalities.  In other words, functions\npreserve equalities.\n\n{: .foldable until=\"6\" }\n\\begin{code}\nap\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼}\n  â†’ (f : A â†’ B) {aâ‚ aâ‚‚ : A}\n  â†’ aâ‚ == aâ‚‚\n  --------------\n  â†’ f aâ‚ == f aâ‚‚\n\nap f idp = idp\n\\end{code}\n\nNow, we can define a convenient syntax sugar for `ap` in\nequational reasoning.\n\n\\begin{code}\ninfixl 40 ap\nsyntax ap f p = p |in-ctx f\n\\end{code}\n\nLet's suppose we have a lemma:\n\n```agda\n  lemma : a == b\n  lemma = _\n```\n\nused in an equational reasoning like:\n\n```agda\n  t : a == e\n  t = f a =âŸ¨ ap f lemma âŸ©\n      f b\n      âˆ\n```\n\n\nThen, we can now put the lemma in front:\n\n```agda\n  t : a == e\n  t = f a =âŸ¨ lemma |in-ctx f âŸ©\n      f b\n      âˆ\n```\n\n\nLastly, we can also define actions on two paths:\n\n{: .foldable until=\"7\" }\n\\begin{code}\napâ‚‚\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {C : Type â„“â‚–}  {bâ‚ bâ‚‚ : B}\n  â†’ (f : A â†’ B â†’ C)\n  â†’ {aâ‚ aâ‚‚ : A} â†’ (aâ‚ == aâ‚‚)\n  â†’ {bâ‚ bâ‚‚ : B} â†’ (bâ‚ == bâ‚‚)\n  --------------------------\n  â†’ f aâ‚ bâ‚  == f aâ‚‚ bâ‚‚\n\napâ‚‚ f idp idp = idp\n\\end{code}\n\n### Lemmas\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-Â·\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {a b c : A}\n  â†’ (f : A â†’ B) â†’ (p : a == b) â†’ (q : b == c)\n  -------------------------------------------\n  â†’ ap f (p Â· q) == ap f p Â· ap f q\n\nap-Â· f idp q = refl (ap f q)\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-inv\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {a b : A}\n  â†’ (f : A â†’ B) â†’ (p : a == b)\n  ----------------------------\n  â†’ ap f (p â»Â¹) == (ap f p) â»Â¹\n\nap-inv f idp = idp\n\n-- synonyms\nap-! = ap-inv\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\nap-comp\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {C : Type â„“â‚–} {a b : A}\n  â†’ (f : A â†’ B)\n  â†’ (g : B â†’ C)\n  â†’ (p : a == b)\n  -------------------------------\n  â†’ ap g (ap f p) == ap (g âˆ˜ f) p\n\nap-comp f g idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-id\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {a b : A}\n  â†’ (p : a == b)\n  --------------\n  â†’ ap id p == p\n\nap-id idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-const\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {C : Type â„“â±¼} {a b : A} {c : C}\n  â†’ (p : a == b)\n  -----------------------\n  â†’ ap (Î» _ â†’ c) p == idp\n\nap-const {c = c} idp = refl (refl c)\n\\end{code}\n\n## Properties on the groupoid\n\nSome properties on the groupoid structure of equalities\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-runit\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  --------------\n  â†’ p == p Â· idp\n\nÂ·-runit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-lunit\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  --------------\n  â†’ p == idp Â· p\n\nÂ·-lunit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-linv\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  ----------------\n  â†’ ! p Â· p == idp\n\nÂ·-linv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-rinv\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  ----------------\n  â†’ p Â· ! p == idp\n\nÂ·-rinv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ninvolution\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ {p : a == b}\n  ---------------\n  â†’ ! (! p) == p\n\ninvolution {p = idp} = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-assoc\n  : âˆ€ {â„“} {A : Type â„“} {a b c d : A}\n  â†’ (p : a == b) â†’ (q : b == c) â†’ (r : c == d)\n  --------------------------------------------\n  â†’ p Â· q Â· r == p Â· (q Â· r)\n\nÂ·-assoc idp q r = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\nÂ·-cancellation\n  : âˆ€ {â„“} {A : Type â„“} {a : A}\n  â†’ (p : a == a) â†’ (q : a == a)\n  â†’ p Â· q == p\n  -----------------------------\n  â†’ q == refl a\n\nÂ·-cancellation {a = a} p q Î± =\n    begin\n      q             ==âŸ¨ ap (_Â· q) (! (Â·-linv p)) âŸ©\n      ! p Â· p Â· q   ==âŸ¨ (Â·-assoc (! p) _ _) âŸ©\n      ! p Â· (p Â· q) ==âŸ¨ (ap (! p Â·_) Î±) âŸ©\n      ! p Â· p       ==âŸ¨ Â·-linv p âŸ©\n      refl a\n    âˆ\n\\end{code}\n\nMoving a term from one side to the other is a common task,\nso let's define some handy functions for that.\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-left-to-right-l\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  â†’ p Â· q == r\n  ------------------\n  â†’     q == ! p Â· r\n\nÂ·-left-to-right-l {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    q\n      ==âŸ¨ Â·-lunit q âŸ©\n    refl b Â· q\n      ==âŸ¨ ap (_Â· q) (! (Â·-linv p)) âŸ©\n    (! p Â· p) Â· q\n      ==âŸ¨ Â·-assoc (! p) p q âŸ©\n    ! p Â· (p Â· q)\n      ==âŸ¨ ap (! p Â·_) Î± âŸ©\n    ! p Â· r\n  âˆ\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-left-to-right-r\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  â†’ p Â· q == r\n  -------------------\n  â†’      p == r Â· ! q\n\nÂ·-left-to-right-r {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    p\n      ==âŸ¨ Â·-runit p âŸ©\n    p Â· refl b\n      ==âŸ¨ ap (p Â·_) (! (Â·-rinv q)) âŸ©\n    p Â· (q Â· ! q)\n      ==âŸ¨ ! (Â·-assoc p q (! q)) âŸ©\n    (p Â· q) Â· ! q\n      ==âŸ¨ ap (_Â· ! q) Î± âŸ©\n    r Â· ! q\n  âˆ\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-right-to-left-r\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  â†’       p == q Â· r\n  -------------------\n  â†’ p Â· ! r == q\n\nÂ·-right-to-left-r {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    p Â· ! r\n      ==âŸ¨ ap (_Â· ! r) Î± âŸ©\n    (q Â· r) Â· ! r\n      ==âŸ¨ Â·-assoc q r (! r) âŸ©\n    q Â· (r Â· ! r)\n      ==âŸ¨ ap (q Â·_) (Â·-rinv r) âŸ©\n    q Â· refl b\n      ==âŸ¨ ! (Â·-runit q) âŸ©\n    q\n    âˆ\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-right-to-left-l\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  â†’       p == q Â· r\n  ------------------\n  â†’ ! q Â· p == r\n\nÂ·-right-to-left-l {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    ! q Â· p\n      ==âŸ¨ ap (! q Â·_) Î± âŸ©\n    ! q Â· (q Â· r)\n      ==âŸ¨ ! (Â·-assoc (! q) q r) âŸ©\n    ! q Â· q Â· r\n      ==âŸ¨ ap (_Â· r) (Â·-linv q) âŸ©\n    refl b Â· r\n      ==âŸ¨ ! (Â·-lunit r) âŸ©\n    r\n  âˆ\n\\end{code}\n\nFinally, when we invert a path composition this is what we got.\n\n{: .foldable until=\"6\" }\n\\begin{code}\n!-Â·\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  â†’ (q : b == a)\n  --------------------------\n  â†’ ! (p Â· q) == ! q Â· ! p\n\n!-Â· idp q = Â·-runit (! q)\n\\end{code}\n\n## Transport\n\n![path](/assets/ipe-images/transport-fiber-minihott.png){: width=\"60%\" }\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}\n  â†’ (C : A â†’ Type â„“â±¼) {aâ‚ aâ‚‚ : A}\n  â†’ (p : aâ‚ == aâ‚‚)\n  -------------------------------\n  â†’ (C aâ‚ â†’ C aâ‚‚)\n\ntransport C idp = (Î» x â†’ x)\n\\end{code}\n\n\\begin{code}\n-- synonyms\ntr     = transport\ntransp = transport\n\\end{code}\n\nStar notation for transport\n\n{: .foldable until=\"5\" }\n\\begin{code}\n_âœ¶\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {C : A â†’ Type â„“â±¼} {aâ‚ aâ‚‚ : A}\n  â†’ (p : aâ‚ == aâ‚‚)\n  ----------------\n  â†’ (C aâ‚ â†’ C aâ‚‚)\n\n_âœ¶ {â„“áµ¢}{â„“â±¼}{C = C} = transport {â„“áµ¢ = â„“áµ¢} {â„“â±¼ = â„“â±¼} C\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ncoe\n  : âˆ€ {â„“} {A B : Type â„“}\n  â†’ A == B\n  ---------\n  â†’ (A â†’ B)\n\ncoe p A = transport (Î» X â†’ X) p A\n\\end{code}\n\n### Pathover\n\nLet be `A : Type`, `aâ‚, aâ‚‚ : A`, `C : A â†’ Type`, `câ‚ : C aâ‚` and `câ‚‚ : C aâ‚‚`.\nUsing the same notation from <a href=\"#hottbook\">(Univalent Foundations Program, 2013)</a>, one of the definitions for the\nPathover type is as the shorthand for the path between the transport along a\npath `Î± : aâ‚ = aâ‚‚` of the point `câ‚ : C aâ‚` and the point `câ‚‚` in the fiber `C\naâ‚‚`. That is, a pathover is a term that inhabit the type `transport C Î± câ‚ = câ‚‚`\nalso denoted by `PathOver C Î± câ‚ câ‚‚`.\n\n![path](/assets/ipe-images/pathover-3-minihott.png){: width=\"60%\" }\n\n\\begin{code}\nPathOver\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}(C : A â†’ Type â„“â±¼) {aâ‚ aâ‚‚ : A}\n  â†’ (Î± : aâ‚ == aâ‚‚) (câ‚ : C aâ‚) (câ‚‚ : C aâ‚‚)\n  ----------------------------------------\n  â†’ Type â„“â±¼\n\nPathOver C Î± câ‚ câ‚‚ = tr C Î± câ‚ == câ‚‚\n\\end{code}\n\n\\begin{code}\ninfix 30 PathOver\nsyntax PathOver B p u v = u == v [ B â†“ p ]\n\\end{code}\n\n### Lemmas\n\nSome lemmas on the transport operation\n\n{: .foldable until=\"6\" }\n\\begin{code}\nlift\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {aâ‚ aâ‚‚ : A} {â„“â±¼} {C : A â†’ Type â„“â±¼}\n  â†’ (u : C aâ‚)\n  â†’ (Î± : aâ‚ == aâ‚‚)\n  -----------------------------\n  â†’ (aâ‚ , u) == (aâ‚‚ , tr C Î± u)\n\nlift {aâ‚ = aâ‚} u idp = refl (aâ‚ , u)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-const\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {aâ‚  aâ‚‚ : A} {â„“â±¼} {B : Type â„“â±¼}\n  â†’ (p : aâ‚ == aâ‚‚)\n  â†’ (b : B)\n  -----------------------\n  â†’ tr (Î» _ â†’ B) p b == b\n\ntransport-const idp b = refl b\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-r\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {a : A} {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : a == x)\n  ---------------------------------\n  â†’  tr (Î» x â†’ a == x) p q == q Â· p\n\ntransport-concat-r idp q = Â·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-l\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {a : A} {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : x == a)\n  ----------------------------------\n  â†’ tr (Î» x â†’ x == a) p q == ! p Â· q\n\ntransport-concat-l idp q = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : x == x)\n  ---------------------------------------\n  â†’ tr (Î» x â†’ x == x) p q == ! p Â· q Â· p\n\ntransport-concat idp q = Â·-runit q\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {â„“â±¼} {B : Type â„“â±¼}\n  â†’ (f g : A â†’ B) {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : f x == g x)\n  --------------------------------------------------------\n  â†’ tr (Î» z â†’ f z == g z) p q == ! (ap f p) Â· q Â· (ap g p)\n\ntransport-eq-fun f g idp q = Â·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-comp\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢}{â„“â±¼} {a b c : A} {P : A â†’ Type â„“â±¼}\n  â†’ (p : a == b)\n  â†’ (q : b == c)\n  ---------------------------------------\n  â†’ ((tr P q) âˆ˜ (tr P p)) == tr P (p Â· q)\n\ntransport-comp {P = P} idp q = refl (transport P q)\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-comp-h\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {â„“â±¼} {a b c : A} {P : A â†’ Type â„“â±¼}\n  â†’ (p : a == b)\n  â†’ (q : b == c)\n  â†’ (x : P a)\n  -------------------------------------------\n  â†’ ((tr P q) âˆ˜ (tr P p)) x == tr P (p Â· q) x\n\ntransport-comp-h {P = P} idp q x = refl (transport P q x)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-eq-fun-l\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {b : B} (f : A â†’ B) {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : f x == b)\n  -------------------------------------------\n  â†’ tr (Î» z â†’ f z == b) p q == ! (ap f p) Â· q\n\ntransport-eq-fun-l {b = b} f p q =\n  begin\n    transport (Î» z â†’ f z == b) p q   ==âŸ¨ transport-eq-fun f (Î» _ â†’ b) p q âŸ©\n    ! (ap f p) Â· q Â· ap (Î» _ â†’ b) p  ==âŸ¨ ap (! (ap f p) Â· q Â·_) (ap-const p) âŸ©\n    ! (ap f p) Â· q Â· idp             ==âŸ¨ ! (Â·-runit _) âŸ©\n    ! (ap f p) Â· q\n  âˆ\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun-r\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {b : B}\n  â†’ (g : A â†’ B) {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : b == g x)\n  ------------------------------------------------\n  â†’ tr (Î» z â†’ b == g z) p q == q Â· (ap g p)\n\ntransport-eq-fun-r {b = b} g p q =\n  begin\n    transport (Î» z â†’ b == g z) p q    ==âŸ¨ transport-eq-fun (Î» _ â†’ b) g p q âŸ©\n    ! (ap (Î» _ â†’ b) p) Â· q Â· ap g p   ==âŸ¨ Â·-assoc (! (ap (Î» _ â†’ b) p)) q (ap g p) âŸ©\n    ! (ap (Î» _ â†’ b) p) Â· (q Â· ap g p) ==âŸ¨ ap (Î» u â†’ ! u Â· (q Â· ap g p)) (ap-const p) âŸ©\n    (q Â· ap g p)\n  âˆ\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-inv\n  : âˆ€ {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{x y : X}\n  â†’ (p : x == y)\n  â†’ {a : A y}\n  --------------------------------------\n  â†’ tr (Î» v â†’ A v) p (tr A (! p) a) == a\n\ntransport-inv {A = A}  idp {a = a} =\n  begin\n    tr (Î» v â†’ A v) idp (tr A (! idp) a)\n      ==âŸ¨ idp âŸ©\n    tr A (! idp Â· idp) a\n      ==âŸ¨âŸ©\n    tr A idp a\n      ==âŸ¨ idp âŸ©\n    a\n  âˆ\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-l\n  : âˆ€ {â„“} {A B : Type â„“}\n  â†’ (p : A == B)\n  â†’ (b : B)\n  --------------------------------------------\n  â†’ tr (Î» v â†’ v) p (tr (Î» v â†’ v) (! p) b) == b\n\ncoe-inv-l idp b = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-r\n  : âˆ€ {â„“} {A B : Type â„“}\n  â†’ (p : A == B)\n  â†’ (a : A)\n  -----------------------------------------------------------\n  â†’ tr (Î» v â†’ v) (! p) (tr (Î» v â†’ v) p a) == a\n\ncoe-inv-r idp b = idp\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-family\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {P : B â†’ Type â„“â‚–}\n  â†’ {f : A â†’ B} â†’ {x y : A}\n  â†’ (p : x == y)\n  â†’ (u : P (f x))\n  -----------------------------------\n  â†’ tr (P âˆ˜ f) p u == tr P (ap f p) u\n\ntransport-family idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-family-id\n  : âˆ€ {â„“áµ¢ â„“â‚–} {A : Type â„“áµ¢} {P : A â†’ Type â„“â‚–} â†’ {x y : A}\n  â†’ (p : x == y)\n  â†’ (u : P x)\n  ----------------------------------------------\n  â†’ transport (Î» a â†’ P a) p u == transport P p u\n\ntransport-family-id idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-fun\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {x y : X} {A : X â†’ Type â„“â±¼} {B : X â†’ Type â„“â‚–}\n  â†’ (p : x == y)\n  â†’ (f : A x â†’ B x)\n  -----------------------------------------------------------------\n  â†’ tr (Î» x â†’ (A x â†’ B x)) p f == (Î» x â†’ tr B p (f (tr A (! p) x)))\n\ntransport-fun idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth = transport-fun\n\\end{code}\n\n![path](/assets/ipe-images/transport-fun.png){: width=\"100%\" }\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-fun-h\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼} {B : X â†’ Type â„“â‚–}\n  â†’ {x y : X}\n  â†’ (p : x == y) â†’ (f : A x â†’ B x)\n  â†’ (b : A y)\n  --------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (A x â†’ B x)) p f) b == tr B p (f (tr A (! p) b))\n\ntransport-fun-h idp f b = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth-h = transport-fun-h\n\\end{code}\n\nNow, when we transport dependent functions this is what we got:\n\n![path](/assets/ipe-images/transport-fun-dependent.png){: width=\"100%\" }\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent-h\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}\n  â†’ {B : (x : X) â†’ (a : A x) â†’ Type â„“â‚–} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  ---------------------------------------------------------------------\n  â†’ (a' : A y)\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a'\n    == tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent-h idp f a' = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth-h = transport-fun-dependent-h\n\\end{code}\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}\n  â†’ {B : (x : X) â†’ (a : A x) â†’ Type â„“â‚–} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  ---------------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f)\n    == Î» (a' : A y)\n      â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth = transport-fun-dependent\n\\end{code}\n\nAction on PathOvers, this was suggested by Fredrik Nordvall:\n\n{: .foldable until=\"9\"}\n\\begin{code}\napOver\n  : {A A' : Typeâ‚€} {C : A â†’ Typeâ‚€} {C' : A' â†’ Typeâ‚€}  -- types\n  â†’ {a a' : A} {b : C a} {b' : C a'}                  -- points\n  â†’ (f : A â†’ A')\n  â†’ (g : {x : A} â†’ C x â†’ C' (f x))\n  â†’ (p : a == a')\n  â†’ b == b' [ C â†“ p ]\n  --------------------------------\n  â†’ g b == g b' [ C' â†“ ap f p ]\n\napOver f g idp q = ap g q\n\\end{code}\n\n## Basic type lemmas\n\n### Sigma type\n\nOur context:\n\n\\begin{code}\nmodule Sigma {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : A â†’ Type â„“â±¼} where\n\\end{code}\n\nTwo dependent pairs are equal if they are componentwise equal.\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Î£-componentwise\n    : {v w : Î£ A P}\n    â†’ v == w\n    ----------------------------------------------\n    â†’ Î£ (Ï€â‚ v == Ï€â‚ w) (Î» p â†’ (p âœ¶) (Ï€â‚‚ v) == Ï€â‚‚ w)\n\n  Î£-componentwise  idp = (idp , idp)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Î£-bycomponents\n    : {v w : Î£ A P}\n    â†’ Î£ (Ï€â‚ v == Ï€â‚ w) (Î» p â†’ (p âœ¶) (Ï€â‚‚ v) == Ï€â‚‚ w)\n    -----------------------------------------------\n    â†’ v == w\n\n  Î£-bycomponents (idp , idp) = idp\n\n  -- synonym of Î£-bycomponents\n  pair= = Î£-bycomponents\n\\end{code}\n\nA trivial consequence is the following identification:\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  lift-pair=\n    : âˆ€ {x y : A} {u : P x}\n    â†’ (p : x == y)\n    --------------------------------------------------------\n    â†’ lift {A = A}{C = P} u p == pair= (p , refl (tr P p u))\n\n  lift-pair= idp = idp\n\\end{code}\n\n\\begin{code}\n-- Uniqueness principle property for products\n  uppt : (x : Î£ A P) â†’ (Ï€â‚ x , Ï€â‚‚ x) == x\n  uppt (a , b) = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  Î£-ap-Ï€â‚\n    : {aâ‚ aâ‚‚ : A} {bâ‚ : P aâ‚} {bâ‚‚ : P aâ‚‚}\n    â†’ (Î± : aâ‚ == aâ‚‚)\n    â†’ (Î³ : transport P Î± bâ‚ == bâ‚‚)\n    ------------------------------\n    â†’ ap Ï€â‚ (pair= (Î± , Î³)) == Î±\n\n  Î£-ap-Ï€â‚ idp idp = idp\n\n  -- synonym for this lemma\n  ap-Ï€â‚-pair= = Î£-ap-Ï€â‚\n\\end{code}\n\n\\begin{code}\nopen Sigma public\n\\end{code}\n\n{: .foldable until=\"10\"}\n\\begin{code}\ntransport-fun-dependent-bezem\n  : âˆ€ {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}\n      {B : (x : X) â†’ (a : A x) â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (a' : A y)\n  ----------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a'\n    == tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w))\n          (pair= (p , transport-inv p )) (f (tr A (! p) a'))\n\ntransport-fun-dependent-bezem idp f a' = idp\n\\end{code}\n\n### Cartesian product\n\n\\begin{code}\nmodule CartesianProduct {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodComponentwise\n    : {x y : A Ã— B}\n    â†’ (x == y)\n    ---------------------------------\n    â†’ (Ï€â‚ x == Ï€â‚ y) Ã— (Ï€â‚‚ x == Ï€â‚‚ y)\n\n  prodComponentwise {x = x} idp = refl (Ï€â‚ x) , refl (Ï€â‚‚ x)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByComponents\n    : {x y : A Ã— B}\n    â†’ (Ï€â‚ x == Ï€â‚ y) Ã— (Ï€â‚‚ x == Ï€â‚‚ y)\n    ---------------------------------\n    â†’ (x == y)\n\n  prodByComponents {x = a , b} (idp , idp) = refl (a , b)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodCompInverse\n    : {x y : A Ã— B}\n    â†’ (b : (Ï€â‚ x == Ï€â‚ y) Ã— (Ï€â‚‚ x == Ï€â‚‚ y))\n    ---------------------------------------------\n    â†’ prodComponentwise (prodByComponents b) == b\n\n  prodCompInverse {x} (idp , idp) = refl (refl (Ï€â‚ x) , refl (Ï€â‚‚ x))\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByCompInverse\n    : {x y : A Ã— B}\n    â†’ (b : x == y)\n    ---------------------------------------------\n    â†’ prodByComponents (prodComponentwise b) == b\n\n  prodByCompInverse {x = x} idp = refl (refl x)\n\\end{code}\n\n\\begin{code}\nopen CartesianProduct\n\\end{code}\n\n## Action on dependent paths\n\n{: .foldable until=\"5\"}\n\\begin{code}\napd\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}  {P : A â†’ Type â„“â±¼} {a b : A}\n  â†’ (f : (a : A) â†’ P a) â†’ (p : a == b)\n  ------------------------------------\n  â†’ transport P p (f a) == f b\n\napd f idp = idp\n\\end{code}\n\n## Homotopy\n\n&gt; In a type-theoretical sense, a homotopy between two\n&gt; functions is a family of equalities between their applications.\n\nThe context:\n\\begin{code}\nmodule Homotopy {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : A â†’ Type â„“â±¼} where\n\\end{code}\n\nLet $$f , g : \\prod\\limits_{(x:A)} P(x)$$ be two sections of a\ntype family $$P : A \\to \\mathcal{U}$$. A **homotopy** from $$f$$ to $$g$$\nis a dependent function of type\n\n{: .equation }\n  $$ (f \\sim g) :\\equiv \\prod\\limits_{x : A} (f(x) = g(x)). $$\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Lemma.\n  homotopy\n    : (f g : Î  A P)\n    ---------------\n    â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\n  homotopy f g = âˆ€ (x : A) â†’ f x == g x\n\\end{code}\n\n\\begin{code}\n  -- Usual notation for homotopy\n  _âˆ¼_ : (f g : ((x : A) â†’ P x)) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  f âˆ¼ g = homotopy f g\n\\end{code}\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Homotopy is an equivalence relation\n  h-refl\n    : (f : Î  A P)\n    -------------\n    â†’ f âˆ¼ f\n\n  h-refl f x = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  h-sym\n    : (f g : Î  A P)\n    â†’ f âˆ¼ g\n    -------\n    â†’ g âˆ¼ f\n\n  h-sym _ _ e x = ! (e x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-comp\n    : {f g h : Î  A P}\n    â†’ f âˆ¼ g\n    â†’ g âˆ¼ h\n    -------\n    â†’ f âˆ¼ h\n\n  h-comp u v x = (u x) Â· (v x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- synonym for h-comp\n  _â—_\n    : {f g h : Î  A P}\n    â†’ f âˆ¼ g\n    â†’ g âˆ¼ h\n    -------\n    â†’ f âˆ¼ h\n\n  Î± â— Î² = h-comp Î± Î²\n\\end{code}\n\n\\begin{code}\nopen Homotopy public\n\\end{code}\n\n### Composition with homotopies\n\n\\begin{code}\nmodule HomotopyComposition {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {C : Type â„“â‚–} where\n\\end{code}\n\n{: .foldable until=\"8\"}\n\\begin{code}\n  -- Lemma.\n  hl-comp\n    : {f g : A â†’ B}\n    â†’ {j k : B â†’ C}\n    â†’ f âˆ¼ g\n    â†’ j âˆ¼ k\n    -------------------\n    â†’ (j âˆ˜ f) âˆ¼ (k âˆ˜ g)\n\n  hl-comp {g = g}{j = j} f-g j-k = Î» x â†’ ap j (f-g x) Â· j-k (g x)\n\\end{code}\n\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  rcomp-âˆ¼\n    : (f : A â†’ B)\n    â†’ {j k : B â†’ C}\n    â†’ j âˆ¼ k\n    -------------------\n    â†’ (j âˆ˜ f) âˆ¼ (k âˆ˜ f)\n\n  rcomp-âˆ¼ f j-k = hl-comp (h-refl f) j-k\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  lcomp-âˆ¼\n    : {f g : A â†’ B}\n    â†’ (j : B â†’ C)\n    â†’ f âˆ¼ g\n    -------------------\n    â†’ (j âˆ˜ f) âˆ¼ (j âˆ˜ g)\n\n  lcomp-âˆ¼ j Î± = hl-comp Î± (h-refl j)\n\\end{code}\n\n\\begin{code}\nopen HomotopyComposition\n\\end{code}\n\n### Naturality\n\n\\begin{code}\nmodule Naturality {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\\end{code}\n\nHomotopy is natural, meaning that it satisfies the following\nsquare commutative diagram.\n\n![path](/assets/ipe-images/h-naturality.png){: width=\"40%\" }\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-naturality\n    : {f g : A â†’ B} â†’ {x y : A}\n    â†’ (H : f âˆ¼ g)\n    â†’ (p : x == y)\n    ------------------------------\n    â†’ H x Â· ap g p == ap f p Â· H y\n\n  h-naturality {x = x} H idp = ! (Â·-runit (H x))\nopen Naturality\n\\end{code}\n\nA particular case of naturality on the identity function.\n\n{: .foldable until=\"5\"}\n\\begin{code}\nh-naturality-id\n  : âˆ€ {â„“} {A : Type â„“} {f : A â†’ A} â†’ {x : A}\n  â†’ (H : f âˆ¼ id)\n  -----------------------\n  â†’ H (f x) == ap f (H x)\n\nh-naturality-id {f = f} {x = x} H =\n  begin\n    H (f x)\n      ==âŸ¨ Â·-runit (H (f x)) âŸ©\n    H (f x) Â· refl (f x)\n      ==âŸ¨ ap (H (f x) Â·_) (! (Â·-rinv (H x))) âŸ©\n    H (f x) Â· ((H x) Â· (! (H x)))\n      ==âŸ¨ ap (H (f x) Â·_) (ap (_Â· (! (H x))) (! ap-id (H x))) âŸ©\n    H (f x) Â· (ap id (H x) Â· ! (H x))\n      ==âŸ¨ ! (Â·-assoc (H (f x)) (ap id (H x)) (! (H x))) âŸ©\n    (H (f x) Â· ap id (H x)) Â· ! (H x)\n      ==âŸ¨ Â·-right-to-left-r (h-naturality H (H x)) âŸ©\n    ap f (H x)\n  âˆ\n\\end{code}\n\n## .... REVIWING .... BELOW\n\n## Fibers\n\nContractible types with a center of contraction.\n\n\\begin{code}\nmodule Fibers {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼}  where\n\n  -- The fiber of a map over a point is given by\n  fib\n    : (f : A â†’ B)\n    â†’ (b : B)\n    ---------------\n    â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\n  fib f b = Î£ A (Î» a â†’ f a == b)\n\n\n  -- A function applied over the fiber returns the original point\n  fib-eq : {f : A â†’ B} â†’ {b : B} â†’ (h : fib f b) â†’ f (Ï€â‚ h) == b\n  fib-eq (a , Î±) = Î±\n\n  -- Each point is on the fiber of its image\n  fib-image : {f : A â†’ B} â†’ {a : A} â†’ fib f (f a)\n  fib-image {f} {a} = a , refl (f a)\n\nopen Fibers public\n\\end{code}\n\n## Contractible types\n\n\\begin{code}\n-- Contractible.  Contractible types with a center of contraction.\nmodule Contractible where\n\n  -- Contractible types. A contractible type is a type such that every\n  -- element is equal to a center of contraction.\n  isContr : âˆ€ {â„“}  (A : Type â„“) â†’ Type â„“\n  isContr A = Î£ A (Î» a â†’ ((x : A) â†’ a == x))\nopen Contractible public\n\n\\end{code}\n\n## Equivalence\n\n\\begin{code}\nmodule Equivalence where\n\n  module DefinitionOfEquivalence {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n    -- Contractible maps. A map is contractible if the fiber in any\n    -- point is contractible, that is, each element has a unique\n    -- preimage.\n    isContrMap : (f : A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n    isContrMap f = (b : B) â†’ isContr (fib f b)\n\\end{code}\n\n\\begin{code}\n    -- There exists an equivalence between two types if there exists a\n    -- contractible function between them.\n    isEquiv : (f : A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n    isEquiv = isContrMap\n  open DefinitionOfEquivalence public\n\\end{code}\n\n\\begin{code}\n  -- Equivalence of types.\n  _â‰ƒ_ : âˆ€ {â„“áµ¢ â„“â±¼}  (A : Type â„“áµ¢) (B : Type â„“â±¼) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  A â‰ƒ B = Î£ (A â†’ B) isEquiv\n\\end{code}\n\n\\begin{code}\n  module EquivalenceMaps {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n    -- Maps of an equivalence\n    lemap : A â‰ƒ B â†’ (A â†’ B)\n    lemap = Ï€â‚\n\n    â‰ƒ-to-â†’ = lemap\n    funâ‰ƒ   = lemap\n\n    remap : A â‰ƒ B â†’ (B â†’ A)\n    remap (f , contrf) b = Ï€â‚ (Ï€â‚ (contrf b))\n\n    -- The maps of an equivalence are inverses in particular\n    lrmap-inverse : (eq : A â‰ƒ B) â†’ {b : B} â†’ (lemap eq) ((remap eq) b) == b\n    lrmap-inverse (f , eqf) {b} = fib-eq (Ï€â‚ (eqf b))\n\n    rlmap-inverse : (eq : A â‰ƒ B) â†’ {a : A} â†’ (remap eq) ((lemap eq) a) == a\n    rlmap-inverse (f , eqf) {a} = ap Ï€â‚ ((Ï€â‚‚ (eqf (f a))) fib-image)\n\n    lrmap-inverse-h : (eq : A â‰ƒ B) â†’ ((lemap eq) âˆ˜ (remap eq)) âˆ¼ id\n    lrmap-inverse-h eq = Î» x â†’ lrmap-inverse eq {x}\n\n    rlmap-inverse-h : (eq : A â‰ƒ B) â†’ ((remap eq) âˆ˜ (lemap eq)) âˆ¼ id\n    rlmap-inverse-h eq = Î» x â†’ rlmap-inverse eq {x}\n  open EquivalenceMaps public\n\\end{code}\n\n\\begin{code}\nopen Equivalence public\n\\end{code}\n\n## Function extensionality\n\n\\begin{code}\n\nmodule FunExt {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}\n  {B : A â†’ Type â„“â±¼} {f g : (a : A) â†’ B a} where\n\\end{code}\n\n\\begin{code}\n  -- Application of an homotopy\n  happly : f == g â†’ ((x : A) â†’ f x == g x)\n  happly idp x = refl (f x)\n\\end{code}\n\n\\begin{code}\n  -- The axiom of function extensionality postulates that the\n  -- application of homotopies is an equivalence.\n  postulate axiomFunExt : isEquiv happly\n\\end{code}\n\n\\begin{code}\n  eqFunExt : (f == g) â‰ƒ ((x : A) â†’ f x == g x)\n  eqFunExt = happly , axiomFunExt\n\\end{code}\n\n\\begin{code}\n  -- From this, the usual notion of function extensionality follows.\n  funext : ((x : A) â†’ f x == g x) â†’ f == g\n  funext = remap eqFunExt\n\\end{code}\n\n\\begin{code}\n  -- Beta and eta rules for function extensionality\n  funext-Î² : (h : ((x : A) â†’ f x == g x)) â†’ happly (funext h) == h\n  funext-Î² h = lrmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-Î· : (p : f == g) â†’ funext (happly p) == p\n  funext-Î· p = rlmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\nopen FunExt public\n\\end{code}\n\n- Function extensionality in the transport case\n\n\\begin{code}\nmodule FunExt-Transport\n  {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢} {A B : X â†’ Type â„“â±¼} {x y : X} where\n\\end{code}\n\n\\begin{code}\n  funext-transport\n    : (p : x == y) â†’ (f : A x â†’ B x) â†’ (g : A y â†’ B y)\n    ------------------------------------------------------------\n    â†’ ((p âœ¶) f == g) â‰ƒ ((a : A(x)) â†’ (p âœ¶) (f a) == g ((p âœ¶) a))\n\n  funext-transport idp f g = eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-transport-l\n    : (p : x == y)\n    â†’ (f : A x â†’ B x)\n    â†’ (g : A y â†’ B y)\n    â†’ ((p âœ¶) f == g)\n    -------------------------------------------\n    â†’ ((a : A(x)) â†’ (p âœ¶) (f a) == g ((p âœ¶) a))\n\n  funext-transport-l p f g = lemap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\n  funext-transport-r\n    : (p : x == y)\n    â†’ (f : A x â†’ B x)\n    â†’ (g : A y â†’ B y)\n    â†’ ((a : A(x)) â†’ (p âœ¶) (f a) == g ((p âœ¶) a))\n    -------------------------------------------\n    â†’ ((p âœ¶) f == g)\n\n  funext-transport-r p f g = remap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\nopen FunExt-Transport public\n\\end{code}\n\n\\begin{code}\nmodule FunExt-Transport-DFun\n  {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼}{x y : X}\n  where\n\n  -- Lemma 2.9.7\n  funext-transport-dfun\n    : (p : x == y)\n    â†’ (f : (a : A x) â†’ B x a)\n    â†’ (g : (a : A y) â†’ B y a)\n    ----------------------------------------------------------------------------\n    â†’ ((p âœ¶) f == g)\n      â‰ƒ ((a : A x) â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p âœ¶) a))\n\n  funext-transport-dfun idp f g = eqFunExt\n\n  funext-transport-dfun-l\n    : (p : x == y) â†’ (f : (a : A x) â†’ B x a) â†’ (g : (a : A y) â†’ B y a)\n    â†’ ((p âœ¶) f == g)\n    ---------------------------------------------------------------------------\n    â†’ ((a : A x) â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p âœ¶) a))\n\n  funext-transport-dfun-l p f g = lemap (funext-transport-dfun p _ _)\n\n  funext-transport-dfun-r\n    : (p : x == y)\n    â†’ (f : (a : A x) â†’ B x a)\n    â†’ (g : (a : A y) â†’ B y a)\n    â†’ ((a : A x) â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p âœ¶) a))\n    --------------------------------------------------------------------------\n    â†’ ((p âœ¶) f == g)\n\n  funext-transport-dfun-r p f g = remap (funext-transport-dfun p _ _)\nopen FunExt-Transport-DFun public\n\\end{code}\n\n## Decidable equality\n\nA type has decidable equality if any two of its\nelements are equal or different. This would be a particular\ninstance of the Law of Excluded Middle that holds even if we do not\nassume Excluded Middle.\n\n\\begin{code}\nmodule DecidableEquality {â„“} where\n\n  -- A type has decidable equality if we can prove that any two of its\n  -- elements are equal or different.\n  decEq : (A : Type â„“) â†’ Type â„“\n  decEq A = (a b : A) â†’ (a == b) + Â¬ (a == b)\n\n  -- The product of types with decidable equality is a type with\n  -- decidable equality.\n  decEqProd : {A B : Type â„“} â†’ decEq A â†’ decEq B â†’ decEq (A Ã— B)\n  decEqProd da db (a1 , b1) (a2 , b2) with (da a1 a2) | (db b1 b2)\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inl beq = inl (prodByComponents (aeq , beq))\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inr bnq = inr Î» b â†’ bnq (ap Ï€â‚‚ b)\n  decEqProd da db (a1 , b1) (a2 , b2) | inr anq | u       = inr Î» b â†’ anq (ap Ï€â‚ b)\n\nopen DecidableEquality\n\\end{code}\n\n## Hlevels\n\n### Propositions\n\nPropositions as described on the main text. A type\nis a proposition if we can create a function making any two of its\nelements equal. We create a type of propositions.\n\n\\begin{code}\n\nmodule Propositions where\n\n  -- A type is a mere proposition if any two inhabitants of the type\n  -- are equal\n  isProp : âˆ€ {â„“}  (A : Type â„“) â†’ Type â„“\n  isProp A = ((x y : A) â†’ x == y)\n\n  -- The type of mere propositions\n  hProp : âˆ€ {â„“} â†’ Type (lsuc â„“)\n  hProp {â„“} = Î£ (Type â„“) isProp\n\n\n  -- The dependent function type to proposition types is itself a\n  -- proposition.\n  piProp : âˆ€ {â„“áµ¢ â„“â±¼} â†’ {A : Type â„“áµ¢} â†’ {B : A â†’ Type â„“â±¼}\n         â†’ ((a : A) â†’ isProp (B a)) â†’ isProp ((a : A) â†’ B a)\n  piProp props f g = funext Î» a â†’ props a (f a) (g a)\n\n  -- The product of propositions is itself a proposition.\n  isProp-prod : âˆ€ {â„“áµ¢ â„“â±¼} â†’ {A : Type â„“áµ¢} â†’ {B : Type â„“â±¼}\n              â†’ isProp A â†’ isProp B â†’ isProp (A Ã— B)\n  isProp-prod p q x y = prodByComponents ((p _ _) , (q _ _))\n\nopen Propositions public\n\\end{code}\n\n### Sets\n\nSets are types without any higher dimensional structure, all\nparallel paths are homotopic and the homotopy is given by a\ncontinuous function on the two paths.\n\n\\begin{code}\nmodule Sets where\n\n  -- A type is a \"set\" by definition if any two equalities on the type\n  -- are equal.\n  isSet : âˆ€ {â„“}  (A : Type â„“) â†’ Type â„“\n  isSet A = (x y : A) â†’ isProp (x == y)\n\n  -- The type of sets.\n  hSet : âˆ€ {â„“} â†’ Type (lsuc â„“)\n  hSet {â„“} = Î£ (Type â„“) isSet\n\n  -- Product of sets is a set.\n  isSet-prod : âˆ€ {â„“áµ¢ â„“â±¼}  {A : Type â„“áµ¢} â†’ {B : Type â„“â±¼}\n             â†’ isSet A â†’ isSet B â†’ isSet (A Ã— B)\n  isSet-prod sa sb (a , b) (c , d) p q = begin\n     p\n      ==âŸ¨ inv (prodByCompInverse p) âŸ©\n     prodByComponents (prodComponentwise p)\n      ==âŸ¨ ap prodByComponents (prodByComponents (sa a c _ _ , sb b d _ _)) âŸ©\n     prodByComponents (prodComponentwise q)\n      ==âŸ¨ prodByCompInverse q âŸ©\n     q\n    âˆ\n\nopen Sets public\n\\end{code}\n\n### Lemmas\n\nHigher levels of the homotopical structure, where the\nfirst levels are:\n\n- Contractible types (0)\n- Propositions (1)\n- Sets (2)\n\nThey would correspond to homotopy levels. We only work with\nthese first levels.\n\n\\begin{code}\n\nmodule HLevels where\n\n  -- Propositions are Sets.\n  propIsSet : âˆ€ {â„“} {A : Type â„“} â†’ isProp A â†’ isSet A\n  propIsSet {A = A} f a _ p q = lemma p Â· inv (lemma q)\n    where\n      triang : {y z : A} {p : y == z} â†’ (f a y) Â· p == f a z\n      triang {y}{p = idp} = inv (Â·-runit (f a y))\n\n      lemma : {y z : A} (p : y == z) â†’ p == ! (f a y) Â· (f a z)\n      lemma {y} {z} p =\n        begin\n          p                       ==âŸ¨ ap (_Â· p) (inv (Â·-linv (f a y))) âŸ©\n          ! (f a y) Â· f a y Â· p   ==âŸ¨ Â·-assoc (! (f a y)) (f a y) p âŸ©\n          ! (f a y) Â· (f a y Â· p) ==âŸ¨ ap (! (f a y) Â·_) triang âŸ©\n          ! (f a y) Â· (f a z)\n        âˆ\n\n  -- Contractible types are Propositions.\n  contrIsProp : âˆ€ {â„“}  {A : Type â„“} â†’ isContr A â†’ isProp A\n  contrIsProp (a , p) x y = ! (p x) Â· p y\n\n  -- To be contractible is itself a proposition.\n  isContrIsProp : âˆ€ {â„“}  {A : Type â„“} â†’ isProp (isContr A)\n  isContrIsProp {_} {A} (a , p) (b , q) = Î£-bycomponents (inv (q a) , piProp (AisSet b) _ q)\n    where\n      AisSet : isSet A\n      AisSet = propIsSet (contrIsProp (a , p))\n\nopen HLevels public\n\\end{code}\n\n\nEquivalence of two types is a proposition\nMoreover, equivalences preserve propositions.\n\n\\begin{code}\n\nmodule EquivalenceProp {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n  -- Contractible maps are propositions\n  isContrMapIsProp : (f : A â†’ B) â†’ isProp (isContrMap f)\n  isContrMapIsProp f = piProp Î» a â†’ isContrIsProp\n\n  isEquivIsProp : (f : A â†’ B) â†’ isProp (isEquiv f)\n  isEquivIsProp = isContrMapIsProp\n\n  -- Equality of same-morphism equivalences\n  sameEqv : {Î± Î² : A â‰ƒ B} â†’ Ï€â‚ Î± == Ï€â‚ Î² â†’ Î± == Î²\n  sameEqv {(f , Ïƒ)} {(g , Ï„)} p = Î£-bycomponents (p , (isEquivIsProp g _ Ï„))\n\n  -- Equivalences preserve propositions\n  isProp-â‰ƒ : (A â‰ƒ B) â†’ isProp A â†’ isProp B\n  isProp-â‰ƒ eq prop x y =\n    begin\n      x                       ==âŸ¨ inv (lrmap-inverse eq) âŸ©\n      lemap eq ((remap eq) x) ==âŸ¨ ap (Î» u â†’ lemap eq u) (prop _ _) âŸ©\n      lemap eq ((remap eq) y) ==âŸ¨ lrmap-inverse eq âŸ©\n      y\n    âˆ\n\nopen EquivalenceProp public\n\\end{code}\n\n\n### Half-adjoints\n\nHalf-adjoints are an auxiliary notion that helps us\nto define a suitable notion of equivalence, meaning that it is a\nproposition and that it captures the usual notion of equivalence.\n\n\\begin{code}\nmodule Halfadjoints {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n  -- Half adjoint equivalence.\n  record ishae (f : A â†’ B) : Type (â„“áµ¢ âŠ” â„“â±¼) where\n    constructor hae\n    field\n      g : B â†’ A\n      Î· : (g âˆ˜ f) âˆ¼ id\n      Îµ : (f âˆ˜ g) âˆ¼ id\n      Ï„ : (a : A) â†’ ap f (Î· a) == Îµ (f a)\n\n  -- Half adjoint equivalences give contractible fibers.\n  ishae-contr : (f : A â†’ B) â†’ ishae f â†’ isContrMap f\n  ishae-contr f (hae g Î· Îµ Ï„) y = ((g y) , (Îµ y)) , contra\n    where\n      lemma : (c c' : fib f y) â†’ Î£ (Ï€â‚ c == Ï€â‚ c') (Î» Î³ â†’ (ap f Î³) Â· Ï€â‚‚ c' == Ï€â‚‚ c) â†’ c == c'\n      lemma c c' (p , q) = Î£-bycomponents (p , lemma2)\n        where\n          lemma2 : transport (Î» z â†’ f z == y) p (Ï€â‚‚ c) == Ï€â‚‚ c'\n          lemma2 =\n            begin\n              transport (Î» z â†’ f z == y) p (Ï€â‚‚ c)\n                ==âŸ¨ transport-eq-fun-l f p (Ï€â‚‚ c) âŸ©\n              inv (ap f p) Â· (Ï€â‚‚ c)\n                ==âŸ¨ ap (inv (ap f p) Â·_) (inv q) âŸ©\n              inv (ap f p) Â· ((ap f p) Â· (Ï€â‚‚ c'))\n                ==âŸ¨ inv (Â·-assoc (inv (ap f p)) (ap f p) (Ï€â‚‚ c')) âŸ©\n              inv (ap f p) Â· (ap f p) Â· (Ï€â‚‚ c')\n                ==âŸ¨ ap (_Â· (Ï€â‚‚ c')) (Â·-linv (ap f p)) âŸ©\n              Ï€â‚‚ c'\n            âˆ\n\n      contra : (x : fib f y) â†’ (g y , Îµ y) == x\n      contra (x , p) = lemma (g y , Îµ y) (x , p) (Î³ , lemma3)\n        where\n          Î³ : g y == x\n          Î³ = inv (ap g p) Â· Î· x\n\n          lemma3 : (ap f Î³ Â· p) == Îµ y\n          lemma3 =\n            begin\n              ap f Î³ Â· p\n                ==âŸ¨ ap (_Â· p) (ap-Â· f (inv (ap g p)) (Î· x)) âŸ©\n              ap f (inv (ap g p)) Â· ap f (Î· x) Â· p\n                ==âŸ¨ Â·-assoc (ap f (inv (ap g p))) _ p âŸ©\n              ap f (inv (ap g p)) Â· (ap f (Î· x) Â· p)\n                ==âŸ¨ ap (_Â· (ap f (Î· x) Â· p)) (ap-inv f (ap g p)) âŸ©\n              inv (ap f (ap g p)) Â· (ap f (Î· x) Â· p)\n                ==âŸ¨ ap (Î» u â†’ inv (ap f (ap g p)) Â· (u Â· p)) (Ï„ x) âŸ©\n              inv (ap f (ap g p)) Â· (Îµ (f x) Â· p)\n                ==âŸ¨ ap (Î» u â†’ inv (ap f (ap g p)) Â· (Îµ (f x) Â· u)) (inv (ap-id p)) âŸ©\n              inv (ap f (ap g p)) Â· (Îµ (f x) Â· ap id p)\n                ==âŸ¨ ap (inv (ap f (ap g p)) Â·_) (h-naturality Îµ p) âŸ©\n              inv (ap f (ap g p)) Â· (ap (f âˆ˜ g) p Â· Îµ y)\n                ==âŸ¨ ap (Î» u â†’ inv u Â· (ap (f âˆ˜ g) p Â· Îµ y)) (ap-comp g f p) âŸ©\n              inv (ap (f âˆ˜ g) p) Â· (ap (f âˆ˜ g) p Â· Îµ y)\n                ==âŸ¨ inv (Â·-assoc (inv (ap (f âˆ˜ g) p)) _ (Îµ y)) âŸ©\n              (inv (ap (f âˆ˜ g) p) Â· ap (f âˆ˜ g) p) Â· Îµ y\n                ==âŸ¨ ap (_Â· Îµ y) (Â·-linv (ap (Î» z â†’ f (g z)) p)) âŸ©\n              Îµ y\n            âˆ\n\n  -- Half-adjointness implies equivalence.\n  ishae-â‰ƒ : {f : A â†’ B} â†’ ishae f â†’ A â‰ƒ B\n  ishae-â‰ƒ ishaef = _ , (ishae-contr _ ishaef)\n\nopen Halfadjoints public\n\\end{code}\n\n### Quasiinverses\n\nTwo functions are quasi-inverses if we can construct a function providing\n`(g âˆ˜ f) x = x` and `(f âˆ˜ g) y = y` for any given `x` and `y`.\n\n\\begin{code}\nmodule Quasiinverses {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n  -- Definitions for quasi-inverses, left-inverses, right-inverses and\n  -- biinverses.\n  qinv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  qinv f = Î£ (B â†’ A) (Î» g â†’ ((f âˆ˜ g) âˆ¼ id) Ã— ((g âˆ˜ f) âˆ¼ id))\n\n  linv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  linv f = Î£ (B â†’ A) (Î» g â†’ (g âˆ˜ f) âˆ¼ id)\n\n  rinv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  rinv f = Î£ (B â†’ A) Î» g â†’ (f âˆ˜ g) âˆ¼ id\n\n  biinv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  biinv f = linv f Ã— rinv f\n\n  qinv-biinv : (f : A â†’ B) â†’ qinv f â†’ biinv f\n  qinv-biinv f (g , (u1 , u2)) = (g , u2) , (g , u1)\n\n  biinv-qinv : (f : A â†’ B) â†’ biinv f â†’ qinv f\n  biinv-qinv f ((h , Î±) , (g , Î²)) = g , (Î² , Î´)\n    where\n      Î³1 : g âˆ¼ ((h âˆ˜ f) âˆ˜ g)\n      Î³1 = rcomp-âˆ¼ g (h-sym (h âˆ˜ f) id Î±)\n\n      Î³2 : ((h âˆ˜ f) âˆ˜ g) âˆ¼ (h âˆ˜ (f âˆ˜ g))\n      Î³2 x = idp\n\n      Î³ : g âˆ¼ h\n      Î³ = Î³1 â— (Î³2 â— (lcomp-âˆ¼ h Î²))\n\n      Î´ : (g âˆ˜ f) âˆ¼ id\n      Î´ = (rcomp-âˆ¼ f Î³) â— Î±\n\n  equiv-biinv : (f : A â†’ B) â†’ isContrMap f â†’ biinv f\n  equiv-biinv f contrf =\n    (remap eq , rlmap-inverse-h eq) , (remap eq , lrmap-inverse-h eq)\n    where\n      eq : A â‰ƒ B\n      eq = f , contrf\n\n  -- Quasiinverses are halfadjoint equivalences.\n  qinv-ishae : {f : A â†’ B} â†’ qinv f â†’ ishae f\n  qinv-ishae {f} (g , (Îµ , Î·)) = record {\n      g = g ;\n      Î· = Î· ;\n      Îµ = Î» b â†’ inv (Îµ (f (g b))) Â· ap f (Î· (g b)) Â· Îµ b ;\n      Ï„ = Ï„\n    }\n    where\n      aux-lemma : (a : A) â†’ ap f (Î· (g (f a))) Â· Îµ (f a) == Îµ (f (g (f a))) Â· ap f (Î· a)\n      aux-lemma a =\n        begin\n          ap f (Î· ((g âˆ˜ f) a)) Â· Îµ (f a)\n            ==âŸ¨ ap (Î» u â†’ ap f u Â· Îµ (f a)) (h-naturality-id Î·) âŸ©\n          ap f (ap (g âˆ˜ f) (Î· a)) Â· Îµ (f a)\n            ==âŸ¨ ap (_Â· Îµ (f a)) (ap-comp (g âˆ˜ f) f (Î· a)) âŸ©\n          ap (f âˆ˜ (g âˆ˜ f)) (Î· a) Â· Îµ (f a)\n            ==âŸ¨ inv (h-naturality (Î» x â†’ Îµ (f x)) (Î· a)) âŸ©\n          Îµ (f (g (f a))) Â· ap f (Î· a)\n        âˆ\n\n      Ï„ : (a : A) â†’ ap f (Î· a) == (inv (Îµ (f (g (f a)))) Â· ap f (Î· (g (f a))) Â· Îµ (f a))\n      Ï„ a =\n        begin\n          ap f (Î· a)\n            ==âŸ¨ ap (_Â· ap f (Î· a)) (inv (Â·-linv (Îµ (f (g (f a)))))) âŸ©\n          inv (Îµ (f (g (f a)))) Â· Îµ (f (g (f a))) Â· ap f (Î· a)\n            ==âŸ¨ Â·-assoc (inv (Îµ (f (g (f a))))) _ (ap f (Î· a)) âŸ©\n          inv (Îµ (f (g (f a)))) Â· (Îµ (f (g (f a))) Â· ap f (Î· a))\n            ==âŸ¨ ap (inv (Îµ (f (g (f a)))) Â·_) (inv (aux-lemma a)) âŸ©\n          inv (Îµ (f (g (f a)))) Â· (ap f (Î· (g (f a))) Â· Îµ (f a))\n            ==âŸ¨ inv (Â·-assoc (inv (Îµ (f (g (f a))))) _ (Îµ (f a))) âŸ©\n          inv (Îµ (f (g (f a)))) Â· ap f (Î· (g (f a))) Â· Îµ (f a)\n        âˆ\n\n  -- Quasiinverses create equivalences.\n  qinv-â‰ƒ : (f : A â†’ B) â†’ qinv f â†’ A â‰ƒ B\n  qinv-â‰ƒ f = ishae-â‰ƒ âˆ˜ qinv-ishae\n\n  â‰ƒ-qinv : A â‰ƒ B â†’ Î£ (A â†’ B) qinv\n  â‰ƒ-qinv eq =\n    lemap eq , (remap eq , (lrmap-inverse-h eq , rlmap-inverse-h eq))\n\n  -- Half-adjoint equivalences are quasiinverses.\n  ishae-qinv : {f : A â†’ B} â†’ ishae f â†’ qinv f\n  ishae-qinv {f} (hae g Î· Îµ Ï„) = g , (Îµ , Î·)\n\n  â‰ƒ-ishae : (e : A â‰ƒ B)â†’ ishae (lemap e)\n  â‰ƒ-ishae e = qinv-ishae (Ï€â‚‚ (â‰ƒ-qinv e))\n\nopen Quasiinverses public\n\\end{code}\n\n## Equivalence composition\n\nComposition of equivalences and properties of that composition.\n\n\\begin{code}\nmodule EquivalenceComposition where\n\n  -- Composition of quasiinverses\n  qinv-comp : âˆ€ {â„“} {A B C : Type â„“} â†’ Î£ (A â†’ B) qinv â†’ Î£ (B â†’ C) qinv â†’ Î£ (A â†’ C) qinv\n  qinv-comp (f , (if , (Îµf , Î·f))) (g , (ig , (Îµg , Î·g))) = (g âˆ˜ f) , ((if âˆ˜ ig) ,\n     ( (Î» x â†’ ap g (Îµf (ig x)) Â· Îµg x)\n     ,  Î» x â†’ ap if (Î·g (f x)) Â· Î·f x))\n\n  qinv-inv : âˆ€ {â„“} {A B : Type â„“} â†’ Î£ (A â†’ B) qinv â†’ Î£ (B â†’ A) qinv\n  qinv-inv (f , (g , (Îµ , Î·))) = g , (f , (Î· , Îµ))\n\n  -- Composition of equivalences\n  idEqv : âˆ€ {â„“} {A : Type â„“} â†’ A â‰ƒ A\n  idEqv = id , Î» a â†’ (a , refl a) , Î» { (_ , idp) â†’ refl (a , refl a) }\n\\end{code}\n\n\\begin{code}\n--\n  compEqv\n    : âˆ€ {â„“} {A B C : Type â„“}\n    â†’ A â‰ƒ B\n    â†’ B â‰ƒ C\n    -------\n    â†’ A â‰ƒ C\n\n  compEqv {A = A} {C = C} eq-f eq-g = qinv-â‰ƒ (Ï€â‚ qcomp) (Ï€â‚‚ qcomp)\n   where\n     qcomp : Î£ (A â†’ C) qinv\n     qcomp = qinv-comp (â‰ƒ-qinv eq-f) (â‰ƒ-qinv eq-g)\n\n  -- synonym:\n  â‰ƒ-trans = compEqv\n\\end{code}\n\n\\begin{code}\n  invEqv : âˆ€ {â„“} {A B : Type â„“} â†’ A â‰ƒ B â†’ B â‰ƒ A\n  invEqv {â„“} {A} {B} eq-f = qinv-â‰ƒ (Ï€â‚ qcinv) (Ï€â‚‚ qcinv)\n   where\n     qcinv : Î£ (B â†’ A) qinv\n     qcinv = qinv-inv (â‰ƒ-qinv eq-f)\n\n  -- Lemmas about composition\n  compEqv-inv : âˆ€ {â„“} {A B : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ compEqv Î± (invEqv Î±) == idEqv\n  compEqv-inv {_} {A} {B} Î± = sameEqv (\n   begin\n     Ï€â‚ (compEqv Î± (invEqv Î±)) ==âŸ¨ refl _ âŸ©\n     Ï€â‚ (invEqv Î±) âˆ˜ Ï€â‚ Î±     ==âŸ¨ funext (rlmap-inverse-h Î±) âŸ©\n     id\n   âˆ)\n\nopen EquivalenceComposition public\n\\end{code}\n\n\n## Equivalence reasoning\n\n\\begin{code}\nmodule EquivalenceReasoning where\n\n  infixr 2 _â‰ƒâŸ¨âŸ©_\n  _â‰ƒâŸ¨âŸ©_ : âˆ€ {â„“} (A {B} : Type â„“) â†’ A â‰ƒ B â†’ A â‰ƒ B\n  _ â‰ƒâŸ¨âŸ© e = e\n\n  infixr 2 _â‰ƒâŸ¨_âŸ©_\n  _â‰ƒâŸ¨_âŸ©_ : âˆ€ {â„“} (A : Type â„“) {B C : Type â„“} â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C\n  _ â‰ƒâŸ¨ eâ‚ âŸ© eâ‚‚ = compEqv eâ‚ eâ‚‚\n  --\n  infix  3 _â‰ƒâˆ\n  _â‰ƒâˆ :  âˆ€ {â„“} (A : Type â„“) â†’ A â‰ƒ A\n  _â‰ƒâˆ = Î» A â†’ idEqv {A = A}\n\n  infix  1 beginâ‰ƒ_\n  beginâ‰ƒ_ : âˆ€ {â„“} {A B : Type â„“} â†’ A â‰ƒ B â†’ A â‰ƒ B\n  beginâ‰ƒ_ e = e\n\nopen EquivalenceReasoning public\n\\end{code}\n\n## Equivalence with Sigma type\n\n\\begin{code}\nmodule SigmaEquivalence {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : A â†’ Type â„“â±¼} where\n\n  pair=Equiv : {v w : Î£ A P}\n    â†’ Î£ (Ï€â‚ v == Ï€â‚ w) (Î» p â†’ tr (Î» a â†’ P a) p (Ï€â‚‚ v) == Ï€â‚‚ w) â‰ƒ v == w\n  pair=Equiv = qinv-â‰ƒ Î£-bycomponents (Î£-componentwise , HÎ£â‚ , HÎ£â‚‚)\n    where\n      HÎ£â‚ : Î£-bycomponents âˆ˜ Î£-componentwise âˆ¼ id\n      HÎ£â‚ idp = idp\n\n      HÎ£â‚‚ : Î£-componentwise âˆ˜ Î£-bycomponents âˆ¼ id\n      HÎ£â‚‚ (idp , idp) = idp\n\n  private\n    f : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ ap Ï€â‚ (pair= (Î² , Î³)) == Î± â†’ Î² == Î±\n    f {Î² = idp} {Î³ = idp} idp = idp\n\n    g : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ Î² == Î± â†’ ap Ï€â‚ (pair= (Î² , Î³)) == Î±\n    g {Î² = idp} {Î³ = idp} idp = idp\n\n    f-g : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ f {Î± = Î±}{Î² = Î²}{Î³} âˆ˜ g {Î± = Î±}{Î² = Î²} âˆ¼ id\n    f-g {Î² = idp} {Î³ = idp} idp = idp\n\n    g-f : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ g {Î± = Î±}{Î² = Î²}{Î³} âˆ˜ f {Î± = Î±}{Î² = Î²}{Î³} âˆ¼ id\n    g-f {Î² = idp} {Î³ = idp} idp = idp\n\n  ap-Ï€â‚-pair=Equiv : {aâ‚ aâ‚‚ : A} {câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n    â†’ (Î± : aâ‚ == aâ‚‚)\n    â†’ (Î³ : Î£ (aâ‚ == aâ‚‚) (Î» Î±' â†’ transport P Î±' câ‚ == câ‚‚))\n    â†’ (ap Ï€â‚ (pair= Î³) == Î±) â‰ƒ Ï€â‚ Î³ == Î±\n  ap-Ï€â‚-pair=Equiv {aâ‚ = aâ‚} Î± (Î² , Î³) = qinv-â‰ƒ f (g , f-g , g-f)\n\nopen SigmaEquivalence public\n\\end{code}\n\n## Univalence\n\nVoevodsky's univalence axiom is postulated. It induces\nan equality between any two equivalent types. Some Î² and Î· rules\nare provided.\n\n\\begin{code}\nmodule Univalence where\n\n  -- Voevodsky's Univalence Axiom.\n  module UnivalenceAxiom {â„“} {A B : Type â„“} where\n\n    idtoeqv : A == B â†’ A â‰ƒ B\n    idtoeqv p = qinv-â‰ƒ\n      (transport (Î» X â†’ X) p)\n      (transport (Î» X â†’ X) (inv p) , (coe-inv-l p , coe-inv-r p))\n\n    -- The Univalence axiom induces an equivalence between equalities\n    -- and equivalences.\n    postulate axiomUnivalence : isEquiv idtoeqv\n    eqvUnivalence : (A == B) â‰ƒ (A â‰ƒ B)\n    eqvUnivalence = idtoeqv , axiomUnivalence\n\n    -- Introduction rule for equalities.\n    ua : A â‰ƒ B â†’ A == B\n    ua = remap eqvUnivalence\n\n    -- Computation rules\n    ua-Î² : (eqv : A â‰ƒ B) â†’ idtoeqv (ua eqv) == eqv\n    ua-Î² eqv = lrmap-inverse eqvUnivalence\n\n    ua-Î· : (p : A == B) â†’ ua (idtoeqv p) == p\n    ua-Î· p = rlmap-inverse eqvUnivalence\n  open UnivalenceAxiom public\nopen Univalence public\n\\end{code}\n\n### Univalence lemmas\n\n\\begin{code}\nmodule UnivalenceLemmas {â„“} where\n\\end{code}\n\n- The identity equivalence creates the trivial path.\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-id : {A : Type â„“} â†’ ua idEqv == refl A\n    -- ua-id {A} =\n    --   begin\n    --     ua idEqv              ==âŸ¨ ap ua (sameEqv (refl id)) âŸ©\n    --     ua (idtoeqv (refl A)) ==âŸ¨ ua-Î· (refl A) âŸ©\n    --     refl A\n    --   âˆ\n\n    -- The composition of equivalences is preserved into composition\n    -- of equalities.\n\\end{code}\n-\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-comp : {A B C : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ (Î² : B â‰ƒ C) â†’ ua (compEqv Î± Î²) == ua Î± Â· ua Î²\n    -- ua-comp Î± Î² =\n    --   begin\n    --     ua (compEqv Î± Î²)                               ==âŸ¨ ap (Î» x â†’ ua (compEqv x Î²)) (inv (ua-Î² Î±)) âŸ©\n    --     ua (compEqv (idtoeqv (ua Î±)) Î²)                ==âŸ¨ ap (Î» x â†’ ua (compEqv (idtoeqv (ua Î±)) x))\n    --                                                        (inv (ua-Î² Î²)) âŸ©\n    --     ua (compEqv (idtoeqv (ua Î±)) (idtoeqv (ua Î²))) ==âŸ¨ ap ua lemma âŸ©\n    --     ua (idtoeqv (ua Î± Â· ua Î²))                     ==âŸ¨ ua-Î· (ua Î± Â· ua Î²) âŸ©\n    --     ua Î± Â· ua Î²\n    --   âˆ\n    --   where\n    --     lemma : compEqv (idtoeqv (ua Î±)) (idtoeqv (ua Î²)) == idtoeqv (ua Î± Â· ua Î²)\n    --     lemma = sameEqv (\n    --       begin\n    --         Ï€â‚ (idtoeqv (ua Î²)) âˆ˜ Ï€â‚ (idtoeqv (ua Î±))                 ==âŸ¨ refl _ âŸ©\n    --         (transport (Î» x â†’ x) (ua Î²)) âˆ˜ (transport (Î» x â†’ x) (ua Î±)) ==âŸ¨ transport-comp (ua Î±) (ua Î²) âŸ©\n    --         transport (Î» x â†’ x) (ua Î± Â· ua Î²)                           ==âŸ¨ refl _ âŸ©\n    --         Ï€â‚ (idtoeqv (ua Î± Â· ua Î²))\n    --       âˆ)\n\\end{code}\n\n- Inverses are preserved\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv-r : {A B : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ ua Î± Â· ua (invEqv Î±) == refl A\n    -- ua-inv-r Î± =\n    --   begin\n    --     ua Î± Â· ua (invEqv Î±)      ==âŸ¨ inv (ua-comp Î± (invEqv Î±)) âŸ©\n    --     ua (compEqv Î± (invEqv Î±)) ==âŸ¨ ap ua (compEqv-inv Î±) âŸ©\n    --     ua idEqv                  ==âŸ¨ ua-id âŸ©\n    --     refl _\n    --   âˆ\n\\end{code}\n\n- Missing description\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv : {A B : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ ua (invEqv Î±) == inv (ua Î±)\n    -- ua-inv Î± =\n    --   begin\n    --     ua (invEqv Î±)                       ==âŸ¨ ap (_Â· ua (invEqv Î±)) (inv (Â·-linv (ua Î±))) âŸ©\n    --     inv (ua Î±) Â· ua Î± Â· ua (invEqv Î±)   ==âŸ¨ Â·-assoc (inv (ua Î±)) _ _ âŸ©\n    --     inv (ua Î±) Â· (ua Î± Â· ua (invEqv Î±)) ==âŸ¨ ap (inv (ua Î±) Â·_) (ua-inv-r Î±) âŸ©\n    --     inv (ua Î±) Â· refl _                 ==âŸ¨ inv (Â·-runit (inv ((ua Î±)))) âŸ©\n    --     inv (ua Î±)\n    --   âˆ\nopen UnivalenceLemmas public\n\\end{code}\n\n### Transport and Univalence\n\n\\begin{code}\nmodule TransportUA where\n\n  transport-family-ap\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (u : B x)\n    ---------------------------------------------------\n    â†’ transport B p u == transport (Î» X â†’ X) (ap B p) u\n  transport-family-ap B idp u = idp\n\n  transport-family-idtoeqv\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (u : B x)\n    ---------------------------------------------------\n    â†’ transport B p u == funâ‰ƒ (idtoeqv (ap B p)) u\n  transport-family-idtoeqv B idp u = idp\n\n  transport-ua\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (e : B x â‰ƒ B y)\n    â†’ ap B p == ua e\n    -----------------\n    â†’ (u : B x) â†’ transport B p u == (funâ‰ƒ e) u\n  transport-ua B idp e q u =\n    begin\n      transport B idp u\n        ==âŸ¨ transport-family-idtoeqv B idp u âŸ©\n      funâ‰ƒ (idtoeqv (ap B idp)) u\n        ==âŸ¨ ap (Î» r â†’ funâ‰ƒ (idtoeqv r) u) q âŸ©\n      funâ‰ƒ (idtoeqv (ua e)) u\n        ==âŸ¨ ap (Î» r â†’ funâ‰ƒ r u) (ua-Î² e) âŸ©\n      funâ‰ƒ e u\n    âˆ\n\n\n  funext-transport-ua\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (e : B x â‰ƒ B y)\n    â†’ ap B p == ua e\n    -----------------\n    â†’ transport B p == (funâ‰ƒ e)\n  funext-transport-ua B p e xâ‚ = funext (transport-ua B p e xâ‚)\nopen TransportUA public\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem\n  : âˆ€ {â„“áµ¢ â„“â±¼}{X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (g : (a : A y) â†’ B y a)\n  â†’ (a : A y)\n  ------------------------------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a == g a\n  â‰ƒ  tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , transport-inv p)) (f (((! p) âœ¶) a)) == g a\n\nfunext-transport-dfun-bezem idp f g a = idEqv\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-l\n  : âˆ€ {â„“áµ¢ â„“â±¼}{X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (g : (a : A y) â†’ B y a)\n  â†’ (a : A y)\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a == g a\n  ------------------------------------------------------------------------------------\n  â†’  tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , transport-inv p)) (f (((! p) âœ¶) a)) == g a\n\nfunext-transport-dfun-bezem-l p f g a xâ‚ = lemap (funext-transport-dfun-bezem p f g a) xâ‚\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-r\n  : âˆ€ {â„“áµ¢ â„“â±¼}{X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (g : (a : A y) â†’ B y a)\n  â†’ (a : A y)\n  â†’  tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , transport-inv p)) (f (((! p) âœ¶) a)) == g a\n  ------------------------------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a == g a\n\nfunext-transport-dfun-bezem-r p f g a xâ‚ = remap (funext-transport-dfun-bezem p f g a) xâ‚\n\\end{code}\n\n## Truncation\n\n\\begin{code}\nmodule Truncation where\n\n  private\n    -- Higher inductive type, defined with equalities between any two\n    -- members.\n    data !âˆ¥_âˆ¥ {â„“} (A : Type â„“) : Type â„“ where\n      !âˆ£_âˆ£ : A â†’ !âˆ¥ A âˆ¥\n\n  âˆ¥_âˆ¥ : âˆ€ {â„“} (A : Type â„“) â†’ Type â„“\n  âˆ¥ A âˆ¥ = !âˆ¥ A âˆ¥\n\n  âˆ£_âˆ£ : âˆ€ {â„“} {X : Type â„“} â†’ X â†’ âˆ¥ X âˆ¥\n  âˆ£ x âˆ£ = !âˆ£ x âˆ£\n\n  -- Any two elements of the truncated type are equal\n  postulate trunc : âˆ€ {â„“} {A : Type â„“} â†’ isProp âˆ¥ A âˆ¥\n\n  -- Recursion principle\n  trunc-rec : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : Type â„“â±¼}\n            â†’ isProp P\n            â†’ (A â†’ P)\n            ---------\n            â†’ âˆ¥ A âˆ¥ â†’ P\n  trunc-rec _ f !âˆ£ x âˆ£ = f x\n\\end{code}\n\n## Set truncation\n\nAn analogous form of truncation for Sets instead of\nPropositions. It truncates any higher-dimensional homothopical\nstructure.\n\n\\begin{code}\nmodule SetTruncation where\n\n  private\n    -- Higher inductive type\n    data !âˆ¥_âˆ¥â‚€ {â„“} (A : Type â„“) : Type â„“ where\n      !âˆ£_âˆ£â‚€ : A â†’ !âˆ¥ A âˆ¥â‚€\n\n  âˆ¥_âˆ¥â‚€ : âˆ€ {â„“} (A : Type â„“) â†’ Type â„“\n  âˆ¥ A âˆ¥â‚€ = !âˆ¥ A âˆ¥â‚€\n\n  âˆ£_âˆ£â‚€ : âˆ€ {â„“} {X : Type â„“} â†’ X â†’ âˆ¥ X âˆ¥â‚€\n  âˆ£ x âˆ£â‚€ = !âˆ£ x âˆ£â‚€\n\n  -- Any two equalities on the truncated type are equal\n  postulate strunc : âˆ€ {â„“} {A : Type â„“} â†’ isSet âˆ¥ A âˆ¥â‚€\n\n  -- Recursion principle\n  strunc-rec : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : Type â„“â±¼} â†’ isSet P â†’ (A â†’ P) â†’ âˆ¥ A âˆ¥â‚€ â†’ P\n  strunc-rec _ f !âˆ£ x âˆ£â‚€ = f x\n\n  -- Induction principle\n  strunc-ind : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : âˆ¥ A âˆ¥â‚€ â†’ Type â„“â±¼} â†’ ((a : âˆ¥ A âˆ¥â‚€) â†’ isSet (B a))\n             â†’ (g : (a : A) â†’ B âˆ£ a âˆ£â‚€) â†’ (a : âˆ¥ A âˆ¥â‚€) â†’ B a\n  strunc-ind _ g !âˆ£ x âˆ£â‚€ = g x\n\\end{code}\n\n## Quotients\n\n\\begin{code}\nmodule Quotients where\n\n  record QRel {â„“} (A : Type â„“) : Type (lsuc â„“) where\n    field\n      R : A â†’ A â†’ Type â„“\n      Aset : isSet A\n      Rprop : (a b : A) â†’ isProp (R a b)\n  open QRel  public\n\n  private\n    -- Higher inductive type\n    data _!/_ {â„“} (A : Type â„“) (r : QRel A) : Type (lsuc â„“) where\n      ![_] : A â†’ (A !/ r)\n\n  _/_ : âˆ€ {â„“} (A : Type â„“) (r : QRel A) â†’ Type (lsuc â„“)\n  A / r = (A !/ r)\n\n  [_] : âˆ€ {â„“} {A : Type â„“} â†’ A â†’ {r : QRel A} â†’ (A / r)\n  [ a ] = ![ a ]\n\n  -- Equalities induced by the relation\n  postulate Req : âˆ€ {â„“} {A : Type â„“} {r : QRel A}\n                 â†’ {a b : A} â†’ R  a b â†’ [ a ] {r} == [ b ]\n\n  -- The quotient of a set is again a set\n  postulate Rtrunc : âˆ€ {â„“} {A : Type â„“} {r : QRel A} â†’ isSet (A / r)\n\n  -- Recursion principle\n  QRel-rec : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {r : QRel A} {B : Type â„“â±¼}\n            â†’ (f : A â†’ B) â†’ ((x y : A) â†’ R  x y â†’ f x == f y) â†’ A / r â†’ B\n  QRel-rec f p ![ x ] = f x\n\n  -- Induction principle\n  QRel-ind : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {r : QRel A} {B : A / r â†’ Type â„“â±¼}\n            â†’ (f : ((a : A) â†’ B [ a ]))\n            â†’ ((x y : A) â†’ (o : R  x y) â†’ (transport B (Req o) (f x)) == f y)\n            â†’ (z : A / r) â†’ B z\n  QRel-ind f p ![ x ] = f x\n\n  -- Recursion in two arguments\n  QRel-rec-bi : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {r : QRel A} {B : Type â„“â±¼}\n              â†’ (f : A â†’ A â†’ B) â†’ ((x y z t : A) â†’ R  x y â†’ R  z t â†’ f x z == f y t)\n              â†’ A / r â†’ A / r â†’ B\n  QRel-rec-bi f p ![ x ] ![ y ] = f x y\n\n\n  Qrel-prod : âˆ€ {â„“áµ¢}{A : Type â„“áµ¢} (r : QRel A) â†’ QRel (A Ã— A)\n  Qrel-prod r = record { R = Î» { (a , b) (c , d) â†’ (R  a c) Ã— (R  b d) }\n                       ; Aset = isSet-prod (Aset ) (Aset )\n                       ; Rprop = Î» { (x , y) (z , w) â†’ isProp-prod (Rprop  x z) (Rprop  y w)} }\n\\end{code}\n\n## Relation\n\n\\begin{code}\nmodule Relation where\n\n  record Rel {â„“} (A : Type â„“) : Type (lsuc â„“) where\n    field\n      R     : A â†’ A â†’ Type â„“\n      Rprop : (a b : A) â†’ isProp (R a b)\n  open Rel  public\n\nopen Relation public\n\\end{code}\n\n\n## Hedberg\n\n\\begin{code}\nmodule Hedberg {â„“} where\n\n  module HedbergLemmas (A : Type â„“) where\n\n    -- A set is a type satisfiying axiom K.\n    axiomKisSet : ((a : A) â†’ (p : a == a) â†’ p == refl a) â†’ isSet A\n    axiomKisSet k x _ p idp = k x p\n\n    -- Lemma: a reflexive relation on X implying the identity proves\n    -- that X is a set.\n    reflRelIsSet :  (r : Rel A) â†’\n      ((x y : A) â†’ R  x y â†’ x == y) â†’\n      (Ï : (a : A) â†’ R  a a) â†’\n      isSet A\n    reflRelIsSet r f Ï x .x p idp = lemma p\n      where\n        lemma2 : {a : A} (p : a == a) â†’ (o : R  a a) â†’\n          transport (Î» x â†’ a == x) p (f a a o) == f a a (transport (R  a) p o)\n        lemma2 {a} p = funext-transport-l p (f a a) (f a a) (apd (f a) p)\n\n        lemma3 : {a : A} (p : a == a) â†’\n          (f a a (Ï a)) Â· p == (f a a (Ï a))\n        lemma3 {a} p = inv (transport-concat-r p _) Â· lemma2 p (Ï a) Â·\n                       ap (f a a) (Rprop  a a _ (Ï a))\n\n        lemma : {a : A} (p : a == a) â†’ p == refl a\n        lemma {a} p = Â·-cancellation ((f a a (Ï a))) p (lemma3 p)\n\n    -- Lemma: if a type is decidable, then Â¬Â¬A is actually A.\n    lemDoubleNeg : (A + Â¬ A) â†’ (Â¬ (Â¬ A) â†’ A)\n    lemDoubleNeg (inl x) _ = x\n    lemDoubleNeg (inr f) n = exfalso (n f)\n\n  open HedbergLemmas public\n\n  -- Hedberg's theorem. A type with decidable equality is a set.\n  hedberg : {A : Type â„“} â†’ ((a b : A) â†’ (a == b) + Â¬ (a == b)) â†’ isSet A\n  hedberg {A} f = reflRelIsSet A\n                (record { R = Î» a b â†’ Â¬ (Â¬ (a == b)) ; Rprop = isPropNeg })\n                doubleNegEq (Î» a z â†’ z (refl a))\n    where\n      doubleNegEq : (a b : A) â†’ Â¬ (Â¬ (a == b)) â†’ (a == b)\n      doubleNegEq a b = lemDoubleNeg (a == b) (f a b)\n\n      isPropNeg : (a b : A) â†’ isProp (Â¬ (Â¬ (a == b)))\n      isPropNeg a b x y = funext Î» u â†’ exfalso (x u)\n\nopen Hedberg public\n\\end{code}\n\n\n## Algebra\n\n### Monoid\n\nDefinition of the algebraic structure of a monoid.\n\n\\begin{code}\nmodule Monoids {â„“} where\n\n  record Monoid : Type (lsuc â„“) where\n    field\n      -- Operations of a monoid\n      G : Type â„“\n      GisSet : isSet G\n      _&lt;&gt;_ : G â†’ G â†’ G  -- Multiplication function\n      e : G             -- Unit element\n\n      -- Axioms of a monoid\n      lunit : (x : G) â†’ (e &lt;&gt; x) == x\n      runit : (x : G) â†’ (x &lt;&gt; e) == x\n      assoc : (x y z : G) â†’ (x &lt;&gt; (y &lt;&gt; z)) == ((x &lt;&gt; y) &lt;&gt; z)\nopen Monoids\n\\end{code}\n\n### Groups\n\n\\begin{code}\nmodule Groups where\n  record GroupStructure {â„“} (M : Type â„“) : Type â„“ where\n    constructor group-structure\n    field\n      -- A group is a monoid\n      _*_   : M â†’ M â†’ M\n      e     : M\n      lunit : âˆ€ x â†’ (e * x) == x\n      runit : âˆ€ x â†’ (x * e) == x\n      assoc : âˆ€ x y z â†’ (x * (y * z)) == ((x * y) * z)\n\n      -- With inverses\n      ginv : M â†’ M\n      glinv : âˆ€ g â†’ (g * ginv g) == e\n      grinv : âˆ€ g â†’ (ginv g * g) == e\n\n  record Group {â„“} : Type (lsuc â„“) where\n    constructor group\n    field\n      M : Type â„“\n      str : GroupStructure M\n  open Group  public\nopen Groups\n\\end{code}\n\n### Naturals\n\n\\begin{code}\nmodule Naturals where\n\n  -- Addition of natural numbers\n  plus : â„• â†’ â„• â†’ â„•\n  plus zero y = y\n  plus (succ x) y = succ (plus x y)\n\n  infixl 60 _+â‚™_\n  _+â‚™_ : â„• â†’ â„• â†’ â„•\n  _+â‚™_ = plus\n\n  -- Lemmas about addition\n  plus-lunit : (n : â„•) â†’ zero +â‚™ n == n\n  plus-lunit n = refl n\n\n  plus-runit : (n : â„•) â†’ n +â‚™ zero == n\n  plus-runit zero = refl zero\n  plus-runit (succ n) = ap succ (plus-runit n)\n\n  plus-succ : (n m : â„•) â†’ succ (n +â‚™ m) == (n +â‚™ (succ m))\n  plus-succ zero     m = refl (succ m)\n  plus-succ (succ n) m = ap succ (plus-succ n m)\n\n  plus-succ-rs : (n m o p : â„•) â†’ n +â‚™ m == o +â‚™ p â†’ n +â‚™ (succ m) == o +â‚™ (succ p)\n  plus-succ-rs n m o p Î± = inv (plus-succ n m) Â· ap succ Î± Â· (plus-succ o p)\n\n  -- Commutativity\n  plus-comm : (n m : â„•) â†’ n +â‚™ m == m +â‚™ n\n  plus-comm zero     m = inv (plus-runit m)\n  plus-comm (succ n) m = ap succ (plus-comm n m) Â· plus-succ m n\n\n  -- Associativity\n  plus-assoc : (n m p : â„•) â†’ n +â‚™ (m +â‚™ p) == (n +â‚™ m) +â‚™ p\n  plus-assoc zero     m p = refl (m +â‚™ p)\n  plus-assoc (succ n) m p = ap succ (plus-assoc n m p)\n\n\n  -- Decidable equality\n  -- Encode-decode technique for natural numbers\n  private\n    code : â„• â†’ â„• â†’ Typeâ‚€\n    code 0        0        = âŠ¤\n    code 0        (succ m) = âŠ¥\n    code (succ n) 0        = âŠ¥\n    code (succ n) (succ m) = code n m\n\n  crefl : (n : â„•) â†’ code n n\n  crefl zero     = â˜…\n  crefl (succ n) = crefl n\n\n  private\n    encode : (n m : â„•) â†’ (n == m) â†’ code n m\n    encode n m p = transport (code n) p (crefl n)\n\n    decode : (n m : â„•) â†’ code n m â†’ n == m\n    decode zero zero c = refl zero\n    decode zero (succ m) ()\n    decode (succ n) zero ()\n    decode (succ n) (succ m) c = ap succ (decode n m c)\n\n  zero-not-succ : (n : â„•) â†’ Â¬ (succ n == zero)\n  zero-not-succ n = encode (succ n) 0\n\n  -- The successor function is injective\n  succ-inj : {n m : â„•} â†’ (succ n == succ m) â†’ n == m\n  succ-inj {n} {m} p = decode n m (encode (succ n) (succ m) p)\n\n  +-inj : (k : â„•) {n m : â„•} â†’ (k +â‚™ n == k +â‚™ m) â†’ n == m\n  +-inj zero   p = p\n  +-inj (succ k) p = +-inj k (succ-inj p)\n\n  nat-decEq : decEq â„•\n  nat-decEq zero zero = inl (refl zero)\n  nat-decEq zero (succ m) = inr (Î» ())\n  nat-decEq (succ n) zero = inr (Î» ())\n  nat-decEq (succ n) (succ m) with (nat-decEq n m)\n  nat-decEq (succ n) (succ m) | inl p = inl (ap succ p)\n  nat-decEq (succ n) (succ m) | inr f = inr Î» p â†’ f (succ-inj p)\n\n  nat-isSet : isSet â„•\n  nat-isSet = hedberg nat-decEq\n\n  -- Naturals form a monoid with addition\n  â„•-plus-monoid : Monoid\n  â„•-plus-monoid = record\n    { G = â„•\n    ; GisSet = nat-isSet\n    ; _&lt;&gt;_ = plus\n    ; e = zero\n    ; lunit = plus-lunit\n    ; runit = plus-runit\n    ; assoc = plus-assoc\n    }\n\n  -- Ordering\n  _</p>",
  "content": "## Introduction\n\nThis is a basic overview of homotopy type theory (HoTT) formalized in Agda. It's\nonly one file and has been type-checked by Agda 2.5.4. No other libraries are\nrequired to type-check this file.\n\n{: .only-website }\n\n  **URL link**: [https://tinyurl.com/mini-hott](https://tinyurl.com/mini-hott).\n\nTo be consistent with homotopy type theory, we tell Agda to not use Axiom K for\ntype-checking by using the option `without-K`. Without Axiom K, Agda's `Set` is\nnot a good name for universes in HoTT and we rename `Set` to `Type`.\n\nThis code is working in progress and it's for my own learning purposes.\nPlease check out the references at the end of this article.\n\n\\begin{code}\n{-# OPTIONS --without-K #-}\n\nopen import Agda.Primitive using ( Level ; lsuc; lzero; _âŠ”_ ) public\n\nType : (â„“ : Level) â†’ Set (lsuc â„“)\nType â„“ = Set â„“\n\nTypeâ‚€ : Type (lsuc lzero)\nTypeâ‚€ = Type lzero\n\\end{code}\n\n## Basic types\n\n### Empty type\n\nThe Empty type, representing falsehood.\n\n\\begin{code}\n-- A datatype without constructors is the empty type.\ndata âŠ¥ {â„“áµ¢} : Type â„“áµ¢ where\n\n-- synonyms of âŠ¥\nEmpty = âŠ¥\nğŸ˜     = âŠ¥\n\\end{code}\n\nIts eliminator:\n\n\\begin{code}\n-- Ex falso quodlibet\nexfalso\n  : âˆ€ {â„“ â„“áµ¢} {A : Type â„“} â†’ âŠ¥ {â„“áµ¢} â†’ A\n\nexfalso ()\n\n-- synonyms of exfalso\nEmpty-elim = exfalso\nâŠ¥-elim     = exfalso\n\\end{code}\n\nA useful convention\n\\begin{code}\n-- Negation\nÂ¬\n  : âˆ€ {â„“} â†’ Type â„“ â†’ Type â„“\n\nÂ¬ A = (A â†’ âŠ¥ {lzero})\n\\end{code}\n\n### Unit type\n\nThe unit type is defined as record so that we also get the Î·-rule\ndefinitionally.\n\nNo elimination rule.\n\\begin{code}\nrecord âŠ¤ : Typeâ‚€ where\n  constructor â˜…\n\n{-# BUILTIN UNIT âŠ¤ #-}\n\n-- synonyms for the data constructor\nunit = â˜…\n\n-- synonyms for the Unit type\nUnit = âŠ¤\nğŸ™    = âŠ¤\n\\end{code}\n\n### Î£-type\n\nSigma types are a particular case of records, but records can be constructed\nusing only sigma types. Note that l âŠ” q is the maximum of two hierarchy levels l\nand q. This way, we define sigma types in full generality, at each universe.\n\n\\begin{code}\ninfixr 60 _,_\nrecord Î£ {â„“áµ¢ â„“â±¼} (A : Type â„“áµ¢)(C : A â†’ Type â„“â±¼) : Type (â„“áµ¢ âŠ” â„“â±¼) where\n  constructor _,_\n  field\n    Ï€â‚ : A\n    Ï€â‚‚ : C Ï€â‚\n\n  -- synonyms for data constructors\n  projâ‚ = Ï€â‚\n  projâ‚‚ = Ï€â‚‚\n  fst   = Ï€â‚\n  snd   = Ï€â‚‚\nopen Î£ public\n\\end{code}\n\n### Î -types\nShorter notation for Î -types.\n\n\\begin{code}\nÎ \n  : âˆ€ {â„“áµ¢ â„“â±¼}\n  â†’ (A : Type â„“áµ¢) (P : A â†’ Type â„“â±¼)\n  --------------------------------\n  â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\nÎ  A P = (x : A) â†’ P x\n\\end{code}\n\n### Product type\n\nProduct type as a particular case of the sigma\n\n\\begin{code}\n_Ã—_\n  : âˆ€ {â„“áµ¢ â„“â±¼}\n  â†’ (A : Type â„“áµ¢) (B : Type â„“â±¼)\n  ----------------------------\n  â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\nA Ã— B = Î£ A (Î» _ â†’ B)\n\\end{code}\n\n### Coproduct\n\nSum types as inductive types\n\n\\begin{code}\ninfixr 80 _+_\ndata _+_ {â„“áµ¢ â„“â±¼} (A : Type â„“áµ¢) (B : Type â„“â±¼) : Type (â„“áµ¢ âŠ” â„“â±¼) where\n  inl : A â†’ A + B\n  inr : B â†’ A + B\n\\end{code}\n\n### Boolean\n\nBoolean type, two constants true and false\n\n\\begin{code}\ndata Bool : Typeâ‚€ where\n  true  : Bool\n  false : Bool\n\\end{code}\n\n*Booleans can be also defined using the coproduct.*\n\n### Natural numbers\n\nNatural numbers are the initial algebra for a constant and a\nsuccessor function. The `BUILTIN` declaration allows us to use\nnatural numbers in Arabic notation.\n\n\\begin{code}\ndata â„• : Typeâ‚€ where\n  zero : â„•\n  succ : â„• â†’ â„•\n\n{-# BUILTIN NATURAL â„• #-}\n\n-- synonyms for natural numbers\nNat = â„•\n\\end{code}\n\n## Functions\n\n### Identity function\n\nThe identity function with implicit type.\n\\begin{code}\nid\n  : âˆ€ {â„“} {A : Type â„“}\n  â†’ A â†’ A\n\nid = Î» x â†’ x\n\\end{code}\n\nThe identity function on a type `A` is `idf A`.\n\n\\begin{code}\nidf\n  : âˆ€ {â„“áµ¢}\n  â†’ (A : Type â„“áµ¢)\n  ---------------\n  â†’ (A â†’ A)\n\nidf A = Î» x â†’ x\n\\end{code}\n\n### Constant function\n\nConstant function at some point `b` is `cst b`\n\n\\begin{code}\ncst\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼}\n  â†’ (b : B)\n  ---------\n  â†’ (A â†’ B)\n\ncst b = Î» _ â†’ b\n\\end{code}\n\n### Composition\n\nA more sophisticated composition function that can handle dependent functions.\n\n\\begin{code}\n_âˆ˜_\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : A â†’ Type â„“â±¼} {C : (a : A) â†’ (B a â†’ Type â„“â‚–)}\n  â†’ (g : {a : A} â†’ Î  (B a) (C a))\n  â†’ (f : Î  A B)\n  -------------------------------\n  â†’ Î  A (Î» a â†’ C a (f a))\n\ng âˆ˜ f = Î» x â†’ g (f x)\ninfixr 80 _âˆ˜_\n\\end{code}\n\nSynonym for composition (diagrammatic version)\n\\begin{code}\n_//_\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : A â†’ Type â„“â±¼} {C : (a : A) â†’ (B a â†’ Type â„“â‚–)}\n  â†’ (f : Î  A B)\n  â†’ (g : {a : A} â†’ Î  (B a) (C a))\n  -------------------------------\n  â†’ Î  A (Î» a â†’ C a (f a))\n\nf // g = g âˆ˜ f\n\\end{code}\n\n### Application\n\n\\begin{code}\ninfixr 0 _$_\n_$_\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : A â†’ Type â„“â±¼}\n  â†’ (âˆ€ x â†’ B x)\n  -------------\n  â†’ (âˆ€ x â†’ B x)\n\nf $ x = f x\n\\end{code}\n\n### Curryfication\n\n\\begin{code}\ncurry\n  : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j} {C : Î£ A B â†’ Type k}\n  â†’ (âˆ€ s â†’ C s)\n  ---------------------\n  â†’ (âˆ€ x y â†’ C (x , y))\n\ncurry f x y = f (x , y)\n\\end{code}\n\n### Uncurryfication\n\n\\begin{code}\nuncurry\n  : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j} {C : âˆ€ x â†’ B x â†’ Type k}\n  â†’ (âˆ€ x y â†’ C x y)\n  -------------------------\n  â†’ (âˆ€ s â†’ C (Ï€â‚ s) (Ï€â‚‚ s))\n\nuncurry f (x , y) = f x y\n\\end{code}\n\n### Instance search\n\n\\begin{code}\n-- how to use it â“\nâŸ¨âŸ©\n  : âˆ€ {i} {A : Type i}  â†’ A\n\nâŸ¨âŸ©  = a\n\\end{code}\n\n## Equality type\n\nIn HoTT, we have a different interpretation of type theory in which the\nset-theoretical notion of *sets* for *types* is replaced by the topological\nnotion of *spaces*. A type judgment like `x : A` means that the point `x`â€Œâ€Œ is\n*in* the topological space `A`â€Œâ€Œ. Furthermore, we include the *Identity type* as\na primary type. The inhabitants of these identity types will not be longer\ninterpreted as *proofs of equalities* but as *paths* in a Path space, an\nIdentity type.\n\n### Homogeneous equality\n\nThe Identity type is defined as an inductive type. Its induction principle is\nthe J-eliminator.\n\n\\begin{code}\ndata _==_ {â„“áµ¢} {A : Type â„“áµ¢} (a : A) : A â†’ Type â„“áµ¢ where\n  idp : a == a\n\ninfix 30 _==_\n{-# BUILTIN EQUALITY _==_ #-}\n\n-- synonyms for identity type\nPath = _==_\n\\end{code}\n\n\\begin{code}\nrefl\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢}\n  â†’ (a : A)\n  ---------\n  â†’ a == a\n\nrefl {â„“áµ¢}{A} a = idp {â„“áµ¢ = â„“áµ¢}{A = A}\n\\end{code}\n\n#### J eliminator\n\nThe elimination principle for the identity type is the path induction. It allows\nus to define an outgoing function from the identity type to a dependent type â€Œâ€Œ\nas we see in the `J` definition below.\n\n*Paulin-Mohring J rule*\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {a : A}\n  â†’ (B : (a' : A) (p : a == a') â†’ Type â„“â±¼)\n  â†’ (d : B a idp)\n  ----------------------------------------\n  â†’ {a' : A} (p : a == a') â†’ B a' p\n\nJ {a = a} B d idp = d\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\nJ'\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {a : A}\n  â†’ (B : (a' : A) (p : a' == a) â†’ Type â„“â±¼)\n  â†’ (d : B a idp)\n  ----------------------------------------\n  â†’ {a' : A} (p : a' == a) â†’ B a' p\n\nJ' {a = a} B d idp = d\n\\end{code}\n\n#### Composition of paths\n\n{: .foldable until=\"6\" }\n\\begin{code}\n_Â·_\n  : âˆ€ {â„“} {A : Type â„“} {x y z : A}\n  â†’ (p : x == y)\n  â†’ (q : y == z)\n  --------------\n  â†’ x == z\n\n_Â·_ idp q = q\n\ninfixl 50 _Â·_\n\\end{code}\n\n![path](/assets/ipe-images/path-concatenation.png){: width=\"60%\" }\n\n#### Inverse of paths\n\n\\begin{code}\ninv\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ a == b\n  --------\n  â†’ b == a\n\ninv idp = idp\n\n-- synonyms for inverse path\ninfixl 60 _â»Â¹\n_â»Â¹ = inv\n\ninfixr 60 !_\n!_  = inv\n\\end{code}\n\n#### Associativity of composition\n\n- Left associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\nâˆ˜-lassoc\n  : âˆ€ {â„“} {A B C D : Type â„“}\n  â†’ (h : C â†’ D) â†’ (g : B â†’ C) â†’ (f : A â†’ B)\n  -----------------------------------------\n  â†’ (h âˆ˜ (g âˆ˜ f)) == ((h âˆ˜ g) âˆ˜ f)\n\nâˆ˜-lassoc h g f = idp {a = (Î» x â†’ h (g (f x)))}\n\\end{code}\n\n- Right associativity\n\n{: .foldable until=\"5\" }\n\\begin{code}\nâˆ˜-rassoc\n  : âˆ€ {â„“} {A B C D : Type â„“}\n  â†’ (h : C â†’ D) â†’ (g : B â†’ C) â†’ (f : A â†’ B)\n  -----------------------------------------\n  â†’ ((h âˆ˜ g) âˆ˜ f) == (h âˆ˜ (g âˆ˜ f))\n\nâˆ˜-rassoc h g f = (âˆ˜-lassoc h g f) â»Â¹\n\\end{code}\n\n### Heterogeneous equality\n\n\\begin{code}\ndata HEq {â„“} (A : Type â„“)\n           : (B : Type â„“)\n           â†’ (Î± : A == B) (a : A) (b : B)\n           â†’ Type â„“ where\n  idp : âˆ€ {a : A} â†’ HEq A A idp a a\n\\end{code}\n\n## Equational reasoning\n\nEquational reasoning is a way to write readable chains of equalities.\n\n\n```agda\n  t : a == e\n  t = a =âŸ¨ p âŸ©\n      b =âŸ¨ q âŸ©\n      c =âŸ¨ r âŸ©\n      d =âŸ¨ s âŸ©\n      e âˆ\n```\n\n\nwhere `p` is a path from `a` to `b`, `q` is a path from `b` to `c`, and so on.\n\n\\begin{code}\nmodule EquationalReasoning {â„“áµ¢} {A : Type â„“áµ¢} where\n\\end{code}\n\nDefinitional equals:\n\n\\begin{code}\n  _==âŸ¨âŸ©_\n    : âˆ€ (x {y} : A)\n    â†’ x == y â†’ x == y\n\n  _ ==âŸ¨âŸ© p = p\n\n  -- synonyms for _==âŸ¨âŸ©\n  _==âŸ¨idpâŸ©_  = _==âŸ¨âŸ©_\n  _==âŸ¨reflâŸ©_ = _==âŸ¨âŸ©_\n\n  infixr 2 _==âŸ¨âŸ©_\n\\end{code}\n\n\\begin{code}\n  -- chain\n  _==âŸ¨_âŸ©_\n    : (x : A) {y z : A}\n    â†’ x == y\n    â†’ y == z\n    â†’ x == z\n\n  _ ==âŸ¨ thm âŸ© q = thm Â· q\n\n  infixr 2 _==âŸ¨_âŸ©_\n\\end{code}\n\n\\begin{code}\n  -- Q.E.D\n  infix 3 _âˆ\n  _âˆ\n    : (x : A)\n    â†’ x == x\n\n  _âˆ = Î» x â†’ idp\n\\end{code}\n\n\\begin{code}\n  -- Begin\n  infix 1 begin_\n  begin_\n    : {x y : A}\n    â†’ x == y\n    â†’ x == y\n\n  begin_ p = p\n\\end{code}\n\n\\begin{code}\nopen EquationalReasoning public\n\\end{code}\n## Actions on paths\n\nFunctions are functors to equalities.  In other words, functions\npreserve equalities.\n\n{: .foldable until=\"6\" }\n\\begin{code}\nap\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼}\n  â†’ (f : A â†’ B) {aâ‚ aâ‚‚ : A}\n  â†’ aâ‚ == aâ‚‚\n  --------------\n  â†’ f aâ‚ == f aâ‚‚\n\nap f idp = idp\n\\end{code}\n\nNow, we can define a convenient syntax sugar for `ap` in\nequational reasoning.\n\n\\begin{code}\ninfixl 40 ap\nsyntax ap f p = p |in-ctx f\n\\end{code}\n\nLet's suppose we have a lemma:\n\n```agda\n  lemma : a == b\n  lemma = _\n```\n\nused in an equational reasoning like:\n\n```agda\n  t : a == e\n  t = f a =âŸ¨ ap f lemma âŸ©\n      f b\n      âˆ\n```\n\n\nThen, we can now put the lemma in front:\n\n```agda\n  t : a == e\n  t = f a =âŸ¨ lemma |in-ctx f âŸ©\n      f b\n      âˆ\n```\n\n\nLastly, we can also define actions on two paths:\n\n{: .foldable until=\"7\" }\n\\begin{code}\napâ‚‚\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {C : Type â„“â‚–}  {bâ‚ bâ‚‚ : B}\n  â†’ (f : A â†’ B â†’ C)\n  â†’ {aâ‚ aâ‚‚ : A} â†’ (aâ‚ == aâ‚‚)\n  â†’ {bâ‚ bâ‚‚ : B} â†’ (bâ‚ == bâ‚‚)\n  --------------------------\n  â†’ f aâ‚ bâ‚  == f aâ‚‚ bâ‚‚\n\napâ‚‚ f idp idp = idp\n\\end{code}\n\n### Lemmas\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-Â·\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {a b c : A}\n  â†’ (f : A â†’ B) â†’ (p : a == b) â†’ (q : b == c)\n  -------------------------------------------\n  â†’ ap f (p Â· q) == ap f p Â· ap f q\n\nap-Â· f idp q = refl (ap f q)\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-inv\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {a b : A}\n  â†’ (f : A â†’ B) â†’ (p : a == b)\n  ----------------------------\n  â†’ ap f (p â»Â¹) == (ap f p) â»Â¹\n\nap-inv f idp = idp\n\n-- synonyms\nap-! = ap-inv\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\nap-comp\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {C : Type â„“â‚–} {a b : A}\n  â†’ (f : A â†’ B)\n  â†’ (g : B â†’ C)\n  â†’ (p : a == b)\n  -------------------------------\n  â†’ ap g (ap f p) == ap (g âˆ˜ f) p\n\nap-comp f g idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-id\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {a b : A}\n  â†’ (p : a == b)\n  --------------\n  â†’ ap id p == p\n\nap-id idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nap-const\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {C : Type â„“â±¼} {a b : A} {c : C}\n  â†’ (p : a == b)\n  -----------------------\n  â†’ ap (Î» _ â†’ c) p == idp\n\nap-const {c = c} idp = refl (refl c)\n\\end{code}\n\n## Properties on the groupoid\n\nSome properties on the groupoid structure of equalities\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-runit\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  --------------\n  â†’ p == p Â· idp\n\nÂ·-runit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-lunit\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  --------------\n  â†’ p == idp Â· p\n\nÂ·-lunit idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-linv\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  ----------------\n  â†’ ! p Â· p == idp\n\nÂ·-linv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-rinv\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  ----------------\n  â†’ p Â· ! p == idp\n\nÂ·-rinv idp = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ninvolution\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ {p : a == b}\n  ---------------\n  â†’ ! (! p) == p\n\ninvolution {p = idp} = idp\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-assoc\n  : âˆ€ {â„“} {A : Type â„“} {a b c d : A}\n  â†’ (p : a == b) â†’ (q : b == c) â†’ (r : c == d)\n  --------------------------------------------\n  â†’ p Â· q Â· r == p Â· (q Â· r)\n\nÂ·-assoc idp q r = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\nÂ·-cancellation\n  : âˆ€ {â„“} {A : Type â„“} {a : A}\n  â†’ (p : a == a) â†’ (q : a == a)\n  â†’ p Â· q == p\n  -----------------------------\n  â†’ q == refl a\n\nÂ·-cancellation {a = a} p q Î± =\n    begin\n      q             ==âŸ¨ ap (_Â· q) (! (Â·-linv p)) âŸ©\n      ! p Â· p Â· q   ==âŸ¨ (Â·-assoc (! p) _ _) âŸ©\n      ! p Â· (p Â· q) ==âŸ¨ (ap (! p Â·_) Î±) âŸ©\n      ! p Â· p       ==âŸ¨ Â·-linv p âŸ©\n      refl a\n    âˆ\n\\end{code}\n\nMoving a term from one side to the other is a common task,\nso let's define some handy functions for that.\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-left-to-right-l\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  â†’ p Â· q == r\n  ------------------\n  â†’     q == ! p Â· r\n\nÂ·-left-to-right-l {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    q\n      ==âŸ¨ Â·-lunit q âŸ©\n    refl b Â· q\n      ==âŸ¨ ap (_Â· q) (! (Â·-linv p)) âŸ©\n    (! p Â· p) Â· q\n      ==âŸ¨ Â·-assoc (! p) p q âŸ©\n    ! p Â· (p Â· q)\n      ==âŸ¨ ap (! p Â·_) Î± âŸ©\n    ! p Â· r\n  âˆ\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-left-to-right-r\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == b} {q : b == c} {r : a == c}\n  â†’ p Â· q == r\n  -------------------\n  â†’      p == r Â· ! q\n\nÂ·-left-to-right-r {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    p\n      ==âŸ¨ Â·-runit p âŸ©\n    p Â· refl b\n      ==âŸ¨ ap (p Â·_) (! (Â·-rinv q)) âŸ©\n    p Â· (q Â· ! q)\n      ==âŸ¨ ! (Â·-assoc p q (! q)) âŸ©\n    (p Â· q) Â· ! q\n      ==âŸ¨ ap (_Â· ! q) Î± âŸ©\n    r Â· ! q\n  âˆ\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-right-to-left-r\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  â†’       p == q Â· r\n  -------------------\n  â†’ p Â· ! r == q\n\nÂ·-right-to-left-r {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    p Â· ! r\n      ==âŸ¨ ap (_Â· ! r) Î± âŸ©\n    (q Â· r) Â· ! r\n      ==âŸ¨ Â·-assoc q r (! r) âŸ©\n    q Â· (r Â· ! r)\n      ==âŸ¨ ap (q Â·_) (Â·-rinv r) âŸ©\n    q Â· refl b\n      ==âŸ¨ ! (Â·-runit q) âŸ©\n    q\n    âˆ\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\nÂ·-right-to-left-l\n  : âˆ€ {â„“} {A : Type â„“} {a b c : A} {p : a == c} {q : a == b} {r : b == c}\n  â†’       p == q Â· r\n  ------------------\n  â†’ ! q Â· p == r\n\nÂ·-right-to-left-l {a = a}{b = b}{c = c} {p} {q} {r} Î± =\n  begin\n    ! q Â· p\n      ==âŸ¨ ap (! q Â·_) Î± âŸ©\n    ! q Â· (q Â· r)\n      ==âŸ¨ ! (Â·-assoc (! q) q r) âŸ©\n    ! q Â· q Â· r\n      ==âŸ¨ ap (_Â· r) (Â·-linv q) âŸ©\n    refl b Â· r\n      ==âŸ¨ ! (Â·-lunit r) âŸ©\n    r\n  âˆ\n\\end{code}\n\nFinally, when we invert a path composition this is what we got.\n\n{: .foldable until=\"6\" }\n\\begin{code}\n!-Â·\n  : âˆ€ {â„“} {A : Type â„“} {a b : A}\n  â†’ (p : a == b)\n  â†’ (q : b == a)\n  --------------------------\n  â†’ ! (p Â· q) == ! q Â· ! p\n\n!-Â· idp q = Â·-runit (! q)\n\\end{code}\n\n## Transport\n\n![path](/assets/ipe-images/transport-fiber-minihott.png){: width=\"60%\" }\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}\n  â†’ (C : A â†’ Type â„“â±¼) {aâ‚ aâ‚‚ : A}\n  â†’ (p : aâ‚ == aâ‚‚)\n  -------------------------------\n  â†’ (C aâ‚ â†’ C aâ‚‚)\n\ntransport C idp = (Î» x â†’ x)\n\\end{code}\n\n\\begin{code}\n-- synonyms\ntr     = transport\ntransp = transport\n\\end{code}\n\nStar notation for transport\n\n{: .foldable until=\"5\" }\n\\begin{code}\n_âœ¶\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {C : A â†’ Type â„“â±¼} {aâ‚ aâ‚‚ : A}\n  â†’ (p : aâ‚ == aâ‚‚)\n  ----------------\n  â†’ (C aâ‚ â†’ C aâ‚‚)\n\n_âœ¶ {â„“áµ¢}{â„“â±¼}{C = C} = transport {â„“áµ¢ = â„“áµ¢} {â„“â±¼ = â„“â±¼} C\n\\end{code}\n\n{: .foldable until=\"5\" }\n\\begin{code}\ncoe\n  : âˆ€ {â„“} {A B : Type â„“}\n  â†’ A == B\n  ---------\n  â†’ (A â†’ B)\n\ncoe p A = transport (Î» X â†’ X) p A\n\\end{code}\n\n### Pathover\n\nLet be `A : Type`, `aâ‚, aâ‚‚ : A`, `C : A â†’ Type`, `câ‚ : C aâ‚` and `câ‚‚ : C aâ‚‚`.\nUsing the same notation from (Univalent Foundations Program, 2013), one of the definitions for the\nPathover type is as the shorthand for the path between the transport along a\npath `Î± : aâ‚ = aâ‚‚` of the point `câ‚ : C aâ‚` and the point `câ‚‚` in the fiber `C\naâ‚‚`. That is, a pathover is a term that inhabit the type `transport C Î± câ‚ = câ‚‚`\nalso denoted by `PathOver C Î± câ‚ câ‚‚`.\n\n![path](/assets/ipe-images/pathover-3-minihott.png){: width=\"60%\" }\n\n\\begin{code}\nPathOver\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}(C : A â†’ Type â„“â±¼) {aâ‚ aâ‚‚ : A}\n  â†’ (Î± : aâ‚ == aâ‚‚) (câ‚ : C aâ‚) (câ‚‚ : C aâ‚‚)\n  ----------------------------------------\n  â†’ Type â„“â±¼\n\nPathOver C Î± câ‚ câ‚‚ = tr C Î± câ‚ == câ‚‚\n\\end{code}\n\n\\begin{code}\ninfix 30 PathOver\nsyntax PathOver B p u v = u == v [ B â†“ p ]\n\\end{code}\n\n### Lemmas\n\nSome lemmas on the transport operation\n\n{: .foldable until=\"6\" }\n\\begin{code}\nlift\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {aâ‚ aâ‚‚ : A} {â„“â±¼} {C : A â†’ Type â„“â±¼}\n  â†’ (u : C aâ‚)\n  â†’ (Î± : aâ‚ == aâ‚‚)\n  -----------------------------\n  â†’ (aâ‚ , u) == (aâ‚‚ , tr C Î± u)\n\nlift {aâ‚ = aâ‚} u idp = refl (aâ‚ , u)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-const\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {aâ‚  aâ‚‚ : A} {â„“â±¼} {B : Type â„“â±¼}\n  â†’ (p : aâ‚ == aâ‚‚)\n  â†’ (b : B)\n  -----------------------\n  â†’ tr (Î» _ â†’ B) p b == b\n\ntransport-const idp b = refl b\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-r\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {a : A} {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : a == x)\n  ---------------------------------\n  â†’  tr (Î» x â†’ a == x) p q == q Â· p\n\ntransport-concat-r idp q = Â·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat-l\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {a : A} {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : x == a)\n  ----------------------------------\n  â†’ tr (Î» x â†’ x == a) p q == ! p Â· q\n\ntransport-concat-l idp q = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-concat\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : x == x)\n  ---------------------------------------\n  â†’ tr (Î» x â†’ x == x) p q == ! p Â· q Â· p\n\ntransport-concat idp q = Â·-runit q\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {â„“â±¼} {B : Type â„“â±¼}\n  â†’ (f g : A â†’ B) {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : f x == g x)\n  --------------------------------------------------------\n  â†’ tr (Î» z â†’ f z == g z) p q == ! (ap f p) Â· q Â· (ap g p)\n\ntransport-eq-fun f g idp q = Â·-runit q\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-comp\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢}{â„“â±¼} {a b c : A} {P : A â†’ Type â„“â±¼}\n  â†’ (p : a == b)\n  â†’ (q : b == c)\n  ---------------------------------------\n  â†’ ((tr P q) âˆ˜ (tr P p)) == tr P (p Â· q)\n\ntransport-comp {P = P} idp q = refl (transport P q)\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-comp-h\n  : âˆ€ {â„“áµ¢} {A : Type â„“áµ¢} {â„“â±¼} {a b c : A} {P : A â†’ Type â„“â±¼}\n  â†’ (p : a == b)\n  â†’ (q : b == c)\n  â†’ (x : P a)\n  -------------------------------------------\n  â†’ ((tr P q) âˆ˜ (tr P p)) x == tr P (p Â· q) x\n\ntransport-comp-h {P = P} idp q x = refl (transport P q x)\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-eq-fun-l\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {b : B} (f : A â†’ B) {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : f x == b)\n  -------------------------------------------\n  â†’ tr (Î» z â†’ f z == b) p q == ! (ap f p) Â· q\n\ntransport-eq-fun-l {b = b} f p q =\n  begin\n    transport (Î» z â†’ f z == b) p q   ==âŸ¨ transport-eq-fun f (Î» _ â†’ b) p q âŸ©\n    ! (ap f p) Â· q Â· ap (Î» _ â†’ b) p  ==âŸ¨ ap (! (ap f p) Â· q Â·_) (ap-const p) âŸ©\n    ! (ap f p) Â· q Â· idp             ==âŸ¨ ! (Â·-runit _) âŸ©\n    ! (ap f p) Â· q\n  âˆ\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-eq-fun-r\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} {b : B}\n  â†’ (g : A â†’ B) {x y : A}\n  â†’ (p : x == y)\n  â†’ (q : b == g x)\n  ------------------------------------------------\n  â†’ tr (Î» z â†’ b == g z) p q == q Â· (ap g p)\n\ntransport-eq-fun-r {b = b} g p q =\n  begin\n    transport (Î» z â†’ b == g z) p q    ==âŸ¨ transport-eq-fun (Î» _ â†’ b) g p q âŸ©\n    ! (ap (Î» _ â†’ b) p) Â· q Â· ap g p   ==âŸ¨ Â·-assoc (! (ap (Î» _ â†’ b) p)) q (ap g p) âŸ©\n    ! (ap (Î» _ â†’ b) p) Â· (q Â· ap g p) ==âŸ¨ ap (Î» u â†’ ! u Â· (q Â· ap g p)) (ap-const p) âŸ©\n    (q Â· ap g p)\n  âˆ\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-inv\n  : âˆ€ {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{x y : X}\n  â†’ (p : x == y)\n  â†’ {a : A y}\n  --------------------------------------\n  â†’ tr (Î» v â†’ A v) p (tr A (! p) a) == a\n\ntransport-inv {A = A}  idp {a = a} =\n  begin\n    tr (Î» v â†’ A v) idp (tr A (! idp) a)\n      ==âŸ¨ idp âŸ©\n    tr A (! idp Â· idp) a\n      ==âŸ¨âŸ©\n    tr A idp a\n      ==âŸ¨ idp âŸ©\n    a\n  âˆ\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-l\n  : âˆ€ {â„“} {A B : Type â„“}\n  â†’ (p : A == B)\n  â†’ (b : B)\n  --------------------------------------------\n  â†’ tr (Î» v â†’ v) p (tr (Î» v â†’ v) (! p) b) == b\n\ncoe-inv-l idp b = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ncoe-inv-r\n  : âˆ€ {â„“} {A B : Type â„“}\n  â†’ (p : A == B)\n  â†’ (a : A)\n  -----------------------------------------------------------\n  â†’ tr (Î» v â†’ v) (! p) (tr (Î» v â†’ v) p a) == a\n\ncoe-inv-r idp b = idp\n\\end{code}\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-family\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {P : B â†’ Type â„“â‚–}\n  â†’ {f : A â†’ B} â†’ {x y : A}\n  â†’ (p : x == y)\n  â†’ (u : P (f x))\n  -----------------------------------\n  â†’ tr (P âˆ˜ f) p u == tr P (ap f p) u\n\ntransport-family idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-family-id\n  : âˆ€ {â„“áµ¢ â„“â‚–} {A : Type â„“áµ¢} {P : A â†’ Type â„“â‚–} â†’ {x y : A}\n  â†’ (p : x == y)\n  â†’ (u : P x)\n  ----------------------------------------------\n  â†’ transport (Î» a â†’ P a) p u == transport P p u\n\ntransport-family-id idp u = idp\n\\end{code}\n\n{: .foldable until=\"6\" }\n\\begin{code}\ntransport-fun\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {x y : X} {A : X â†’ Type â„“â±¼} {B : X â†’ Type â„“â‚–}\n  â†’ (p : x == y)\n  â†’ (f : A x â†’ B x)\n  -----------------------------------------------------------------\n  â†’ tr (Î» x â†’ (A x â†’ B x)) p f == (Î» x â†’ tr B p (f (tr A (! p) x)))\n\ntransport-fun idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth = transport-fun\n\\end{code}\n\n![path](/assets/ipe-images/transport-fun.png){: width=\"100%\" }\n\n{: .foldable until=\"7\" }\n\\begin{code}\ntransport-fun-h\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼} {B : X â†’ Type â„“â‚–}\n  â†’ {x y : X}\n  â†’ (p : x == y) â†’ (f : A x â†’ B x)\n  â†’ (b : A y)\n  --------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (A x â†’ B x)) p f) b == tr B p (f (tr A (! p) b))\n\ntransport-fun-h idp f b = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\nback-and-forth-h = transport-fun-h\n\\end{code}\n\nNow, when we transport dependent functions this is what we got:\n\n![path](/assets/ipe-images/transport-fun-dependent.png){: width=\"100%\" }\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent-h\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}\n  â†’ {B : (x : X) â†’ (a : A x) â†’ Type â„“â‚–} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  ---------------------------------------------------------------------\n  â†’ (a' : A y)\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a'\n    == tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent-h idp f a' = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth-h = transport-fun-dependent-h\n\\end{code}\n\n{: .foldable until=\"9\" }\n\\begin{code}\ntransport-fun-dependent\n  : âˆ€ {â„“áµ¢ â„“â±¼ â„“â‚–} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}\n  â†’ {B : (x : X) â†’ (a : A x) â†’ Type â„“â‚–} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  ---------------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f)\n    == Î» (a' : A y)\n      â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (! lift a' (! p)) (f (tr A (! p) a'))\n\ntransport-fun-dependent idp f = idp\n\\end{code}\n\n\\begin{code}\n-- synonyms\ndependent-back-and-forth = transport-fun-dependent\n\\end{code}\n\nAction on PathOvers, this was suggested by Fredrik Nordvall:\n\n{: .foldable until=\"9\"}\n\\begin{code}\napOver\n  : {A A' : Typeâ‚€} {C : A â†’ Typeâ‚€} {C' : A' â†’ Typeâ‚€}  -- types\n  â†’ {a a' : A} {b : C a} {b' : C a'}                  -- points\n  â†’ (f : A â†’ A')\n  â†’ (g : {x : A} â†’ C x â†’ C' (f x))\n  â†’ (p : a == a')\n  â†’ b == b' [ C â†“ p ]\n  --------------------------------\n  â†’ g b == g b' [ C' â†“ ap f p ]\n\napOver f g idp q = ap g q\n\\end{code}\n\n## Basic type lemmas\n\n### Sigma type\n\nOur context:\n\n\\begin{code}\nmodule Sigma {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : A â†’ Type â„“â±¼} where\n\\end{code}\n\nTwo dependent pairs are equal if they are componentwise equal.\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Î£-componentwise\n    : {v w : Î£ A P}\n    â†’ v == w\n    ----------------------------------------------\n    â†’ Î£ (Ï€â‚ v == Ï€â‚ w) (Î» p â†’ (p âœ¶) (Ï€â‚‚ v) == Ï€â‚‚ w)\n\n  Î£-componentwise  idp = (idp , idp)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  Î£-bycomponents\n    : {v w : Î£ A P}\n    â†’ Î£ (Ï€â‚ v == Ï€â‚ w) (Î» p â†’ (p âœ¶) (Ï€â‚‚ v) == Ï€â‚‚ w)\n    -----------------------------------------------\n    â†’ v == w\n\n  Î£-bycomponents (idp , idp) = idp\n\n  -- synonym of Î£-bycomponents\n  pair= = Î£-bycomponents\n\\end{code}\n\nA trivial consequence is the following identification:\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  lift-pair=\n    : âˆ€ {x y : A} {u : P x}\n    â†’ (p : x == y)\n    --------------------------------------------------------\n    â†’ lift {A = A}{C = P} u p == pair= (p , refl (tr P p u))\n\n  lift-pair= idp = idp\n\\end{code}\n\n\\begin{code}\n-- Uniqueness principle property for products\n  uppt : (x : Î£ A P) â†’ (Ï€â‚ x , Ï€â‚‚ x) == x\n  uppt (a , b) = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n-- Lemma.\n  Î£-ap-Ï€â‚\n    : {aâ‚ aâ‚‚ : A} {bâ‚ : P aâ‚} {bâ‚‚ : P aâ‚‚}\n    â†’ (Î± : aâ‚ == aâ‚‚)\n    â†’ (Î³ : transport P Î± bâ‚ == bâ‚‚)\n    ------------------------------\n    â†’ ap Ï€â‚ (pair= (Î± , Î³)) == Î±\n\n  Î£-ap-Ï€â‚ idp idp = idp\n\n  -- synonym for this lemma\n  ap-Ï€â‚-pair= = Î£-ap-Ï€â‚\n\\end{code}\n\n\\begin{code}\nopen Sigma public\n\\end{code}\n\n{: .foldable until=\"10\"}\n\\begin{code}\ntransport-fun-dependent-bezem\n  : âˆ€ {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}\n      {B : (x : X) â†’ (a : A x) â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (a' : A y)\n  ----------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a'\n    == tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w))\n          (pair= (p , transport-inv p )) (f (tr A (! p) a'))\n\ntransport-fun-dependent-bezem idp f a' = idp\n\\end{code}\n\n### Cartesian product\n\n\\begin{code}\nmodule CartesianProduct {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodComponentwise\n    : {x y : A Ã— B}\n    â†’ (x == y)\n    ---------------------------------\n    â†’ (Ï€â‚ x == Ï€â‚ y) Ã— (Ï€â‚‚ x == Ï€â‚‚ y)\n\n  prodComponentwise {x = x} idp = refl (Ï€â‚ x) , refl (Ï€â‚‚ x)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByComponents\n    : {x y : A Ã— B}\n    â†’ (Ï€â‚ x == Ï€â‚ y) Ã— (Ï€â‚‚ x == Ï€â‚‚ y)\n    ---------------------------------\n    â†’ (x == y)\n\n  prodByComponents {x = a , b} (idp , idp) = refl (a , b)\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodCompInverse\n    : {x y : A Ã— B}\n    â†’ (b : (Ï€â‚ x == Ï€â‚ y) Ã— (Ï€â‚‚ x == Ï€â‚‚ y))\n    ---------------------------------------------\n    â†’ prodComponentwise (prodByComponents b) == b\n\n  prodCompInverse {x} (idp , idp) = refl (refl (Ï€â‚ x) , refl (Ï€â‚‚ x))\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  prodByCompInverse\n    : {x y : A Ã— B}\n    â†’ (b : x == y)\n    ---------------------------------------------\n    â†’ prodByComponents (prodComponentwise b) == b\n\n  prodByCompInverse {x = x} idp = refl (refl x)\n\\end{code}\n\n\\begin{code}\nopen CartesianProduct\n\\end{code}\n\n## Action on dependent paths\n\n{: .foldable until=\"5\"}\n\\begin{code}\napd\n  : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}  {P : A â†’ Type â„“â±¼} {a b : A}\n  â†’ (f : (a : A) â†’ P a) â†’ (p : a == b)\n  ------------------------------------\n  â†’ transport P p (f a) == f b\n\napd f idp = idp\n\\end{code}\n\n## Homotopy\n\n> In a type-theoretical sense, a homotopy between two\n> functions is a family of equalities between their applications.\n\nThe context:\n\\begin{code}\nmodule Homotopy {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : A â†’ Type â„“â±¼} where\n\\end{code}\n\nLet $$f , g : \\prod\\limits_{(x:A)} P(x)$$ be two sections of a\ntype family $$P : A \\to \\mathcal{U}$$. A **homotopy** from $$f$$ to $$g$$\nis a dependent function of type\n\n{: .equation }\n  $$ (f \\sim g) :\\equiv \\prod\\limits_{x : A} (f(x) = g(x)). $$\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Lemma.\n  homotopy\n    : (f g : Î  A P)\n    ---------------\n    â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\n  homotopy f g = âˆ€ (x : A) â†’ f x == g x\n\\end{code}\n\n\\begin{code}\n  -- Usual notation for homotopy\n  _âˆ¼_ : (f g : ((x : A) â†’ P x)) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  f âˆ¼ g = homotopy f g\n\\end{code}\n\n{: .foldable until=\"5\"}\n\\begin{code}\n  -- Homotopy is an equivalence relation\n  h-refl\n    : (f : Î  A P)\n    -------------\n    â†’ f âˆ¼ f\n\n  h-refl f x = idp\n\\end{code}\n\n{: .foldable until=\"6\"}\n\\begin{code}\n  -- Lemma.\n  h-sym\n    : (f g : Î  A P)\n    â†’ f âˆ¼ g\n    -------\n    â†’ g âˆ¼ f\n\n  h-sym _ _ e x = ! (e x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-comp\n    : {f g h : Î  A P}\n    â†’ f âˆ¼ g\n    â†’ g âˆ¼ h\n    -------\n    â†’ f âˆ¼ h\n\n  h-comp u v x = (u x) Â· (v x)\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- synonym for h-comp\n  _â—_\n    : {f g h : Î  A P}\n    â†’ f âˆ¼ g\n    â†’ g âˆ¼ h\n    -------\n    â†’ f âˆ¼ h\n\n  Î± â— Î² = h-comp Î± Î²\n\\end{code}\n\n\\begin{code}\nopen Homotopy public\n\\end{code}\n\n### Composition with homotopies\n\n\\begin{code}\nmodule HomotopyComposition {â„“áµ¢ â„“â±¼ â„“â‚–} {A : Type â„“áµ¢} {B : Type â„“â±¼} {C : Type â„“â‚–} where\n\\end{code}\n\n{: .foldable until=\"8\"}\n\\begin{code}\n  -- Lemma.\n  hl-comp\n    : {f g : A â†’ B}\n    â†’ {j k : B â†’ C}\n    â†’ f âˆ¼ g\n    â†’ j âˆ¼ k\n    -------------------\n    â†’ (j âˆ˜ f) âˆ¼ (k âˆ˜ g)\n\n  hl-comp {g = g}{j = j} f-g j-k = Î» x â†’ ap j (f-g x) Â· j-k (g x)\n\\end{code}\n\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  rcomp-âˆ¼\n    : (f : A â†’ B)\n    â†’ {j k : B â†’ C}\n    â†’ j âˆ¼ k\n    -------------------\n    â†’ (j âˆ˜ f) âˆ¼ (k âˆ˜ f)\n\n  rcomp-âˆ¼ f j-k = hl-comp (h-refl f) j-k\n\\end{code}\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  lcomp-âˆ¼\n    : {f g : A â†’ B}\n    â†’ (j : B â†’ C)\n    â†’ f âˆ¼ g\n    -------------------\n    â†’ (j âˆ˜ f) âˆ¼ (j âˆ˜ g)\n\n  lcomp-âˆ¼ j Î± = hl-comp Î± (h-refl j)\n\\end{code}\n\n\\begin{code}\nopen HomotopyComposition\n\\end{code}\n\n### Naturality\n\n\\begin{code}\nmodule Naturality {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\\end{code}\n\nHomotopy is natural, meaning that it satisfies the following\nsquare commutative diagram.\n\n![path](/assets/ipe-images/h-naturality.png){: width=\"40%\" }\n\n{: .foldable until=\"7\"}\n\\begin{code}\n  -- Lemma.\n  h-naturality\n    : {f g : A â†’ B} â†’ {x y : A}\n    â†’ (H : f âˆ¼ g)\n    â†’ (p : x == y)\n    ------------------------------\n    â†’ H x Â· ap g p == ap f p Â· H y\n\n  h-naturality {x = x} H idp = ! (Â·-runit (H x))\nopen Naturality\n\\end{code}\n\nA particular case of naturality on the identity function.\n\n{: .foldable until=\"5\"}\n\\begin{code}\nh-naturality-id\n  : âˆ€ {â„“} {A : Type â„“} {f : A â†’ A} â†’ {x : A}\n  â†’ (H : f âˆ¼ id)\n  -----------------------\n  â†’ H (f x) == ap f (H x)\n\nh-naturality-id {f = f} {x = x} H =\n  begin\n    H (f x)\n      ==âŸ¨ Â·-runit (H (f x)) âŸ©\n    H (f x) Â· refl (f x)\n      ==âŸ¨ ap (H (f x) Â·_) (! (Â·-rinv (H x))) âŸ©\n    H (f x) Â· ((H x) Â· (! (H x)))\n      ==âŸ¨ ap (H (f x) Â·_) (ap (_Â· (! (H x))) (! ap-id (H x))) âŸ©\n    H (f x) Â· (ap id (H x) Â· ! (H x))\n      ==âŸ¨ ! (Â·-assoc (H (f x)) (ap id (H x)) (! (H x))) âŸ©\n    (H (f x) Â· ap id (H x)) Â· ! (H x)\n      ==âŸ¨ Â·-right-to-left-r (h-naturality H (H x)) âŸ©\n    ap f (H x)\n  âˆ\n\\end{code}\n\n## .... REVIWING .... BELOW\n\n## Fibers\n\nContractible types with a center of contraction.\n\n\\begin{code}\nmodule Fibers {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼}  where\n\n  -- The fiber of a map over a point is given by\n  fib\n    : (f : A â†’ B)\n    â†’ (b : B)\n    ---------------\n    â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n\n  fib f b = Î£ A (Î» a â†’ f a == b)\n\n\n  -- A function applied over the fiber returns the original point\n  fib-eq : {f : A â†’ B} â†’ {b : B} â†’ (h : fib f b) â†’ f (Ï€â‚ h) == b\n  fib-eq (a , Î±) = Î±\n\n  -- Each point is on the fiber of its image\n  fib-image : {f : A â†’ B} â†’ {a : A} â†’ fib f (f a)\n  fib-image {f} {a} = a , refl (f a)\n\nopen Fibers public\n\\end{code}\n\n## Contractible types\n\n\\begin{code}\n-- Contractible.  Contractible types with a center of contraction.\nmodule Contractible where\n\n  -- Contractible types. A contractible type is a type such that every\n  -- element is equal to a center of contraction.\n  isContr : âˆ€ {â„“}  (A : Type â„“) â†’ Type â„“\n  isContr A = Î£ A (Î» a â†’ ((x : A) â†’ a == x))\nopen Contractible public\n\n\\end{code}\n\n## Equivalence\n\n\\begin{code}\nmodule Equivalence where\n\n  module DefinitionOfEquivalence {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n    -- Contractible maps. A map is contractible if the fiber in any\n    -- point is contractible, that is, each element has a unique\n    -- preimage.\n    isContrMap : (f : A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n    isContrMap f = (b : B) â†’ isContr (fib f b)\n\\end{code}\n\n\\begin{code}\n    -- There exists an equivalence between two types if there exists a\n    -- contractible function between them.\n    isEquiv : (f : A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n    isEquiv = isContrMap\n  open DefinitionOfEquivalence public\n\\end{code}\n\n\\begin{code}\n  -- Equivalence of types.\n  _â‰ƒ_ : âˆ€ {â„“áµ¢ â„“â±¼}  (A : Type â„“áµ¢) (B : Type â„“â±¼) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  A â‰ƒ B = Î£ (A â†’ B) isEquiv\n\\end{code}\n\n\\begin{code}\n  module EquivalenceMaps {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n    -- Maps of an equivalence\n    lemap : A â‰ƒ B â†’ (A â†’ B)\n    lemap = Ï€â‚\n\n    â‰ƒ-to-â†’ = lemap\n    funâ‰ƒ   = lemap\n\n    remap : A â‰ƒ B â†’ (B â†’ A)\n    remap (f , contrf) b = Ï€â‚ (Ï€â‚ (contrf b))\n\n    -- The maps of an equivalence are inverses in particular\n    lrmap-inverse : (eq : A â‰ƒ B) â†’ {b : B} â†’ (lemap eq) ((remap eq) b) == b\n    lrmap-inverse (f , eqf) {b} = fib-eq (Ï€â‚ (eqf b))\n\n    rlmap-inverse : (eq : A â‰ƒ B) â†’ {a : A} â†’ (remap eq) ((lemap eq) a) == a\n    rlmap-inverse (f , eqf) {a} = ap Ï€â‚ ((Ï€â‚‚ (eqf (f a))) fib-image)\n\n    lrmap-inverse-h : (eq : A â‰ƒ B) â†’ ((lemap eq) âˆ˜ (remap eq)) âˆ¼ id\n    lrmap-inverse-h eq = Î» x â†’ lrmap-inverse eq {x}\n\n    rlmap-inverse-h : (eq : A â‰ƒ B) â†’ ((remap eq) âˆ˜ (lemap eq)) âˆ¼ id\n    rlmap-inverse-h eq = Î» x â†’ rlmap-inverse eq {x}\n  open EquivalenceMaps public\n\\end{code}\n\n\\begin{code}\nopen Equivalence public\n\\end{code}\n\n## Function extensionality\n\n\\begin{code}\n\nmodule FunExt {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢}\n  {B : A â†’ Type â„“â±¼} {f g : (a : A) â†’ B a} where\n\\end{code}\n\n\\begin{code}\n  -- Application of an homotopy\n  happly : f == g â†’ ((x : A) â†’ f x == g x)\n  happly idp x = refl (f x)\n\\end{code}\n\n\\begin{code}\n  -- The axiom of function extensionality postulates that the\n  -- application of homotopies is an equivalence.\n  postulate axiomFunExt : isEquiv happly\n\\end{code}\n\n\\begin{code}\n  eqFunExt : (f == g) â‰ƒ ((x : A) â†’ f x == g x)\n  eqFunExt = happly , axiomFunExt\n\\end{code}\n\n\\begin{code}\n  -- From this, the usual notion of function extensionality follows.\n  funext : ((x : A) â†’ f x == g x) â†’ f == g\n  funext = remap eqFunExt\n\\end{code}\n\n\\begin{code}\n  -- Beta and eta rules for function extensionality\n  funext-Î² : (h : ((x : A) â†’ f x == g x)) â†’ happly (funext h) == h\n  funext-Î² h = lrmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-Î· : (p : f == g) â†’ funext (happly p) == p\n  funext-Î· p = rlmap-inverse eqFunExt\n\\end{code}\n\n\\begin{code}\nopen FunExt public\n\\end{code}\n\n- Function extensionality in the transport case\n\n\\begin{code}\nmodule FunExt-Transport\n  {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢} {A B : X â†’ Type â„“â±¼} {x y : X} where\n\\end{code}\n\n\\begin{code}\n  funext-transport\n    : (p : x == y) â†’ (f : A x â†’ B x) â†’ (g : A y â†’ B y)\n    ------------------------------------------------------------\n    â†’ ((p âœ¶) f == g) â‰ƒ ((a : A(x)) â†’ (p âœ¶) (f a) == g ((p âœ¶) a))\n\n  funext-transport idp f g = eqFunExt\n\\end{code}\n\n\\begin{code}\n  funext-transport-l\n    : (p : x == y)\n    â†’ (f : A x â†’ B x)\n    â†’ (g : A y â†’ B y)\n    â†’ ((p âœ¶) f == g)\n    -------------------------------------------\n    â†’ ((a : A(x)) â†’ (p âœ¶) (f a) == g ((p âœ¶) a))\n\n  funext-transport-l p f g = lemap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\n  funext-transport-r\n    : (p : x == y)\n    â†’ (f : A x â†’ B x)\n    â†’ (g : A y â†’ B y)\n    â†’ ((a : A(x)) â†’ (p âœ¶) (f a) == g ((p âœ¶) a))\n    -------------------------------------------\n    â†’ ((p âœ¶) f == g)\n\n  funext-transport-r p f g = remap (funext-transport p _ _)\n\\end{code}\n\n\\begin{code}\nopen FunExt-Transport public\n\\end{code}\n\n\\begin{code}\nmodule FunExt-Transport-DFun\n  {â„“áµ¢ â„“â±¼} {X : Type â„“áµ¢} {A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼}{x y : X}\n  where\n\n  -- Lemma 2.9.7\n  funext-transport-dfun\n    : (p : x == y)\n    â†’ (f : (a : A x) â†’ B x a)\n    â†’ (g : (a : A y) â†’ B y a)\n    ----------------------------------------------------------------------------\n    â†’ ((p âœ¶) f == g)\n      â‰ƒ ((a : A x) â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p âœ¶) a))\n\n  funext-transport-dfun idp f g = eqFunExt\n\n  funext-transport-dfun-l\n    : (p : x == y) â†’ (f : (a : A x) â†’ B x a) â†’ (g : (a : A y) â†’ B y a)\n    â†’ ((p âœ¶) f == g)\n    ---------------------------------------------------------------------------\n    â†’ ((a : A x) â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p âœ¶) a))\n\n  funext-transport-dfun-l p f g = lemap (funext-transport-dfun p _ _)\n\n  funext-transport-dfun-r\n    : (p : x == y)\n    â†’ (f : (a : A x) â†’ B x a)\n    â†’ (g : (a : A y) â†’ B y a)\n    â†’ ((a : A x) â†’ tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p âœ¶) a))\n    --------------------------------------------------------------------------\n    â†’ ((p âœ¶) f == g)\n\n  funext-transport-dfun-r p f g = remap (funext-transport-dfun p _ _)\nopen FunExt-Transport-DFun public\n\\end{code}\n\n## Decidable equality\n\nA type has decidable equality if any two of its\nelements are equal or different. This would be a particular\ninstance of the Law of Excluded Middle that holds even if we do not\nassume Excluded Middle.\n\n\\begin{code}\nmodule DecidableEquality {â„“} where\n\n  -- A type has decidable equality if we can prove that any two of its\n  -- elements are equal or different.\n  decEq : (A : Type â„“) â†’ Type â„“\n  decEq A = (a b : A) â†’ (a == b) + Â¬ (a == b)\n\n  -- The product of types with decidable equality is a type with\n  -- decidable equality.\n  decEqProd : {A B : Type â„“} â†’ decEq A â†’ decEq B â†’ decEq (A Ã— B)\n  decEqProd da db (a1 , b1) (a2 , b2) with (da a1 a2) | (db b1 b2)\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inl beq = inl (prodByComponents (aeq , beq))\n  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inr bnq = inr Î» b â†’ bnq (ap Ï€â‚‚ b)\n  decEqProd da db (a1 , b1) (a2 , b2) | inr anq | u       = inr Î» b â†’ anq (ap Ï€â‚ b)\n\nopen DecidableEquality\n\\end{code}\n\n## Hlevels\n\n### Propositions\n\nPropositions as described on the main text. A type\nis a proposition if we can create a function making any two of its\nelements equal. We create a type of propositions.\n\n\\begin{code}\n\nmodule Propositions where\n\n  -- A type is a mere proposition if any two inhabitants of the type\n  -- are equal\n  isProp : âˆ€ {â„“}  (A : Type â„“) â†’ Type â„“\n  isProp A = ((x y : A) â†’ x == y)\n\n  -- The type of mere propositions\n  hProp : âˆ€ {â„“} â†’ Type (lsuc â„“)\n  hProp {â„“} = Î£ (Type â„“) isProp\n\n\n  -- The dependent function type to proposition types is itself a\n  -- proposition.\n  piProp : âˆ€ {â„“áµ¢ â„“â±¼} â†’ {A : Type â„“áµ¢} â†’ {B : A â†’ Type â„“â±¼}\n         â†’ ((a : A) â†’ isProp (B a)) â†’ isProp ((a : A) â†’ B a)\n  piProp props f g = funext Î» a â†’ props a (f a) (g a)\n\n  -- The product of propositions is itself a proposition.\n  isProp-prod : âˆ€ {â„“áµ¢ â„“â±¼} â†’ {A : Type â„“áµ¢} â†’ {B : Type â„“â±¼}\n              â†’ isProp A â†’ isProp B â†’ isProp (A Ã— B)\n  isProp-prod p q x y = prodByComponents ((p _ _) , (q _ _))\n\nopen Propositions public\n\\end{code}\n\n### Sets\n\nSets are types without any higher dimensional structure, all\nparallel paths are homotopic and the homotopy is given by a\ncontinuous function on the two paths.\n\n\\begin{code}\nmodule Sets where\n\n  -- A type is a \"set\" by definition if any two equalities on the type\n  -- are equal.\n  isSet : âˆ€ {â„“}  (A : Type â„“) â†’ Type â„“\n  isSet A = (x y : A) â†’ isProp (x == y)\n\n  -- The type of sets.\n  hSet : âˆ€ {â„“} â†’ Type (lsuc â„“)\n  hSet {â„“} = Î£ (Type â„“) isSet\n\n  -- Product of sets is a set.\n  isSet-prod : âˆ€ {â„“áµ¢ â„“â±¼}  {A : Type â„“áµ¢} â†’ {B : Type â„“â±¼}\n             â†’ isSet A â†’ isSet B â†’ isSet (A Ã— B)\n  isSet-prod sa sb (a , b) (c , d) p q = begin\n     p\n      ==âŸ¨ inv (prodByCompInverse p) âŸ©\n     prodByComponents (prodComponentwise p)\n      ==âŸ¨ ap prodByComponents (prodByComponents (sa a c _ _ , sb b d _ _)) âŸ©\n     prodByComponents (prodComponentwise q)\n      ==âŸ¨ prodByCompInverse q âŸ©\n     q\n    âˆ\n\nopen Sets public\n\\end{code}\n\n### Lemmas\n\nHigher levels of the homotopical structure, where the\nfirst levels are:\n\n- Contractible types (0)\n- Propositions (1)\n- Sets (2)\n\nThey would correspond to homotopy levels. We only work with\nthese first levels.\n\n\\begin{code}\n\nmodule HLevels where\n\n  -- Propositions are Sets.\n  propIsSet : âˆ€ {â„“} {A : Type â„“} â†’ isProp A â†’ isSet A\n  propIsSet {A = A} f a _ p q = lemma p Â· inv (lemma q)\n    where\n      triang : {y z : A} {p : y == z} â†’ (f a y) Â· p == f a z\n      triang {y}{p = idp} = inv (Â·-runit (f a y))\n\n      lemma : {y z : A} (p : y == z) â†’ p == ! (f a y) Â· (f a z)\n      lemma {y} {z} p =\n        begin\n          p                       ==âŸ¨ ap (_Â· p) (inv (Â·-linv (f a y))) âŸ©\n          ! (f a y) Â· f a y Â· p   ==âŸ¨ Â·-assoc (! (f a y)) (f a y) p âŸ©\n          ! (f a y) Â· (f a y Â· p) ==âŸ¨ ap (! (f a y) Â·_) triang âŸ©\n          ! (f a y) Â· (f a z)\n        âˆ\n\n  -- Contractible types are Propositions.\n  contrIsProp : âˆ€ {â„“}  {A : Type â„“} â†’ isContr A â†’ isProp A\n  contrIsProp (a , p) x y = ! (p x) Â· p y\n\n  -- To be contractible is itself a proposition.\n  isContrIsProp : âˆ€ {â„“}  {A : Type â„“} â†’ isProp (isContr A)\n  isContrIsProp {_} {A} (a , p) (b , q) = Î£-bycomponents (inv (q a) , piProp (AisSet b) _ q)\n    where\n      AisSet : isSet A\n      AisSet = propIsSet (contrIsProp (a , p))\n\nopen HLevels public\n\\end{code}\n\n\nEquivalence of two types is a proposition\nMoreover, equivalences preserve propositions.\n\n\\begin{code}\n\nmodule EquivalenceProp {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n  -- Contractible maps are propositions\n  isContrMapIsProp : (f : A â†’ B) â†’ isProp (isContrMap f)\n  isContrMapIsProp f = piProp Î» a â†’ isContrIsProp\n\n  isEquivIsProp : (f : A â†’ B) â†’ isProp (isEquiv f)\n  isEquivIsProp = isContrMapIsProp\n\n  -- Equality of same-morphism equivalences\n  sameEqv : {Î± Î² : A â‰ƒ B} â†’ Ï€â‚ Î± == Ï€â‚ Î² â†’ Î± == Î²\n  sameEqv {(f , Ïƒ)} {(g , Ï„)} p = Î£-bycomponents (p , (isEquivIsProp g _ Ï„))\n\n  -- Equivalences preserve propositions\n  isProp-â‰ƒ : (A â‰ƒ B) â†’ isProp A â†’ isProp B\n  isProp-â‰ƒ eq prop x y =\n    begin\n      x                       ==âŸ¨ inv (lrmap-inverse eq) âŸ©\n      lemap eq ((remap eq) x) ==âŸ¨ ap (Î» u â†’ lemap eq u) (prop _ _) âŸ©\n      lemap eq ((remap eq) y) ==âŸ¨ lrmap-inverse eq âŸ©\n      y\n    âˆ\n\nopen EquivalenceProp public\n\\end{code}\n\n\n### Half-adjoints\n\nHalf-adjoints are an auxiliary notion that helps us\nto define a suitable notion of equivalence, meaning that it is a\nproposition and that it captures the usual notion of equivalence.\n\n\\begin{code}\nmodule Halfadjoints {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n  -- Half adjoint equivalence.\n  record ishae (f : A â†’ B) : Type (â„“áµ¢ âŠ” â„“â±¼) where\n    constructor hae\n    field\n      g : B â†’ A\n      Î· : (g âˆ˜ f) âˆ¼ id\n      Îµ : (f âˆ˜ g) âˆ¼ id\n      Ï„ : (a : A) â†’ ap f (Î· a) == Îµ (f a)\n\n  -- Half adjoint equivalences give contractible fibers.\n  ishae-contr : (f : A â†’ B) â†’ ishae f â†’ isContrMap f\n  ishae-contr f (hae g Î· Îµ Ï„) y = ((g y) , (Îµ y)) , contra\n    where\n      lemma : (c c' : fib f y) â†’ Î£ (Ï€â‚ c == Ï€â‚ c') (Î» Î³ â†’ (ap f Î³) Â· Ï€â‚‚ c' == Ï€â‚‚ c) â†’ c == c'\n      lemma c c' (p , q) = Î£-bycomponents (p , lemma2)\n        where\n          lemma2 : transport (Î» z â†’ f z == y) p (Ï€â‚‚ c) == Ï€â‚‚ c'\n          lemma2 =\n            begin\n              transport (Î» z â†’ f z == y) p (Ï€â‚‚ c)\n                ==âŸ¨ transport-eq-fun-l f p (Ï€â‚‚ c) âŸ©\n              inv (ap f p) Â· (Ï€â‚‚ c)\n                ==âŸ¨ ap (inv (ap f p) Â·_) (inv q) âŸ©\n              inv (ap f p) Â· ((ap f p) Â· (Ï€â‚‚ c'))\n                ==âŸ¨ inv (Â·-assoc (inv (ap f p)) (ap f p) (Ï€â‚‚ c')) âŸ©\n              inv (ap f p) Â· (ap f p) Â· (Ï€â‚‚ c')\n                ==âŸ¨ ap (_Â· (Ï€â‚‚ c')) (Â·-linv (ap f p)) âŸ©\n              Ï€â‚‚ c'\n            âˆ\n\n      contra : (x : fib f y) â†’ (g y , Îµ y) == x\n      contra (x , p) = lemma (g y , Îµ y) (x , p) (Î³ , lemma3)\n        where\n          Î³ : g y == x\n          Î³ = inv (ap g p) Â· Î· x\n\n          lemma3 : (ap f Î³ Â· p) == Îµ y\n          lemma3 =\n            begin\n              ap f Î³ Â· p\n                ==âŸ¨ ap (_Â· p) (ap-Â· f (inv (ap g p)) (Î· x)) âŸ©\n              ap f (inv (ap g p)) Â· ap f (Î· x) Â· p\n                ==âŸ¨ Â·-assoc (ap f (inv (ap g p))) _ p âŸ©\n              ap f (inv (ap g p)) Â· (ap f (Î· x) Â· p)\n                ==âŸ¨ ap (_Â· (ap f (Î· x) Â· p)) (ap-inv f (ap g p)) âŸ©\n              inv (ap f (ap g p)) Â· (ap f (Î· x) Â· p)\n                ==âŸ¨ ap (Î» u â†’ inv (ap f (ap g p)) Â· (u Â· p)) (Ï„ x) âŸ©\n              inv (ap f (ap g p)) Â· (Îµ (f x) Â· p)\n                ==âŸ¨ ap (Î» u â†’ inv (ap f (ap g p)) Â· (Îµ (f x) Â· u)) (inv (ap-id p)) âŸ©\n              inv (ap f (ap g p)) Â· (Îµ (f x) Â· ap id p)\n                ==âŸ¨ ap (inv (ap f (ap g p)) Â·_) (h-naturality Îµ p) âŸ©\n              inv (ap f (ap g p)) Â· (ap (f âˆ˜ g) p Â· Îµ y)\n                ==âŸ¨ ap (Î» u â†’ inv u Â· (ap (f âˆ˜ g) p Â· Îµ y)) (ap-comp g f p) âŸ©\n              inv (ap (f âˆ˜ g) p) Â· (ap (f âˆ˜ g) p Â· Îµ y)\n                ==âŸ¨ inv (Â·-assoc (inv (ap (f âˆ˜ g) p)) _ (Îµ y)) âŸ©\n              (inv (ap (f âˆ˜ g) p) Â· ap (f âˆ˜ g) p) Â· Îµ y\n                ==âŸ¨ ap (_Â· Îµ y) (Â·-linv (ap (Î» z â†’ f (g z)) p)) âŸ©\n              Îµ y\n            âˆ\n\n  -- Half-adjointness implies equivalence.\n  ishae-â‰ƒ : {f : A â†’ B} â†’ ishae f â†’ A â‰ƒ B\n  ishae-â‰ƒ ishaef = _ , (ishae-contr _ ishaef)\n\nopen Halfadjoints public\n\\end{code}\n\n### Quasiinverses\n\nTwo functions are quasi-inverses if we can construct a function providing\n`(g âˆ˜ f) x = x` and `(f âˆ˜ g) y = y` for any given `x` and `y`.\n\n\\begin{code}\nmodule Quasiinverses {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : Type â„“â±¼} where\n\n  -- Definitions for quasi-inverses, left-inverses, right-inverses and\n  -- biinverses.\n  qinv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  qinv f = Î£ (B â†’ A) (Î» g â†’ ((f âˆ˜ g) âˆ¼ id) Ã— ((g âˆ˜ f) âˆ¼ id))\n\n  linv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  linv f = Î£ (B â†’ A) (Î» g â†’ (g âˆ˜ f) âˆ¼ id)\n\n  rinv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  rinv f = Î£ (B â†’ A) Î» g â†’ (f âˆ˜ g) âˆ¼ id\n\n  biinv : (A â†’ B) â†’ Type (â„“áµ¢ âŠ” â„“â±¼)\n  biinv f = linv f Ã— rinv f\n\n  qinv-biinv : (f : A â†’ B) â†’ qinv f â†’ biinv f\n  qinv-biinv f (g , (u1 , u2)) = (g , u2) , (g , u1)\n\n  biinv-qinv : (f : A â†’ B) â†’ biinv f â†’ qinv f\n  biinv-qinv f ((h , Î±) , (g , Î²)) = g , (Î² , Î´)\n    where\n      Î³1 : g âˆ¼ ((h âˆ˜ f) âˆ˜ g)\n      Î³1 = rcomp-âˆ¼ g (h-sym (h âˆ˜ f) id Î±)\n\n      Î³2 : ((h âˆ˜ f) âˆ˜ g) âˆ¼ (h âˆ˜ (f âˆ˜ g))\n      Î³2 x = idp\n\n      Î³ : g âˆ¼ h\n      Î³ = Î³1 â— (Î³2 â— (lcomp-âˆ¼ h Î²))\n\n      Î´ : (g âˆ˜ f) âˆ¼ id\n      Î´ = (rcomp-âˆ¼ f Î³) â— Î±\n\n  equiv-biinv : (f : A â†’ B) â†’ isContrMap f â†’ biinv f\n  equiv-biinv f contrf =\n    (remap eq , rlmap-inverse-h eq) , (remap eq , lrmap-inverse-h eq)\n    where\n      eq : A â‰ƒ B\n      eq = f , contrf\n\n  -- Quasiinverses are halfadjoint equivalences.\n  qinv-ishae : {f : A â†’ B} â†’ qinv f â†’ ishae f\n  qinv-ishae {f} (g , (Îµ , Î·)) = record {\n      g = g ;\n      Î· = Î· ;\n      Îµ = Î» b â†’ inv (Îµ (f (g b))) Â· ap f (Î· (g b)) Â· Îµ b ;\n      Ï„ = Ï„\n    }\n    where\n      aux-lemma : (a : A) â†’ ap f (Î· (g (f a))) Â· Îµ (f a) == Îµ (f (g (f a))) Â· ap f (Î· a)\n      aux-lemma a =\n        begin\n          ap f (Î· ((g âˆ˜ f) a)) Â· Îµ (f a)\n            ==âŸ¨ ap (Î» u â†’ ap f u Â· Îµ (f a)) (h-naturality-id Î·) âŸ©\n          ap f (ap (g âˆ˜ f) (Î· a)) Â· Îµ (f a)\n            ==âŸ¨ ap (_Â· Îµ (f a)) (ap-comp (g âˆ˜ f) f (Î· a)) âŸ©\n          ap (f âˆ˜ (g âˆ˜ f)) (Î· a) Â· Îµ (f a)\n            ==âŸ¨ inv (h-naturality (Î» x â†’ Îµ (f x)) (Î· a)) âŸ©\n          Îµ (f (g (f a))) Â· ap f (Î· a)\n        âˆ\n\n      Ï„ : (a : A) â†’ ap f (Î· a) == (inv (Îµ (f (g (f a)))) Â· ap f (Î· (g (f a))) Â· Îµ (f a))\n      Ï„ a =\n        begin\n          ap f (Î· a)\n            ==âŸ¨ ap (_Â· ap f (Î· a)) (inv (Â·-linv (Îµ (f (g (f a)))))) âŸ©\n          inv (Îµ (f (g (f a)))) Â· Îµ (f (g (f a))) Â· ap f (Î· a)\n            ==âŸ¨ Â·-assoc (inv (Îµ (f (g (f a))))) _ (ap f (Î· a)) âŸ©\n          inv (Îµ (f (g (f a)))) Â· (Îµ (f (g (f a))) Â· ap f (Î· a))\n            ==âŸ¨ ap (inv (Îµ (f (g (f a)))) Â·_) (inv (aux-lemma a)) âŸ©\n          inv (Îµ (f (g (f a)))) Â· (ap f (Î· (g (f a))) Â· Îµ (f a))\n            ==âŸ¨ inv (Â·-assoc (inv (Îµ (f (g (f a))))) _ (Îµ (f a))) âŸ©\n          inv (Îµ (f (g (f a)))) Â· ap f (Î· (g (f a))) Â· Îµ (f a)\n        âˆ\n\n  -- Quasiinverses create equivalences.\n  qinv-â‰ƒ : (f : A â†’ B) â†’ qinv f â†’ A â‰ƒ B\n  qinv-â‰ƒ f = ishae-â‰ƒ âˆ˜ qinv-ishae\n\n  â‰ƒ-qinv : A â‰ƒ B â†’ Î£ (A â†’ B) qinv\n  â‰ƒ-qinv eq =\n    lemap eq , (remap eq , (lrmap-inverse-h eq , rlmap-inverse-h eq))\n\n  -- Half-adjoint equivalences are quasiinverses.\n  ishae-qinv : {f : A â†’ B} â†’ ishae f â†’ qinv f\n  ishae-qinv {f} (hae g Î· Îµ Ï„) = g , (Îµ , Î·)\n\n  â‰ƒ-ishae : (e : A â‰ƒ B)â†’ ishae (lemap e)\n  â‰ƒ-ishae e = qinv-ishae (Ï€â‚‚ (â‰ƒ-qinv e))\n\nopen Quasiinverses public\n\\end{code}\n\n## Equivalence composition\n\nComposition of equivalences and properties of that composition.\n\n\\begin{code}\nmodule EquivalenceComposition where\n\n  -- Composition of quasiinverses\n  qinv-comp : âˆ€ {â„“} {A B C : Type â„“} â†’ Î£ (A â†’ B) qinv â†’ Î£ (B â†’ C) qinv â†’ Î£ (A â†’ C) qinv\n  qinv-comp (f , (if , (Îµf , Î·f))) (g , (ig , (Îµg , Î·g))) = (g âˆ˜ f) , ((if âˆ˜ ig) ,\n     ( (Î» x â†’ ap g (Îµf (ig x)) Â· Îµg x)\n     ,  Î» x â†’ ap if (Î·g (f x)) Â· Î·f x))\n\n  qinv-inv : âˆ€ {â„“} {A B : Type â„“} â†’ Î£ (A â†’ B) qinv â†’ Î£ (B â†’ A) qinv\n  qinv-inv (f , (g , (Îµ , Î·))) = g , (f , (Î· , Îµ))\n\n  -- Composition of equivalences\n  idEqv : âˆ€ {â„“} {A : Type â„“} â†’ A â‰ƒ A\n  idEqv = id , Î» a â†’ (a , refl a) , Î» { (_ , idp) â†’ refl (a , refl a) }\n\\end{code}\n\n\\begin{code}\n--\n  compEqv\n    : âˆ€ {â„“} {A B C : Type â„“}\n    â†’ A â‰ƒ B\n    â†’ B â‰ƒ C\n    -------\n    â†’ A â‰ƒ C\n\n  compEqv {A = A} {C = C} eq-f eq-g = qinv-â‰ƒ (Ï€â‚ qcomp) (Ï€â‚‚ qcomp)\n   where\n     qcomp : Î£ (A â†’ C) qinv\n     qcomp = qinv-comp (â‰ƒ-qinv eq-f) (â‰ƒ-qinv eq-g)\n\n  -- synonym:\n  â‰ƒ-trans = compEqv\n\\end{code}\n\n\\begin{code}\n  invEqv : âˆ€ {â„“} {A B : Type â„“} â†’ A â‰ƒ B â†’ B â‰ƒ A\n  invEqv {â„“} {A} {B} eq-f = qinv-â‰ƒ (Ï€â‚ qcinv) (Ï€â‚‚ qcinv)\n   where\n     qcinv : Î£ (B â†’ A) qinv\n     qcinv = qinv-inv (â‰ƒ-qinv eq-f)\n\n  -- Lemmas about composition\n  compEqv-inv : âˆ€ {â„“} {A B : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ compEqv Î± (invEqv Î±) == idEqv\n  compEqv-inv {_} {A} {B} Î± = sameEqv (\n   begin\n     Ï€â‚ (compEqv Î± (invEqv Î±)) ==âŸ¨ refl _ âŸ©\n     Ï€â‚ (invEqv Î±) âˆ˜ Ï€â‚ Î±     ==âŸ¨ funext (rlmap-inverse-h Î±) âŸ©\n     id\n   âˆ)\n\nopen EquivalenceComposition public\n\\end{code}\n\n\n## Equivalence reasoning\n\n\\begin{code}\nmodule EquivalenceReasoning where\n\n  infixr 2 _â‰ƒâŸ¨âŸ©_\n  _â‰ƒâŸ¨âŸ©_ : âˆ€ {â„“} (A {B} : Type â„“) â†’ A â‰ƒ B â†’ A â‰ƒ B\n  _ â‰ƒâŸ¨âŸ© e = e\n\n  infixr 2 _â‰ƒâŸ¨_âŸ©_\n  _â‰ƒâŸ¨_âŸ©_ : âˆ€ {â„“} (A : Type â„“) {B C : Type â„“} â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C\n  _ â‰ƒâŸ¨ eâ‚ âŸ© eâ‚‚ = compEqv eâ‚ eâ‚‚\n  --\n  infix  3 _â‰ƒâˆ\n  _â‰ƒâˆ :  âˆ€ {â„“} (A : Type â„“) â†’ A â‰ƒ A\n  _â‰ƒâˆ = Î» A â†’ idEqv {A = A}\n\n  infix  1 beginâ‰ƒ_\n  beginâ‰ƒ_ : âˆ€ {â„“} {A B : Type â„“} â†’ A â‰ƒ B â†’ A â‰ƒ B\n  beginâ‰ƒ_ e = e\n\nopen EquivalenceReasoning public\n\\end{code}\n\n## Equivalence with Sigma type\n\n\\begin{code}\nmodule SigmaEquivalence {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : A â†’ Type â„“â±¼} where\n\n  pair=Equiv : {v w : Î£ A P}\n    â†’ Î£ (Ï€â‚ v == Ï€â‚ w) (Î» p â†’ tr (Î» a â†’ P a) p (Ï€â‚‚ v) == Ï€â‚‚ w) â‰ƒ v == w\n  pair=Equiv = qinv-â‰ƒ Î£-bycomponents (Î£-componentwise , HÎ£â‚ , HÎ£â‚‚)\n    where\n      HÎ£â‚ : Î£-bycomponents âˆ˜ Î£-componentwise âˆ¼ id\n      HÎ£â‚ idp = idp\n\n      HÎ£â‚‚ : Î£-componentwise âˆ˜ Î£-bycomponents âˆ¼ id\n      HÎ£â‚‚ (idp , idp) = idp\n\n  private\n    f : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ ap Ï€â‚ (pair= (Î² , Î³)) == Î± â†’ Î² == Î±\n    f {Î² = idp} {Î³ = idp} idp = idp\n\n    g : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ Î² == Î± â†’ ap Ï€â‚ (pair= (Î² , Î³)) == Î±\n    g {Î² = idp} {Î³ = idp} idp = idp\n\n    f-g : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ f {Î± = Î±}{Î² = Î²}{Î³} âˆ˜ g {Î± = Î±}{Î² = Î²} âˆ¼ id\n    f-g {Î² = idp} {Î³ = idp} idp = idp\n\n    g-f : {aâ‚ aâ‚‚ : A} {Î± : aâ‚ == aâ‚‚}{câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n      â†’ {Î² : aâ‚ == aâ‚‚}\n      â†’ {Î³ : transport P Î² câ‚ == câ‚‚}\n      â†’ g {Î± = Î±}{Î² = Î²}{Î³} âˆ˜ f {Î± = Î±}{Î² = Î²}{Î³} âˆ¼ id\n    g-f {Î² = idp} {Î³ = idp} idp = idp\n\n  ap-Ï€â‚-pair=Equiv : {aâ‚ aâ‚‚ : A} {câ‚ : P aâ‚} {câ‚‚ : P aâ‚‚}\n    â†’ (Î± : aâ‚ == aâ‚‚)\n    â†’ (Î³ : Î£ (aâ‚ == aâ‚‚) (Î» Î±' â†’ transport P Î±' câ‚ == câ‚‚))\n    â†’ (ap Ï€â‚ (pair= Î³) == Î±) â‰ƒ Ï€â‚ Î³ == Î±\n  ap-Ï€â‚-pair=Equiv {aâ‚ = aâ‚} Î± (Î² , Î³) = qinv-â‰ƒ f (g , f-g , g-f)\n\nopen SigmaEquivalence public\n\\end{code}\n\n## Univalence\n\nVoevodsky's univalence axiom is postulated. It induces\nan equality between any two equivalent types. Some Î² and Î· rules\nare provided.\n\n\\begin{code}\nmodule Univalence where\n\n  -- Voevodsky's Univalence Axiom.\n  module UnivalenceAxiom {â„“} {A B : Type â„“} where\n\n    idtoeqv : A == B â†’ A â‰ƒ B\n    idtoeqv p = qinv-â‰ƒ\n      (transport (Î» X â†’ X) p)\n      (transport (Î» X â†’ X) (inv p) , (coe-inv-l p , coe-inv-r p))\n\n    -- The Univalence axiom induces an equivalence between equalities\n    -- and equivalences.\n    postulate axiomUnivalence : isEquiv idtoeqv\n    eqvUnivalence : (A == B) â‰ƒ (A â‰ƒ B)\n    eqvUnivalence = idtoeqv , axiomUnivalence\n\n    -- Introduction rule for equalities.\n    ua : A â‰ƒ B â†’ A == B\n    ua = remap eqvUnivalence\n\n    -- Computation rules\n    ua-Î² : (eqv : A â‰ƒ B) â†’ idtoeqv (ua eqv) == eqv\n    ua-Î² eqv = lrmap-inverse eqvUnivalence\n\n    ua-Î· : (p : A == B) â†’ ua (idtoeqv p) == p\n    ua-Î· p = rlmap-inverse eqvUnivalence\n  open UnivalenceAxiom public\nopen Univalence public\n\\end{code}\n\n### Univalence lemmas\n\n\\begin{code}\nmodule UnivalenceLemmas {â„“} where\n\\end{code}\n\n- The identity equivalence creates the trivial path.\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-id : {A : Type â„“} â†’ ua idEqv == refl A\n    -- ua-id {A} =\n    --   begin\n    --     ua idEqv              ==âŸ¨ ap ua (sameEqv (refl id)) âŸ©\n    --     ua (idtoeqv (refl A)) ==âŸ¨ ua-Î· (refl A) âŸ©\n    --     refl A\n    --   âˆ\n\n    -- The composition of equivalences is preserved into composition\n    -- of equalities.\n\\end{code}\n-\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-comp : {A B C : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ (Î² : B â‰ƒ C) â†’ ua (compEqv Î± Î²) == ua Î± Â· ua Î²\n    -- ua-comp Î± Î² =\n    --   begin\n    --     ua (compEqv Î± Î²)                               ==âŸ¨ ap (Î» x â†’ ua (compEqv x Î²)) (inv (ua-Î² Î±)) âŸ©\n    --     ua (compEqv (idtoeqv (ua Î±)) Î²)                ==âŸ¨ ap (Î» x â†’ ua (compEqv (idtoeqv (ua Î±)) x))\n    --                                                        (inv (ua-Î² Î²)) âŸ©\n    --     ua (compEqv (idtoeqv (ua Î±)) (idtoeqv (ua Î²))) ==âŸ¨ ap ua lemma âŸ©\n    --     ua (idtoeqv (ua Î± Â· ua Î²))                     ==âŸ¨ ua-Î· (ua Î± Â· ua Î²) âŸ©\n    --     ua Î± Â· ua Î²\n    --   âˆ\n    --   where\n    --     lemma : compEqv (idtoeqv (ua Î±)) (idtoeqv (ua Î²)) == idtoeqv (ua Î± Â· ua Î²)\n    --     lemma = sameEqv (\n    --       begin\n    --         Ï€â‚ (idtoeqv (ua Î²)) âˆ˜ Ï€â‚ (idtoeqv (ua Î±))                 ==âŸ¨ refl _ âŸ©\n    --         (transport (Î» x â†’ x) (ua Î²)) âˆ˜ (transport (Î» x â†’ x) (ua Î±)) ==âŸ¨ transport-comp (ua Î±) (ua Î²) âŸ©\n    --         transport (Î» x â†’ x) (ua Î± Â· ua Î²)                           ==âŸ¨ refl _ âŸ©\n    --         Ï€â‚ (idtoeqv (ua Î± Â· ua Î²))\n    --       âˆ)\n\\end{code}\n\n- Inverses are preserved\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv-r : {A B : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ ua Î± Â· ua (invEqv Î±) == refl A\n    -- ua-inv-r Î± =\n    --   begin\n    --     ua Î± Â· ua (invEqv Î±)      ==âŸ¨ inv (ua-comp Î± (invEqv Î±)) âŸ©\n    --     ua (compEqv Î± (invEqv Î±)) ==âŸ¨ ap ua (compEqv-inv Î±) âŸ©\n    --     ua idEqv                  ==âŸ¨ ua-id âŸ©\n    --     refl _\n    --   âˆ\n\\end{code}\n\n- Missing description\n{: .foldable}\n\\begin{code}\n  postulate\n    ua-inv : {A B : Type â„“} â†’ (Î± : A â‰ƒ B) â†’ ua (invEqv Î±) == inv (ua Î±)\n    -- ua-inv Î± =\n    --   begin\n    --     ua (invEqv Î±)                       ==âŸ¨ ap (_Â· ua (invEqv Î±)) (inv (Â·-linv (ua Î±))) âŸ©\n    --     inv (ua Î±) Â· ua Î± Â· ua (invEqv Î±)   ==âŸ¨ Â·-assoc (inv (ua Î±)) _ _ âŸ©\n    --     inv (ua Î±) Â· (ua Î± Â· ua (invEqv Î±)) ==âŸ¨ ap (inv (ua Î±) Â·_) (ua-inv-r Î±) âŸ©\n    --     inv (ua Î±) Â· refl _                 ==âŸ¨ inv (Â·-runit (inv ((ua Î±)))) âŸ©\n    --     inv (ua Î±)\n    --   âˆ\nopen UnivalenceLemmas public\n\\end{code}\n\n### Transport and Univalence\n\n\\begin{code}\nmodule TransportUA where\n\n  transport-family-ap\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (u : B x)\n    ---------------------------------------------------\n    â†’ transport B p u == transport (Î» X â†’ X) (ap B p) u\n  transport-family-ap B idp u = idp\n\n  transport-family-idtoeqv\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (u : B x)\n    ---------------------------------------------------\n    â†’ transport B p u == funâ‰ƒ (idtoeqv (ap B p)) u\n  transport-family-idtoeqv B idp u = idp\n\n  transport-ua\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (e : B x â‰ƒ B y)\n    â†’ ap B p == ua e\n    -----------------\n    â†’ (u : B x) â†’ transport B p u == (funâ‰ƒ e) u\n  transport-ua B idp e q u =\n    begin\n      transport B idp u\n        ==âŸ¨ transport-family-idtoeqv B idp u âŸ©\n      funâ‰ƒ (idtoeqv (ap B idp)) u\n        ==âŸ¨ ap (Î» r â†’ funâ‰ƒ (idtoeqv r) u) q âŸ©\n      funâ‰ƒ (idtoeqv (ua e)) u\n        ==âŸ¨ ap (Î» r â†’ funâ‰ƒ r u) (ua-Î² e) âŸ©\n      funâ‰ƒ e u\n    âˆ\n\n\n  funext-transport-ua\n    : âˆ€ {â„“} {A : Type â„“}\n    â†’ (B : A â†’ Type â„“)\n    â†’ {x y : A}\n    â†’ (p : x == y)\n    â†’ (e : B x â‰ƒ B y)\n    â†’ ap B p == ua e\n    -----------------\n    â†’ transport B p == (funâ‰ƒ e)\n  funext-transport-ua B p e xâ‚ = funext (transport-ua B p e xâ‚)\nopen TransportUA public\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem\n  : âˆ€ {â„“áµ¢ â„“â±¼}{X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (g : (a : A y) â†’ B y a)\n  â†’ (a : A y)\n  ------------------------------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a == g a\n  â‰ƒ  tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , transport-inv p)) (f (((! p) âœ¶) a)) == g a\n\nfunext-transport-dfun-bezem idp f g a = idEqv\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-l\n  : âˆ€ {â„“áµ¢ â„“â±¼}{X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (g : (a : A y) â†’ B y a)\n  â†’ (a : A y)\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a == g a\n  ------------------------------------------------------------------------------------\n  â†’  tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , transport-inv p)) (f (((! p) âœ¶) a)) == g a\n\nfunext-transport-dfun-bezem-l p f g a xâ‚ = lemap (funext-transport-dfun-bezem p f g a) xâ‚\n\\end{code}\n\n\\begin{code}\nfunext-transport-dfun-bezem-r\n  : âˆ€ {â„“áµ¢ â„“â±¼}{X : Type â„“áµ¢}{A : X â†’ Type â„“â±¼}{B : (x : X) â†’ A x â†’ Type â„“â±¼} {x y : X}\n  â†’ (p : x == y)\n  â†’ (f : (a : A x) â†’ B x a)\n  â†’ (g : (a : A y) â†’ B y a)\n  â†’ (a : A y)\n  â†’  tr (Î» w â†’ B (Ï€â‚ w) (Ï€â‚‚ w)) (pair= (p , transport-inv p)) (f (((! p) âœ¶) a)) == g a\n  ------------------------------------------------------------------------------------\n  â†’ (tr (Î» x â†’ (a : A x) â†’ B x a) p f) a == g a\n\nfunext-transport-dfun-bezem-r p f g a xâ‚ = remap (funext-transport-dfun-bezem p f g a) xâ‚\n\\end{code}\n\n## Truncation\n\n\\begin{code}\nmodule Truncation where\n\n  private\n    -- Higher inductive type, defined with equalities between any two\n    -- members.\n    data !âˆ¥_âˆ¥ {â„“} (A : Type â„“) : Type â„“ where\n      !âˆ£_âˆ£ : A â†’ !âˆ¥ A âˆ¥\n\n  âˆ¥_âˆ¥ : âˆ€ {â„“} (A : Type â„“) â†’ Type â„“\n  âˆ¥ A âˆ¥ = !âˆ¥ A âˆ¥\n\n  âˆ£_âˆ£ : âˆ€ {â„“} {X : Type â„“} â†’ X â†’ âˆ¥ X âˆ¥\n  âˆ£ x âˆ£ = !âˆ£ x âˆ£\n\n  -- Any two elements of the truncated type are equal\n  postulate trunc : âˆ€ {â„“} {A : Type â„“} â†’ isProp âˆ¥ A âˆ¥\n\n  -- Recursion principle\n  trunc-rec : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : Type â„“â±¼}\n            â†’ isProp P\n            â†’ (A â†’ P)\n            ---------\n            â†’ âˆ¥ A âˆ¥ â†’ P\n  trunc-rec _ f !âˆ£ x âˆ£ = f x\n\\end{code}\n\n## Set truncation\n\nAn analogous form of truncation for Sets instead of\nPropositions. It truncates any higher-dimensional homothopical\nstructure.\n\n\\begin{code}\nmodule SetTruncation where\n\n  private\n    -- Higher inductive type\n    data !âˆ¥_âˆ¥â‚€ {â„“} (A : Type â„“) : Type â„“ where\n      !âˆ£_âˆ£â‚€ : A â†’ !âˆ¥ A âˆ¥â‚€\n\n  âˆ¥_âˆ¥â‚€ : âˆ€ {â„“} (A : Type â„“) â†’ Type â„“\n  âˆ¥ A âˆ¥â‚€ = !âˆ¥ A âˆ¥â‚€\n\n  âˆ£_âˆ£â‚€ : âˆ€ {â„“} {X : Type â„“} â†’ X â†’ âˆ¥ X âˆ¥â‚€\n  âˆ£ x âˆ£â‚€ = !âˆ£ x âˆ£â‚€\n\n  -- Any two equalities on the truncated type are equal\n  postulate strunc : âˆ€ {â„“} {A : Type â„“} â†’ isSet âˆ¥ A âˆ¥â‚€\n\n  -- Recursion principle\n  strunc-rec : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {P : Type â„“â±¼} â†’ isSet P â†’ (A â†’ P) â†’ âˆ¥ A âˆ¥â‚€ â†’ P\n  strunc-rec _ f !âˆ£ x âˆ£â‚€ = f x\n\n  -- Induction principle\n  strunc-ind : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {B : âˆ¥ A âˆ¥â‚€ â†’ Type â„“â±¼} â†’ ((a : âˆ¥ A âˆ¥â‚€) â†’ isSet (B a))\n             â†’ (g : (a : A) â†’ B âˆ£ a âˆ£â‚€) â†’ (a : âˆ¥ A âˆ¥â‚€) â†’ B a\n  strunc-ind _ g !âˆ£ x âˆ£â‚€ = g x\n\\end{code}\n\n## Quotients\n\n\\begin{code}\nmodule Quotients where\n\n  record QRel {â„“} (A : Type â„“) : Type (lsuc â„“) where\n    field\n      R : A â†’ A â†’ Type â„“\n      Aset : isSet A\n      Rprop : (a b : A) â†’ isProp (R a b)\n  open QRel  public\n\n  private\n    -- Higher inductive type\n    data _!/_ {â„“} (A : Type â„“) (r : QRel A) : Type (lsuc â„“) where\n      ![_] : A â†’ (A !/ r)\n\n  _/_ : âˆ€ {â„“} (A : Type â„“) (r : QRel A) â†’ Type (lsuc â„“)\n  A / r = (A !/ r)\n\n  [_] : âˆ€ {â„“} {A : Type â„“} â†’ A â†’ {r : QRel A} â†’ (A / r)\n  [ a ] = ![ a ]\n\n  -- Equalities induced by the relation\n  postulate Req : âˆ€ {â„“} {A : Type â„“} {r : QRel A}\n                 â†’ {a b : A} â†’ R  a b â†’ [ a ] {r} == [ b ]\n\n  -- The quotient of a set is again a set\n  postulate Rtrunc : âˆ€ {â„“} {A : Type â„“} {r : QRel A} â†’ isSet (A / r)\n\n  -- Recursion principle\n  QRel-rec : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {r : QRel A} {B : Type â„“â±¼}\n            â†’ (f : A â†’ B) â†’ ((x y : A) â†’ R  x y â†’ f x == f y) â†’ A / r â†’ B\n  QRel-rec f p ![ x ] = f x\n\n  -- Induction principle\n  QRel-ind : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {r : QRel A} {B : A / r â†’ Type â„“â±¼}\n            â†’ (f : ((a : A) â†’ B [ a ]))\n            â†’ ((x y : A) â†’ (o : R  x y) â†’ (transport B (Req o) (f x)) == f y)\n            â†’ (z : A / r) â†’ B z\n  QRel-ind f p ![ x ] = f x\n\n  -- Recursion in two arguments\n  QRel-rec-bi : âˆ€ {â„“áµ¢ â„“â±¼} {A : Type â„“áµ¢} {r : QRel A} {B : Type â„“â±¼}\n              â†’ (f : A â†’ A â†’ B) â†’ ((x y z t : A) â†’ R  x y â†’ R  z t â†’ f x z == f y t)\n              â†’ A / r â†’ A / r â†’ B\n  QRel-rec-bi f p ![ x ] ![ y ] = f x y\n\n\n  Qrel-prod : âˆ€ {â„“áµ¢}{A : Type â„“áµ¢} (r : QRel A) â†’ QRel (A Ã— A)\n  Qrel-prod r = record { R = Î» { (a , b) (c , d) â†’ (R  a c) Ã— (R  b d) }\n                       ; Aset = isSet-prod (Aset ) (Aset )\n                       ; Rprop = Î» { (x , y) (z , w) â†’ isProp-prod (Rprop  x z) (Rprop  y w)} }\n\\end{code}\n\n## Relation\n\n\\begin{code}\nmodule Relation where\n\n  record Rel {â„“} (A : Type â„“) : Type (lsuc â„“) where\n    field\n      R     : A â†’ A â†’ Type â„“\n      Rprop : (a b : A) â†’ isProp (R a b)\n  open Rel  public\n\nopen Relation public\n\\end{code}\n\n\n## Hedberg\n\n\\begin{code}\nmodule Hedberg {â„“} where\n\n  module HedbergLemmas (A : Type â„“) where\n\n    -- A set is a type satisfiying axiom K.\n    axiomKisSet : ((a : A) â†’ (p : a == a) â†’ p == refl a) â†’ isSet A\n    axiomKisSet k x _ p idp = k x p\n\n    -- Lemma: a reflexive relation on X implying the identity proves\n    -- that X is a set.\n    reflRelIsSet :  (r : Rel A) â†’\n      ((x y : A) â†’ R  x y â†’ x == y) â†’\n      (Ï : (a : A) â†’ R  a a) â†’\n      isSet A\n    reflRelIsSet r f Ï x .x p idp = lemma p\n      where\n        lemma2 : {a : A} (p : a == a) â†’ (o : R  a a) â†’\n          transport (Î» x â†’ a == x) p (f a a o) == f a a (transport (R  a) p o)\n        lemma2 {a} p = funext-transport-l p (f a a) (f a a) (apd (f a) p)\n\n        lemma3 : {a : A} (p : a == a) â†’\n          (f a a (Ï a)) Â· p == (f a a (Ï a))\n        lemma3 {a} p = inv (transport-concat-r p _) Â· lemma2 p (Ï a) Â·\n                       ap (f a a) (Rprop  a a _ (Ï a))\n\n        lemma : {a : A} (p : a == a) â†’ p == refl a\n        lemma {a} p = Â·-cancellation ((f a a (Ï a))) p (lemma3 p)\n\n    -- Lemma: if a type is decidable, then Â¬Â¬A is actually A.\n    lemDoubleNeg : (A + Â¬ A) â†’ (Â¬ (Â¬ A) â†’ A)\n    lemDoubleNeg (inl x) _ = x\n    lemDoubleNeg (inr f) n = exfalso (n f)\n\n  open HedbergLemmas public\n\n  -- Hedberg's theorem. A type with decidable equality is a set.\n  hedberg : {A : Type â„“} â†’ ((a b : A) â†’ (a == b) + Â¬ (a == b)) â†’ isSet A\n  hedberg {A} f = reflRelIsSet A\n                (record { R = Î» a b â†’ Â¬ (Â¬ (a == b)) ; Rprop = isPropNeg })\n                doubleNegEq (Î» a z â†’ z (refl a))\n    where\n      doubleNegEq : (a b : A) â†’ Â¬ (Â¬ (a == b)) â†’ (a == b)\n      doubleNegEq a b = lemDoubleNeg (a == b) (f a b)\n\n      isPropNeg : (a b : A) â†’ isProp (Â¬ (Â¬ (a == b)))\n      isPropNeg a b x y = funext Î» u â†’ exfalso (x u)\n\nopen Hedberg public\n\\end{code}\n\n\n## Algebra\n\n### Monoid\n\nDefinition of the algebraic structure of a monoid.\n\n\\begin{code}\nmodule Monoids {â„“} where\n\n  record Monoid : Type (lsuc â„“) where\n    field\n      -- Operations of a monoid\n      G : Type â„“\n      GisSet : isSet G\n      _<>_ : G â†’ G â†’ G  -- Multiplication function\n      e : G             -- Unit element\n\n      -- Axioms of a monoid\n      lunit : (x : G) â†’ (e <> x) == x\n      runit : (x : G) â†’ (x <> e) == x\n      assoc : (x y z : G) â†’ (x <> (y <> z)) == ((x <> y) <> z)\nopen Monoids\n\\end{code}\n\n### Groups\n\n\\begin{code}\nmodule Groups where\n  record GroupStructure {â„“} (M : Type â„“) : Type â„“ where\n    constructor group-structure\n    field\n      -- A group is a monoid\n      _*_   : M â†’ M â†’ M\n      e     : M\n      lunit : âˆ€ x â†’ (e * x) == x\n      runit : âˆ€ x â†’ (x * e) == x\n      assoc : âˆ€ x y z â†’ (x * (y * z)) == ((x * y) * z)\n\n      -- With inverses\n      ginv : M â†’ M\n      glinv : âˆ€ g â†’ (g * ginv g) == e\n      grinv : âˆ€ g â†’ (ginv g * g) == e\n\n  record Group {â„“} : Type (lsuc â„“) where\n    constructor group\n    field\n      M : Type â„“\n      str : GroupStructure M\n  open Group  public\nopen Groups\n\\end{code}\n\n### Naturals\n\n\\begin{code}\nmodule Naturals where\n\n  -- Addition of natural numbers\n  plus : â„• â†’ â„• â†’ â„•\n  plus zero y = y\n  plus (succ x) y = succ (plus x y)\n\n  infixl 60 _+â‚™_\n  _+â‚™_ : â„• â†’ â„• â†’ â„•\n  _+â‚™_ = plus\n\n  -- Lemmas about addition\n  plus-lunit : (n : â„•) â†’ zero +â‚™ n == n\n  plus-lunit n = refl n\n\n  plus-runit : (n : â„•) â†’ n +â‚™ zero == n\n  plus-runit zero = refl zero\n  plus-runit (succ n) = ap succ (plus-runit n)\n\n  plus-succ : (n m : â„•) â†’ succ (n +â‚™ m) == (n +â‚™ (succ m))\n  plus-succ zero     m = refl (succ m)\n  plus-succ (succ n) m = ap succ (plus-succ n m)\n\n  plus-succ-rs : (n m o p : â„•) â†’ n +â‚™ m == o +â‚™ p â†’ n +â‚™ (succ m) == o +â‚™ (succ p)\n  plus-succ-rs n m o p Î± = inv (plus-succ n m) Â· ap succ Î± Â· (plus-succ o p)\n\n  -- Commutativity\n  plus-comm : (n m : â„•) â†’ n +â‚™ m == m +â‚™ n\n  plus-comm zero     m = inv (plus-runit m)\n  plus-comm (succ n) m = ap succ (plus-comm n m) Â· plus-succ m n\n\n  -- Associativity\n  plus-assoc : (n m p : â„•) â†’ n +â‚™ (m +â‚™ p) == (n +â‚™ m) +â‚™ p\n  plus-assoc zero     m p = refl (m +â‚™ p)\n  plus-assoc (succ n) m p = ap succ (plus-assoc n m p)\n\n\n  -- Decidable equality\n  -- Encode-decode technique for natural numbers\n  private\n    code : â„• â†’ â„• â†’ Typeâ‚€\n    code 0        0        = âŠ¤\n    code 0        (succ m) = âŠ¥\n    code (succ n) 0        = âŠ¥\n    code (succ n) (succ m) = code n m\n\n  crefl : (n : â„•) â†’ code n n\n  crefl zero     = â˜…\n  crefl (succ n) = crefl n\n\n  private\n    encode : (n m : â„•) â†’ (n == m) â†’ code n m\n    encode n m p = transport (code n) p (crefl n)\n\n    decode : (n m : â„•) â†’ code n m â†’ n == m\n    decode zero zero c = refl zero\n    decode zero (succ m) ()\n    decode (succ n) zero ()\n    decode (succ n) (succ m) c = ap succ (decode n m c)\n\n  zero-not-succ : (n : â„•) â†’ Â¬ (succ n == zero)\n  zero-not-succ n = encode (succ n) 0\n\n  -- The successor function is injective\n  succ-inj : {n m : â„•} â†’ (succ n == succ m) â†’ n == m\n  succ-inj {n} {m} p = decode n m (encode (succ n) (succ m) p)\n\n  +-inj : (k : â„•) {n m : â„•} â†’ (k +â‚™ n == k +â‚™ m) â†’ n == m\n  +-inj zero   p = p\n  +-inj (succ k) p = +-inj k (succ-inj p)\n\n  nat-decEq : decEq â„•\n  nat-decEq zero zero = inl (refl zero)\n  nat-decEq zero (succ m) = inr (Î» ())\n  nat-decEq (succ n) zero = inr (Î» ())\n  nat-decEq (succ n) (succ m) with (nat-decEq n m)\n  nat-decEq (succ n) (succ m) | inl p = inl (ap succ p)\n  nat-decEq (succ n) (succ m) | inr f = inr Î» p â†’ f (succ-inj p)\n\n  nat-isSet : isSet â„•\n  nat-isSet = hedberg nat-decEq\n\n  -- Naturals form a monoid with addition\n  â„•-plus-monoid : Monoid\n  â„•-plus-monoid = record\n    { G = â„•\n    ; GisSet = nat-isSet\n    ; _<>_ = plus\n    ; e = zero\n    ; lunit = plus-lunit\n    ; runit = plus-runit\n    ; assoc = plus-assoc\n    }\n\n  -- Ordering\n  _",
  "headings": [

  ],
  "custom_ranking": {
    "position": 0,
    "heading": 100
  },
  "title": "Mini HoTT library in Agda",
  "toc": true,
  "agda": true,
  "gallery": true,
  "latex": true,
  "references": true,
  "showcitation": true,
  "last_modified_at": "20-Sep-18",
  "git": {
    "authors": [
      {
        "commits": 1,
        "name": "Jonathan Prieto-Cubides",
        "email": "jcu043@uib.no"
      }
    ],
    "total_commits": 1,
    "total_additions": 3451,
    "total_subtractions": 0,
    "first_commit": {
      "short_sha": "c4f28f44",
      "long_sha": "c4f28f442c4609eb0fe2795033803790551d3f6b",
      "author_name": "Jonathan Prieto-Cubides",
      "author_email": "jcu043@uib.no",
      "author_date": "Thu Sep 20 20:23:14 2018 +0200",
      "commit_name": "Jonathan Prieto-Cubides",
      "commit_email": "jcu043@uib.no",
      "commit_date": "Thu Sep 20 20:23:14 2018 +0200",
      "message": "[ bitacora ] saving progress",
      "changed_files": [
        ".git-metadata/7b5fca1be20ca8347810317bb0eebf95b1529745.json",
        "_posts/2018-09-20-bitacora.md",
        "_src/notes/2018-09-20-bitacora.md",
        "assets/png-images/2018-07-06-mini-hott.lagda",
        "assets/png-images/2018-09-20-bitacora-485765ed.png",
        "assets/png-images/2018-09-20-bitacora-c68ebbd9.png"
      ]
    },
    "last_commit": {
      "short_sha": "c4f28f44",
      "long_sha": "c4f28f442c4609eb0fe2795033803790551d3f6b",
      "author_name": "Jonathan Prieto-Cubides",
      "author_email": "jcu043@uib.no",
      "author_date": "Thu Sep 20 20:23:14 2018 +0200",
      "commit_name": "Jonathan Prieto-Cubides",
      "commit_email": "jcu043@uib.no",
      "commit_date": "Thu Sep 20 20:23:14 2018 +0200",
      "message": "[ bitacora ] saving progress",
      "changed_files": [
        ".git-metadata/7b5fca1be20ca8347810317bb0eebf95b1529745.json",
        "_posts/2018-09-20-bitacora.md",
        "_src/notes/2018-09-20-bitacora.md",
        "assets/png-images/2018-07-06-mini-hott.lagda",
        "assets/png-images/2018-09-20-bitacora-485765ed.png",
        "assets/png-images/2018-09-20-bitacora-c68ebbd9.png"
      ]
    }
  },
  "tags": [

  ],
  "categories": "type-theory",
  "date": 1530828000,
  "slug": "2018-07-06-mini-hott",
  "type": "page",
  "url": "/assets/png-images/2018-07-06-mini-hott.lagda"
}
Let's define first an auxiliary type for the this approach.

\begin{code}
module _ where
\end{code}

{: .foldable until="3"}
\begin{code}
module Câ‚‚ where
  -- Câ‚‚ HIT
  private
    data !Câ‚‚ : Set where
      !* : !Câ‚‚

  Câ‚‚ : Typeâ‚€
  Câ‚‚ = !Câ‚‚

  * : Câ‚‚
  * = !*

  postulate
    t : * == *
    q : t Â· t == refl *

    Câ‚‚-groupoid : (x y : Câ‚‚)(Î± Î² : x == y)(Îµ Î´ : Î± == Î²) â†’ Îµ == Î´
    -- Câ‚‚ is h-level 3, h-groupoid?

  -- Def. Recursion on points:
  postulate
    Câ‚‚-rec
      : âˆ€ {â„“}
      â†’ (A : Type â„“)
      â†’ (a : A)
      â†’ (p : a == a)
      â†’ (k : p Â· p == refl a)
      --------------
      â†’ (Câ‚‚ â†’ A)

  -- Câ‚‚-rec A a p !* _ = a
--
--   -- Postulate. Recursion on paths:
--   postulate
--     Câ‚‚-Î²rec
--       : âˆ€ {â„“}
--       â†’ (A : Type â„“)
--       â†’ (a : A)
--       â†’ (p : a == a)
--       â†’ (k : p Â· p == refl a)
--       -- -----------------------------
--       â†’ ap (Câ‚‚-rec A a p)  ? == ?
--
--   -- Postulate. Recursion on paths for q
--
--   postulate
--     Câ‚‚-Î²recâ‚‚
--       : âˆ€ {â„“}
--       â†’ (A : Type â„“)
--       â†’ (a : A)
--       â†’ (p : a == a)
--       â†’ (k : p Â· p == refl a)
--       -----------------------------
--       â†’ ap ? ? == k
--
--   -- postulate
--   --   Câ‚‚-Î²rec
--   --     : âˆ€ {â„“}
--   --     â†’ (A : Type â„“)
--   --     â†’ (a : A)
--   --     â†’ (p : a == a)
--   --     â†’ (k : p Â· p == relf a)
--   --     -----------------------------
--   --     â†’ ap (Câ‚‚-rec A a p) t _==
--
--   -- Def.  Induction principle on points:
--   Câ‚‚-ind
--     : âˆ€ {â„“} (P : Câ‚‚ â†’ Type â„“)
--     â†’ (x : P *)
--     â†’ (x == x [ P â†“ t ])
--     ------------------------
--     â†’ ((t : Câ‚‚) â†’ P t)
--
--   Câ‚‚-ind P x p !* = x
--   -- Postulate. Induction principle on paths:
--   postulate
--     Câ‚‚-Î²ind
--       : âˆ€ {â„“} (P : Câ‚‚ â†’ Type â„“)
--       â†’ (x : P *)
--       â†’ (p : x == x [ P â†“ t ])
--       -------------------------------
--       â†’ apd (Câ‚‚-ind P x p) t == p
-- \end{code}
--
-- Now, we define the type family for
--
-- {: .foldable until="2"}
-- \begin{code}
--   -- Pâ‚‚ Type family
--   Pâ‚‚ : Câ‚‚ â†’ Set
--
--   neg-eq : ğŸš â‰ƒ ğŸš
--   neg-eq = qinv-â‰ƒ negÂ¬ (negÂ¬ , h , h)
--     where
--       h : negÂ¬ âˆ˜ negÂ¬ âˆ¼ id
--       h true  = idp
--       h false = idp
--
--   Pâ‚‚ = Câ‚‚-rec Typeâ‚€ ğŸš (ua neg-eq)
--
--   -- Defs.
--   flipâ‚ : tr Pâ‚‚ t false == true
--   flipâ‚ = transport-ua Pâ‚‚ t neg-eq (Câ‚‚-Î²rec Typeâ‚€ ğŸš (ua neg-eq)) false
--
--   flipâ‚‚ : tr Pâ‚‚ t true == false
--   flipâ‚‚ = transport-ua Pâ‚‚ t neg-eq (Câ‚‚-Î²rec Typeâ‚€ ğŸš (ua neg-eq)) true
--
--   postulate
--     tr-inv-t : âˆ€ {x} â†’ transport Pâ‚‚ (! t) x == negÂ¬ x
--     -- Check the article tinyurl.com/circle-puzzle, it has how to remove this

\end{code}

A *graph* can be defined by using two constructors: `Node` and `Edge`.

\begin{code}
-- module GraphFormâ‚ {â„“} where
--   open Câ‚‚
\end{code}

- A set of vertices:

\begin{code}
  -- Def.
  -- postulate
    -- Node : Type â„“
    -- NodeisSet : isSet Node
\end{code}

- A set of edges:

{: .eq }
  $$ \Edge :â‰¡ \sum_{x : Câ‚‚} ~{Pâ‚‚~x}\to\Node$$

\begin{code}
  -- Def.
  -- Edge : Î£ Câ‚‚ (Î» x â†’ (Pâ‚‚ x) â†’ Node) â†’ Set
\end{code}

\begin{code}
  -- -- Graphâ‚
  -- record Graph : Type (lsuc â„“) where
  --   constructor graph
  --   field
  --     Node : Type â„“
  --     NodeisSet : isSet Node
  --     Edge : Î£ Câ‚‚ (Î» x â†’ (Pâ‚‚ x) â†’ Node) â†’ Set
\end{code}

\begin{code}
  -- data X : Set where
  --   x : X
  --   y : X
  --
  -- g : Graph
  -- g = graph ? ? ?
  --
  -- Ex.
  -- postulate
    -- Node : Type â„“
    -- Edge : Î£ Câ‚‚ (Î» x â†’ (Pâ‚‚ x) â†’ Node) â†’ Set
    -- x : Node
    -- y : Node
  --
  -- x-y : Pâ‚‚ * â†’ Node
  -- x-y true  = x
  -- x-y false = y
  --
  -- y-x : Pâ‚‚ * â†’ Node
  -- y-x true  = y
  -- y-x false = x
  --
  -- e1 = Edge (* , x-y)
  -- e2 = Edge (* , y-x)
  --
  -- e1=e2 : Edge (* , x-y) == Edge (* , y-x)
  -- e1=e2 = ap Edge (pair= (t , Î·))
  --   where
  --     lem : (x : Pâ‚‚ *) â†’ x-y (negÂ¬ x) == y-x x
  --     lem true  = idp
  --     lem false = idp
  --
  --     Î· : tr (Î» x â†’ Pâ‚‚ x â†’ Node) t x-y == y-x
  --     Î· =
  --       begin
  --         tr (Î» x â†’ Pâ‚‚ x â†’ Node) t x-y
  --           ==âŸ¨ transport-fun t x-y âŸ©
  --         (Î» x â†’ tr (Î» _ â†’ Node) t (x-y (tr Pâ‚‚ (! t) x)))
  --           ==âŸ¨ funext (Î» x â†’ transport-const t (x-y (tr Pâ‚‚ (! t) x))) âŸ©
  --         (Î» x â†’ x-y (tr Pâ‚‚ (! t) x))
  --           ==âŸ¨ funext (Î» x â†’ ap x-y tr-inv-t) âŸ©
  --         (Î» x â†’ x-y (negÂ¬ x))
  --           ==âŸ¨ funext (Î» x â†’ lem x) âŸ©
  --         y-x
  --       âˆ
\end{code}

<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Induction on Identity Types &middot; jonaprieto
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- TIMELINES -->
  <link title="timeline-styles" rel="stylesheet" href="https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Induction on Identity Types</title>
  <meta name="description" content="We present here a new type former to introduce identities. The identity or equality type is defined as follows:">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114360791-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-114360791-1');
  </script>
  <!-- TIMELINE -->
  <script src="https://cdn.knightlab.com/libs/timeline3/latest/js/timeline.js"></script>

</head>




  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item" >
    <p style="text-decoration:left">Jonathan Prieto-Cubides</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/HoTT-Timeline/">HoTT Timeline</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/Interval-Analysis-Timeline/">Interval Analysis Timeline</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/categories/">Post by category</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/references/">References</a>
        
      
    

    <!-- <a class="sidebar-nav-item" href="/archive/v0.0.4.zip">Download</a> -->
    <!-- <a class="sidebar-nav-item" href="">GitHub project</a> -->
    <!-- <span class="sidebar-nav-item">Currently v0.0.4</span> -->
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://github.com/jonaprieto"><img alt="@jonaprieto" class="avatar float-left mr-1" src="https://avatars3.githubusercontent.com/u/1428088?s=40&amp;v=4" height="20" width="20"></a>
            <a href="/" title="Home">jonaprieto</a>

            <small style="text-decoration:left">logs in progress</small>
          </h3>
        </div>
      
      <div class="container content">
        <div class="post">
  <div class="post-changes">
    <div class="main-heading">
      <div class="main-title"> Latest change <span class="post-modifications">(<span class="additions">+1197</span>/<span class="substractions">-1012</span>)</span>:
          <span class="commit-message"> <a href="http://github.com/jonaprieto/jonaprieto.github.io"> Add references</a></span>
    </div>
    <div class="main-last-date">
        Latest commit <a href="">94934d4 </a> on  23 Apr 2018
    </div>
    </div>
</div>
  <h1 class="post-title">Induction on Identity Types</h1>

  <!-- <span class="post-date">Created on 14 Feb 2018 -->
    <!-- <small style="text-decoration:left">Created on 14 Feb 2018 on Latest change on 23 Apr 2018</small> -->
  <!-- </span> -->

  
  <p>We present here a new type former to introduce identities.
The identity or equality type is defined as follows:</p>

<pre><code class="language-agda">data Id (A : Set) (x y : A) : Set where
  refl : Id A x y
</code></pre>

<p>The only rule/constructor is <code class="highlighter-rouge">refl</code> that represents the reflexivity property of
the inductive types. Sometimes we can another definition for refl, that is
similar as the presented above but using the equality symbol (<code class="highlighter-rouge">_≡_</code>) and Π-type.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>refl: Π x:A. x ≡ x
</code></pre></div></div>

<p>In Agda we will write this</p>

<pre><code class="language-agda">infix 4 _≡_
data _≡_ {a} {A : Set a} (x : A) : A → Set a where
  instance refl : x ≡ x
</code></pre>

<p>instead of</p>

<pre><code class="language-agda">infix 3 _≡_
_≡_ : ∀ {A : Set} → (x y : A) → Id A x y
x ≡ y = refl
</code></pre>

<p>However, this type is already present in the Agda standard library, so let’s use it</p>

<pre class="Agda"><a id="877" class="Keyword">open</a> <a id="882" class="Keyword">import</a> <a id="889" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="927" class="Keyword">using</a> <a id="933" class="Symbol">(</a><a id="934" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a><a id="938" class="Symbol">;</a> <a id="940" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">_≡_</a><a id="943" class="Symbol">)</a></pre>

<h3 id="martin-löfs-rules-about-identity-type">Martin-Löf’s rules about identity type</h3>

<ul>
  <li>
    <p>ML1. For any type <code class="highlighter-rouge">X</code>, for each <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> of it, there is a type <code class="highlighter-rouge">a = b</code></p>
  </li>
  <li>
    <p>ML2. There is an element <code class="highlighter-rouge">refl x : x = x</code> for each <code class="highlighter-rouge">x : X</code></p>
  </li>
  <li>
    <p>ML3. Induction for equality:</p>

    <blockquote>
      <p>For any type <script type="math/tex">X</script> and for any element <script type="math/tex">a</script> of it, given a family of types <script type="math/tex">P(b,e)</script>
  depending on parameters <script type="math/tex">b</script> of type <script type="math/tex">X</script> and <script type="math/tex">e</script> of type <script type="math/tex">a=b</script>, in order to
  define elements <script type="math/tex">f(b,e) : P(b,e)</script> of all of them it suffices to provide an
  element <script type="math/tex">p</script> of <script type="math/tex">P(a, refl\ a)</script>.  The resulting function <script type="math/tex">f</script> may be regarded as
  having been completely defined by the single definition <script type="math/tex">f(a, refl\ a) := p</script>.</p>
    </blockquote>

    <blockquote>
      <p>Intuitively, the induction principle for equality amounts to saying that the
  element <script type="math/tex">refl a</script> ``generates’’ the system of types <script type="math/tex">a=b</script>, as <script type="math/tex">b</script> ranges
  over elements of <script type="math/tex">A</script>.
  <cite><a href="http://arxiv.org/abs/1711.01477">Daniel Grayson</a></cite></p>
    </blockquote>
  </li>
</ul>

<p>We will show in a moment more about ML3 rule from the univalance perspective,
that is, the homotopy type theory perspective. The main diference up to now, we
give another meaning of <code class="highlighter-rouge">a = b</code>, insteaf of thinking about it as a proof of such
a equality, we are going to think as a <code class="highlighter-rouge">path space</code> in a topological space
associated to <code class="highlighter-rouge">A</code></p>

<p>In the following, we may encounter with <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/">levels</a> in Agda.
The small types are those that belongs to the first level 0, types of level 1 are
those formed by using small types, and so on. The small types in Agda has <code class="highlighter-rouge">Set</code> type ,
types formed by these small types have <code class="highlighter-rouge">Set 1</code> type, and so on with <code class="highlighter-rouge">Set i</code> type.</p>

<h3 id="path-induction">Path induction</h3>

<p>We call <em>path</em> to the inhabitant of the identity type, that is, p : x ≡ y for
some x and y of type A. We can probably think that there is only one p, but
there are many identifications between x and y from the HoTT perspective. That’s
the reason we talk about one path and one set of paths, the <em>path space</em>.</p>

<p><img src="/assets/ipe-images/path.png" alt="path" /></p>

<p>Now, we introduce the induction principle for the identity type with <code class="highlighter-rouge">pi</code>
abbreviation of path induction also called elimination identity and noted
<a href="https://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory/"><code class="highlighter-rouge">J</code></a>.</p>

<pre class="Agda"><a id="pi" href="/type-theory/2018/02/14/induction-on-identity-types/#pi" class="Function">pi</a>
  <a id="3238" class="Symbol">:</a> <a id="3240" class="Symbol">∀</a> <a id="3242" class="Symbol">{</a><a id="3243" href="/type-theory/2018/02/14/induction-on-identity-types/#3243" class="Bound">i</a><a id="3244" class="Symbol">}</a> <a id="3246" class="Symbol">{</a><a id="3247" href="/type-theory/2018/02/14/induction-on-identity-types/#3247" class="Bound">A</a> <a id="3249" class="Symbol">:</a> <a id="3251" class="PrimitiveType">Set</a><a id="3254" class="Symbol">}</a>
  <a id="3258" class="Symbol">→</a> <a id="3260" class="Symbol">(</a><a id="3261" href="/type-theory/2018/02/14/induction-on-identity-types/#3261" class="Bound">C</a> <a id="3263" class="Symbol">:</a> <a id="3265" class="Symbol">(</a><a id="3266" href="/type-theory/2018/02/14/induction-on-identity-types/#3266" class="Bound">x</a> <a id="3268" href="/type-theory/2018/02/14/induction-on-identity-types/#3268" class="Bound">y</a> <a id="3270" class="Symbol">:</a> <a id="3272" href="/type-theory/2018/02/14/induction-on-identity-types/#3247" class="Bound">A</a><a id="3273" class="Symbol">)</a> <a id="3275" class="Symbol">→</a> <a id="3277" href="/type-theory/2018/02/14/induction-on-identity-types/#3266" class="Bound">x</a> <a id="3279" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="3281" href="/type-theory/2018/02/14/induction-on-identity-types/#3268" class="Bound">y</a> <a id="3283" class="Symbol">→</a> <a id="3285" class="PrimitiveType">Set</a> <a id="3289" href="/type-theory/2018/02/14/induction-on-identity-types/#3243" class="Bound">i</a><a id="3290" class="Symbol">)</a>
  <a id="3294" class="Symbol">→</a> <a id="3296" class="Symbol">(∀</a> <a id="3299" class="Symbol">(</a><a id="3300" href="/type-theory/2018/02/14/induction-on-identity-types/#3300" class="Bound">x</a> <a id="3302" class="Symbol">:</a> <a id="3304" href="/type-theory/2018/02/14/induction-on-identity-types/#3247" class="Bound">A</a><a id="3305" class="Symbol">)</a> <a id="3307" class="Symbol">→</a> <a id="3309" href="/type-theory/2018/02/14/induction-on-identity-types/#3261" class="Bound">C</a> <a id="3311" href="/type-theory/2018/02/14/induction-on-identity-types/#3300" class="Bound">x</a> <a id="3313" href="/type-theory/2018/02/14/induction-on-identity-types/#3300" class="Bound">x</a> <a id="3315" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a><a id="3319" class="Symbol">)</a>
  <a id="3323" class="Symbol">→</a> <a id="3325" class="Symbol">∀</a> <a id="3327" class="Symbol">(</a><a id="3328" href="/type-theory/2018/02/14/induction-on-identity-types/#3328" class="Bound">x</a> <a id="3330" href="/type-theory/2018/02/14/induction-on-identity-types/#3330" class="Bound">y</a> <a id="3332" class="Symbol">:</a> <a id="3334" href="/type-theory/2018/02/14/induction-on-identity-types/#3247" class="Bound">A</a><a id="3335" class="Symbol">)</a> <a id="3337" class="Symbol">(</a><a id="3338" href="/type-theory/2018/02/14/induction-on-identity-types/#3338" class="Bound">p</a> <a id="3340" class="Symbol">:</a> <a id="3342" href="/type-theory/2018/02/14/induction-on-identity-types/#3328" class="Bound">x</a> <a id="3344" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="3346" href="/type-theory/2018/02/14/induction-on-identity-types/#3330" class="Bound">y</a><a id="3347" class="Symbol">)</a> <a id="3349" class="Symbol">→</a> <a id="3351" href="/type-theory/2018/02/14/induction-on-identity-types/#3261" class="Bound">C</a> <a id="3353" href="/type-theory/2018/02/14/induction-on-identity-types/#3328" class="Bound">x</a> <a id="3355" href="/type-theory/2018/02/14/induction-on-identity-types/#3330" class="Bound">y</a> <a id="3357" href="/type-theory/2018/02/14/induction-on-identity-types/#3338" class="Bound">p</a></pre>

<p>defined by the equation</p>

<pre class="Agda"><a id="3409" href="/type-theory/2018/02/14/induction-on-identity-types/#pi" class="Function">pi</a> <a id="3412" class="Symbol">{</a><a id="3413" href="/type-theory/2018/02/14/induction-on-identity-types/#3413" class="Bound">A</a><a id="3414" class="Symbol">}</a> <a id="3416" href="/type-theory/2018/02/14/induction-on-identity-types/#3416" class="Bound">C</a> <a id="3418" href="/type-theory/2018/02/14/induction-on-identity-types/#3418" class="Bound">c</a> <a id="3420" href="/type-theory/2018/02/14/induction-on-identity-types/#3420" class="Bound">x</a> <a id="3422" class="DottedPattern Symbol">.</a><a id="3423" href="/type-theory/2018/02/14/induction-on-identity-types/#3420" class="DottedPattern Bound">x</a> <a id="3425" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="3430" class="Symbol">=</a> <a id="3432" href="/type-theory/2018/02/14/induction-on-identity-types/#3418" class="Bound">c</a> <a id="3434" href="/type-theory/2018/02/14/induction-on-identity-types/#3420" class="Bound">x</a></pre>

<p>Let us unpackage this:</p>

<p>To contruct something of the type (∀ (x y : A) (p : x ≡ y) → C x y p) we need that:</p>

<ul>
  <li>
    <p>C can construct types from three arguments: two points and one path.</p>
  </li>
  <li>
    <p>C holds in the <em>diagonal</em>, that is, we need to prove or find an
inhabitant of C x x refl for all x.</p>
  </li>
</ul>

<p>Then, as result, the property C holds for all paths in general.</p>

<h3 id="based-path-induction">Based path induction</h3>

<p>A differente or more customized version of path induction is the based
path induction abbreviated as <code class="highlighter-rouge">bpi</code>.</p>

<pre class="Agda"><a id="bpi" href="/type-theory/2018/02/14/induction-on-identity-types/#bpi" class="Function">bpi</a>
  <a id="3951" class="Symbol">:</a> <a id="3953" class="Symbol">∀</a> <a id="3955" class="Symbol">{</a><a id="3956" href="/type-theory/2018/02/14/induction-on-identity-types/#3956" class="Bound">i</a><a id="3957" class="Symbol">}</a> <a id="3959" class="Symbol">{</a><a id="3960" href="/type-theory/2018/02/14/induction-on-identity-types/#3960" class="Bound">A</a> <a id="3962" class="Symbol">:</a> <a id="3964" class="PrimitiveType">Set</a><a id="3967" class="Symbol">}</a>
  <a id="3971" class="Symbol">→</a> <a id="3973" class="Symbol">(</a><a id="3974" href="/type-theory/2018/02/14/induction-on-identity-types/#3974" class="Bound">a</a> <a id="3976" class="Symbol">:</a> <a id="3978" href="/type-theory/2018/02/14/induction-on-identity-types/#3960" class="Bound">A</a><a id="3979" class="Symbol">)</a>
  <a id="3983" class="Symbol">→</a> <a id="3985" class="Symbol">(</a><a id="3986" href="/type-theory/2018/02/14/induction-on-identity-types/#3986" class="Bound">C</a> <a id="3988" class="Symbol">:</a> <a id="3990" class="Symbol">(</a><a id="3991" href="/type-theory/2018/02/14/induction-on-identity-types/#3991" class="Bound">y</a> <a id="3993" class="Symbol">:</a> <a id="3995" href="/type-theory/2018/02/14/induction-on-identity-types/#3960" class="Bound">A</a><a id="3996" class="Symbol">)</a> <a id="3998" class="Symbol">→</a> <a id="4000" href="/type-theory/2018/02/14/induction-on-identity-types/#3974" class="Bound">a</a> <a id="4002" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4004" href="/type-theory/2018/02/14/induction-on-identity-types/#3991" class="Bound">y</a> <a id="4006" class="Symbol">→</a> <a id="4008" class="PrimitiveType">Set</a> <a id="4012" href="/type-theory/2018/02/14/induction-on-identity-types/#3956" class="Bound">i</a><a id="4013" class="Symbol">)</a>
  <a id="4017" class="Symbol">→</a> <a id="4019" href="/type-theory/2018/02/14/induction-on-identity-types/#3986" class="Bound">C</a> <a id="4021" href="/type-theory/2018/02/14/induction-on-identity-types/#3974" class="Bound">a</a> <a id="4023" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a>
  <a id="4030" class="Symbol">→</a> <a id="4032" class="Symbol">(</a><a id="4033" href="/type-theory/2018/02/14/induction-on-identity-types/#4033" class="Bound">y</a> <a id="4035" class="Symbol">:</a> <a id="4037" href="/type-theory/2018/02/14/induction-on-identity-types/#3960" class="Bound">A</a><a id="4038" class="Symbol">)</a> <a id="4040" class="Symbol">(</a><a id="4041" href="/type-theory/2018/02/14/induction-on-identity-types/#4041" class="Bound">p</a> <a id="4043" class="Symbol">:</a> <a id="4045" href="/type-theory/2018/02/14/induction-on-identity-types/#3974" class="Bound">a</a> <a id="4047" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4049" href="/type-theory/2018/02/14/induction-on-identity-types/#4033" class="Bound">y</a><a id="4050" class="Symbol">)</a> <a id="4052" class="Symbol">→</a> <a id="4054" href="/type-theory/2018/02/14/induction-on-identity-types/#3986" class="Bound">C</a> <a id="4056" href="/type-theory/2018/02/14/induction-on-identity-types/#4033" class="Bound">y</a> <a id="4058" href="/type-theory/2018/02/14/induction-on-identity-types/#4041" class="Bound">p</a></pre>

<p>defined by the equation</p>

<pre class="Agda"><a id="4110" href="/type-theory/2018/02/14/induction-on-identity-types/#bpi" class="Function">bpi</a> <a id="4114" href="/type-theory/2018/02/14/induction-on-identity-types/#4114" class="Bound">a</a> <a id="4116" href="/type-theory/2018/02/14/induction-on-identity-types/#4116" class="Bound">C</a> <a id="4118" href="/type-theory/2018/02/14/induction-on-identity-types/#4118" class="Bound">c</a> <a id="4120" class="DottedPattern Symbol">.</a><a id="4121" href="/type-theory/2018/02/14/induction-on-identity-types/#4114" class="DottedPattern Bound">a</a> <a id="4123" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="4128" class="Symbol">=</a> <a id="4130" href="/type-theory/2018/02/14/induction-on-identity-types/#4118" class="Bound">c</a></pre>

<p><em>Remark</em>: we can not repeat in Agda a name variable in an equation. But using
the dot accompanying as a prefix of a variable, it tells the typechecker that
there is only one possible value and it corresponds to that variable.</p>

<p>Let us unpackage this:</p>

<ul>
  <li>
    <p>With a fixed endpoint a</p>
  </li>
  <li>
    <p>if we consider all paths whiches start with a</p>
  </li>
  <li>
    <p>to have the property for all y:A and for all paths a ≡ y the only
necessary is to have C a refl, that is, holds C for the <em>base case</em>.</p>
  </li>
</ul>

<h3 id="equivalence-between-path-induction-and-base-path-induction">Equivalence between path induction and base path induction</h3>

<p>Path-induction follows from path based induction.</p>

<pre class="Agda"><a id="bpi⇒pi" href="/type-theory/2018/02/14/induction-on-identity-types/#bpi%E2%87%92pi" class="Function">bpi⇒pi</a>
  <a id="4747" class="Symbol">:</a> <a id="4749" class="Symbol">∀</a> <a id="4751" class="Symbol">{</a><a id="4752" href="/type-theory/2018/02/14/induction-on-identity-types/#4752" class="Bound">A</a> <a id="4754" class="Symbol">:</a> <a id="4756" class="PrimitiveType">Set</a><a id="4759" class="Symbol">}</a>
  <a id="4763" class="Symbol">→</a> <a id="4765" class="Symbol">(</a><a id="4766" href="/type-theory/2018/02/14/induction-on-identity-types/#4766" class="Bound">C</a> <a id="4768" class="Symbol">:</a> <a id="4770" class="Symbol">(</a><a id="4771" href="/type-theory/2018/02/14/induction-on-identity-types/#4771" class="Bound">x</a> <a id="4773" href="/type-theory/2018/02/14/induction-on-identity-types/#4773" class="Bound">y</a> <a id="4775" class="Symbol">:</a> <a id="4777" href="/type-theory/2018/02/14/induction-on-identity-types/#4752" class="Bound">A</a><a id="4778" class="Symbol">)</a> <a id="4780" class="Symbol">→</a> <a id="4782" href="/type-theory/2018/02/14/induction-on-identity-types/#4771" class="Bound">x</a> <a id="4784" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4786" href="/type-theory/2018/02/14/induction-on-identity-types/#4773" class="Bound">y</a> <a id="4788" class="Symbol">→</a> <a id="4790" class="PrimitiveType">Set</a><a id="4793" class="Symbol">)</a>
  <a id="4797" class="Symbol">→</a> <a id="4799" class="Symbol">(</a><a id="4800" href="/type-theory/2018/02/14/induction-on-identity-types/#4800" class="Bound">c</a> <a id="4802" class="Symbol">:</a> <a id="4804" class="Symbol">(</a><a id="4805" href="/type-theory/2018/02/14/induction-on-identity-types/#4805" class="Bound">x</a> <a id="4807" class="Symbol">:</a> <a id="4809" href="/type-theory/2018/02/14/induction-on-identity-types/#4752" class="Bound">A</a><a id="4810" class="Symbol">)</a> <a id="4812" class="Symbol">→</a> <a id="4814" href="/type-theory/2018/02/14/induction-on-identity-types/#4766" class="Bound">C</a> <a id="4816" href="/type-theory/2018/02/14/induction-on-identity-types/#4805" class="Bound">x</a> <a id="4818" href="/type-theory/2018/02/14/induction-on-identity-types/#4805" class="Bound">x</a> <a id="4820" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a><a id="4824" class="Symbol">)</a>
  <a id="4828" class="Symbol">→</a> <a id="4830" class="Symbol">(</a><a id="4831" href="/type-theory/2018/02/14/induction-on-identity-types/#4831" class="Bound">x</a> <a id="4833" href="/type-theory/2018/02/14/induction-on-identity-types/#4833" class="Bound">y</a> <a id="4835" class="Symbol">:</a> <a id="4837" href="/type-theory/2018/02/14/induction-on-identity-types/#4752" class="Bound">A</a><a id="4838" class="Symbol">)</a> <a id="4840" class="Symbol">(</a><a id="4841" href="/type-theory/2018/02/14/induction-on-identity-types/#4841" class="Bound">p</a> <a id="4843" class="Symbol">:</a> <a id="4845" href="/type-theory/2018/02/14/induction-on-identity-types/#4831" class="Bound">x</a> <a id="4847" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4849" href="/type-theory/2018/02/14/induction-on-identity-types/#4833" class="Bound">y</a><a id="4850" class="Symbol">)</a> <a id="4852" class="Symbol">→</a> <a id="4854" href="/type-theory/2018/02/14/induction-on-identity-types/#4766" class="Bound">C</a> <a id="4856" href="/type-theory/2018/02/14/induction-on-identity-types/#4831" class="Bound">x</a> <a id="4858" href="/type-theory/2018/02/14/induction-on-identity-types/#4833" class="Bound">y</a> <a id="4860" href="/type-theory/2018/02/14/induction-on-identity-types/#4841" class="Bound">p</a>

<a id="4863" href="/type-theory/2018/02/14/induction-on-identity-types/#bpi%E2%87%92pi" class="Function">bpi⇒pi</a> <a id="4870" class="Symbol">{</a><a id="4871" href="/type-theory/2018/02/14/induction-on-identity-types/#4871" class="Bound">A</a><a id="4872" class="Symbol">}</a> <a id="4874" href="/type-theory/2018/02/14/induction-on-identity-types/#4874" class="Bound">C</a> <a id="4876" href="/type-theory/2018/02/14/induction-on-identity-types/#4876" class="Bound">c</a> <a id="4878" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a> <a id="4880" class="Symbol">=</a> <a id="4882" href="/type-theory/2018/02/14/induction-on-identity-types/#4976" class="Function">g</a>
  <a id="4886" class="Keyword">where</a>
    <a id="4896" href="/type-theory/2018/02/14/induction-on-identity-types/#4896" class="Function">C′</a> <a id="4899" class="Symbol">:</a> <a id="4901" class="Symbol">(</a><a id="4902" href="/type-theory/2018/02/14/induction-on-identity-types/#4902" class="Bound">y</a> <a id="4904" class="Symbol">:</a> <a id="4906" href="/type-theory/2018/02/14/induction-on-identity-types/#4871" class="Bound">A</a><a id="4907" class="Symbol">)</a> <a id="4909" class="Symbol">→</a> <a id="4911" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a> <a id="4913" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4915" href="/type-theory/2018/02/14/induction-on-identity-types/#4902" class="Bound">y</a> <a id="4917" class="Symbol">→</a> <a id="4919" class="PrimitiveType">Set</a>
    <a id="4927" href="/type-theory/2018/02/14/induction-on-identity-types/#4896" class="Function">C′</a> <a id="4930" class="Symbol">=</a> <a id="4932" href="/type-theory/2018/02/14/induction-on-identity-types/#4874" class="Bound">C</a> <a id="4934" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a>

    <a id="4941" href="/type-theory/2018/02/14/induction-on-identity-types/#4941" class="Function">c′</a> <a id="4944" class="Symbol">:</a> <a id="4946" href="/type-theory/2018/02/14/induction-on-identity-types/#4874" class="Bound">C</a> <a id="4948" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a> <a id="4950" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a> <a id="4952" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a>
    <a id="4961" href="/type-theory/2018/02/14/induction-on-identity-types/#4941" class="Function">c′</a>  <a id="4965" class="Symbol">=</a> <a id="4967" href="/type-theory/2018/02/14/induction-on-identity-types/#4876" class="Bound">c</a> <a id="4969" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a>

    <a id="4976" href="/type-theory/2018/02/14/induction-on-identity-types/#4976" class="Function">g</a> <a id="4978" class="Symbol">:</a> <a id="4980" class="Symbol">∀</a> <a id="4982" class="Symbol">(</a><a id="4983" href="/type-theory/2018/02/14/induction-on-identity-types/#4983" class="Bound">y</a> <a id="4985" class="Symbol">:</a> <a id="4987" href="/type-theory/2018/02/14/induction-on-identity-types/#4871" class="Bound">A</a><a id="4988" class="Symbol">)</a> <a id="4990" class="Symbol">(</a><a id="4991" href="/type-theory/2018/02/14/induction-on-identity-types/#4991" class="Bound">p</a> <a id="4993" class="Symbol">:</a> <a id="4995" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a> <a id="4997" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="4999" href="/type-theory/2018/02/14/induction-on-identity-types/#4983" class="Bound">y</a><a id="5000" class="Symbol">)</a> <a id="5002" class="Symbol">→</a> <a id="5004" href="/type-theory/2018/02/14/induction-on-identity-types/#4896" class="Function">C′</a> <a id="5007" href="/type-theory/2018/02/14/induction-on-identity-types/#4983" class="Bound">y</a> <a id="5009" href="/type-theory/2018/02/14/induction-on-identity-types/#4991" class="Bound">p</a>
    <a id="5015" href="/type-theory/2018/02/14/induction-on-identity-types/#4976" class="Function">g</a> <a id="5017" class="Symbol">=</a> <a id="5019" href="/type-theory/2018/02/14/induction-on-identity-types/#bpi" class="Function">bpi</a> <a id="5023" href="/type-theory/2018/02/14/induction-on-identity-types/#4878" class="Bound">x</a> <a id="5025" href="/type-theory/2018/02/14/induction-on-identity-types/#4896" class="Function">C′</a> <a id="5028" href="/type-theory/2018/02/14/induction-on-identity-types/#4941" class="Function">c′</a></pre>

<p>The other direction:</p>

<pre class="Agda"><a id="pi⇒bpi" href="/type-theory/2018/02/14/induction-on-identity-types/#pi%E2%87%92bpi" class="Function">pi⇒bpi</a>
  <a id="5087" class="Symbol">:</a> <a id="5089" class="Symbol">∀</a> <a id="5091" class="Symbol">{</a><a id="5092" href="/type-theory/2018/02/14/induction-on-identity-types/#5092" class="Bound">A</a> <a id="5094" class="Symbol">:</a> <a id="5096" class="PrimitiveType">Set</a><a id="5099" class="Symbol">}</a>
  <a id="5103" class="Symbol">→</a> <a id="5105" class="Symbol">(</a><a id="5106" href="/type-theory/2018/02/14/induction-on-identity-types/#5106" class="Bound">a</a> <a id="5108" class="Symbol">:</a> <a id="5110" href="/type-theory/2018/02/14/induction-on-identity-types/#5092" class="Bound">A</a><a id="5111" class="Symbol">)</a>
  <a id="5115" class="Symbol">→</a> <a id="5117" class="Symbol">(</a><a id="5118" href="/type-theory/2018/02/14/induction-on-identity-types/#5118" class="Bound">C</a> <a id="5120" class="Symbol">:</a> <a id="5122" class="Symbol">(</a><a id="5123" href="/type-theory/2018/02/14/induction-on-identity-types/#5123" class="Bound">y</a> <a id="5125" class="Symbol">:</a> <a id="5127" href="/type-theory/2018/02/14/induction-on-identity-types/#5092" class="Bound">A</a><a id="5128" class="Symbol">)</a> <a id="5130" class="Symbol">→</a> <a id="5132" href="/type-theory/2018/02/14/induction-on-identity-types/#5106" class="Bound">a</a> <a id="5134" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="5136" href="/type-theory/2018/02/14/induction-on-identity-types/#5123" class="Bound">y</a> <a id="5138" class="Symbol">→</a> <a id="5140" class="PrimitiveType">Set</a><a id="5143" class="Symbol">)</a>
  <a id="5147" class="Symbol">→</a> <a id="5149" class="Symbol">(</a><a id="5150" href="/type-theory/2018/02/14/induction-on-identity-types/#5150" class="Bound">c</a> <a id="5152" class="Symbol">:</a> <a id="5154" href="/type-theory/2018/02/14/induction-on-identity-types/#5118" class="Bound">C</a> <a id="5156" href="/type-theory/2018/02/14/induction-on-identity-types/#5106" class="Bound">a</a> <a id="5158" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a><a id="5162" class="Symbol">)</a>
  <a id="5166" class="Symbol">→</a> <a id="5168" class="Symbol">∀</a> <a id="5170" class="Symbol">(</a><a id="5171" href="/type-theory/2018/02/14/induction-on-identity-types/#5171" class="Bound">y</a> <a id="5173" class="Symbol">:</a> <a id="5175" href="/type-theory/2018/02/14/induction-on-identity-types/#5092" class="Bound">A</a><a id="5176" class="Symbol">)</a> <a id="5178" class="Symbol">(</a><a id="5179" href="/type-theory/2018/02/14/induction-on-identity-types/#5179" class="Bound">p</a> <a id="5181" class="Symbol">:</a> <a id="5183" href="/type-theory/2018/02/14/induction-on-identity-types/#5106" class="Bound">a</a> <a id="5185" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="5187" href="/type-theory/2018/02/14/induction-on-identity-types/#5171" class="Bound">y</a><a id="5188" class="Symbol">)</a> <a id="5190" class="Symbol">→</a> <a id="5192" href="/type-theory/2018/02/14/induction-on-identity-types/#5118" class="Bound">C</a> <a id="5194" href="/type-theory/2018/02/14/induction-on-identity-types/#5171" class="Bound">y</a> <a id="5196" href="/type-theory/2018/02/14/induction-on-identity-types/#5179" class="Bound">p</a>

<a id="5199" href="/type-theory/2018/02/14/induction-on-identity-types/#pi%E2%87%92bpi" class="Function">pi⇒bpi</a> <a id="5206" class="Symbol">{</a><a id="5207" href="/type-theory/2018/02/14/induction-on-identity-types/#5207" class="Bound">A</a><a id="5208" class="Symbol">}</a> <a id="5210" href="/type-theory/2018/02/14/induction-on-identity-types/#5210" class="Bound">a</a> <a id="5212" href="/type-theory/2018/02/14/induction-on-identity-types/#5212" class="Bound">C</a> <a id="5214" href="/type-theory/2018/02/14/induction-on-identity-types/#5214" class="Bound">c</a> <a id="5216" href="/type-theory/2018/02/14/induction-on-identity-types/#5216" class="Bound">y</a> <a id="5218" href="/type-theory/2018/02/14/induction-on-identity-types/#5218" class="Bound">p</a> <a id="5220" class="Symbol">=</a> <a id="5222" href="/type-theory/2018/02/14/induction-on-identity-types/#5395" class="Function">f</a> <a id="5224" href="/type-theory/2018/02/14/induction-on-identity-types/#5210" class="Bound">a</a> <a id="5226" href="/type-theory/2018/02/14/induction-on-identity-types/#5216" class="Bound">y</a> <a id="5228" href="/type-theory/2018/02/14/induction-on-identity-types/#5218" class="Bound">p</a> <a id="5230" href="/type-theory/2018/02/14/induction-on-identity-types/#5212" class="Bound">C</a> <a id="5232" href="/type-theory/2018/02/14/induction-on-identity-types/#5214" class="Bound">c</a>
  <a id="5236" class="Keyword">where</a>
    <a id="5246" href="/type-theory/2018/02/14/induction-on-identity-types/#5246" class="Function">D</a> <a id="5248" class="Symbol">:</a> <a id="5250" class="Symbol">∀</a> <a id="5252" class="Symbol">(</a><a id="5253" href="/type-theory/2018/02/14/induction-on-identity-types/#5253" class="Bound">x</a> <a id="5255" href="/type-theory/2018/02/14/induction-on-identity-types/#5255" class="Bound">y</a> <a id="5257" class="Symbol">:</a> <a id="5259" href="/type-theory/2018/02/14/induction-on-identity-types/#5207" class="Bound">A</a><a id="5260" class="Symbol">)</a> <a id="5262" class="Symbol">→</a> <a id="5264" href="/type-theory/2018/02/14/induction-on-identity-types/#5253" class="Bound">x</a> <a id="5266" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="5268" href="/type-theory/2018/02/14/induction-on-identity-types/#5255" class="Bound">y</a> <a id="5270" class="Symbol">→</a> <a id="5272" class="PrimitiveType">Set₁</a>
    <a id="5281" href="/type-theory/2018/02/14/induction-on-identity-types/#5246" class="Function">D</a> <a id="5283" href="/type-theory/2018/02/14/induction-on-identity-types/#5283" class="Bound">x</a> <a id="5285" href="/type-theory/2018/02/14/induction-on-identity-types/#5285" class="Bound">y</a> <a id="5287" href="/type-theory/2018/02/14/induction-on-identity-types/#5287" class="Bound">p</a> <a id="5289" class="Symbol">=</a> <a id="5291" class="Symbol">(</a><a id="5292" href="/type-theory/2018/02/14/induction-on-identity-types/#5292" class="Bound">L</a> <a id="5294" class="Symbol">:</a> <a id="5296" class="Symbol">(</a><a id="5297" href="/type-theory/2018/02/14/induction-on-identity-types/#5297" class="Bound">z</a> <a id="5299" class="Symbol">:</a> <a id="5301" href="/type-theory/2018/02/14/induction-on-identity-types/#5207" class="Bound">A</a><a id="5302" class="Symbol">)</a> <a id="5304" class="Symbol">→</a> <a id="5306" href="/type-theory/2018/02/14/induction-on-identity-types/#5283" class="Bound">x</a> <a id="5308" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="5310" href="/type-theory/2018/02/14/induction-on-identity-types/#5297" class="Bound">z</a> <a id="5312" class="Symbol">→</a> <a id="5314" class="PrimitiveType">Set</a><a id="5317" class="Symbol">)</a> <a id="5319" class="Symbol">→</a> <a id="5321" href="/type-theory/2018/02/14/induction-on-identity-types/#5292" class="Bound">L</a> <a id="5323" href="/type-theory/2018/02/14/induction-on-identity-types/#5283" class="Bound">x</a> <a id="5325" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a> <a id="5330" class="Symbol">→</a> <a id="5332" href="/type-theory/2018/02/14/induction-on-identity-types/#5292" class="Bound">L</a> <a id="5334" href="/type-theory/2018/02/14/induction-on-identity-types/#5285" class="Bound">y</a> <a id="5336" href="/type-theory/2018/02/14/induction-on-identity-types/#5287" class="Bound">p</a>

    <a id="5343" href="/type-theory/2018/02/14/induction-on-identity-types/#5343" class="Function">d</a> <a id="5345" class="Symbol">:</a> <a id="5347" class="Symbol">∀</a> <a id="5349" class="Symbol">(</a><a id="5350" href="/type-theory/2018/02/14/induction-on-identity-types/#5350" class="Bound">x</a> <a id="5352" class="Symbol">:</a> <a id="5354" href="/type-theory/2018/02/14/induction-on-identity-types/#5207" class="Bound">A</a><a id="5355" class="Symbol">)</a> <a id="5357" class="Symbol">→</a> <a id="5359" href="/type-theory/2018/02/14/induction-on-identity-types/#5246" class="Function">D</a> <a id="5361" href="/type-theory/2018/02/14/induction-on-identity-types/#5350" class="Bound">x</a> <a id="5363" href="/type-theory/2018/02/14/induction-on-identity-types/#5350" class="Bound">x</a> <a id="5365" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_.refl" class="InductiveConstructor">refl</a>
    <a id="5374" href="/type-theory/2018/02/14/induction-on-identity-types/#5343" class="Function">d</a> <a id="5376" class="Symbol">=</a> <a id="5378" class="Symbol">λ</a> <a id="5380" href="/type-theory/2018/02/14/induction-on-identity-types/#5380" class="Bound">x</a> <a id="5382" href="/type-theory/2018/02/14/induction-on-identity-types/#5382" class="Bound">C</a> <a id="5384" href="/type-theory/2018/02/14/induction-on-identity-types/#5384" class="Bound">c</a> <a id="5386" class="Symbol">→</a> <a id="5388" href="/type-theory/2018/02/14/induction-on-identity-types/#5384" class="Bound">c</a>

    <a id="5395" href="/type-theory/2018/02/14/induction-on-identity-types/#5395" class="Function">f</a> <a id="5397" class="Symbol">:</a> <a id="5399" class="Symbol">∀</a> <a id="5401" class="Symbol">(</a><a id="5402" href="/type-theory/2018/02/14/induction-on-identity-types/#5402" class="Bound">x</a> <a id="5404" href="/type-theory/2018/02/14/induction-on-identity-types/#5404" class="Bound">y</a> <a id="5406" class="Symbol">:</a> <a id="5408" href="/type-theory/2018/02/14/induction-on-identity-types/#5207" class="Bound">A</a><a id="5409" class="Symbol">)</a> <a id="5411" class="Symbol">(</a><a id="5412" href="/type-theory/2018/02/14/induction-on-identity-types/#5412" class="Bound">p</a> <a id="5414" class="Symbol">:</a> <a id="5416" href="/type-theory/2018/02/14/induction-on-identity-types/#5402" class="Bound">x</a> <a id="5418" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#_%E2%89%A1_" class="Datatype Operator">≡</a> <a id="5420" href="/type-theory/2018/02/14/induction-on-identity-types/#5404" class="Bound">y</a><a id="5421" class="Symbol">)</a> <a id="5423" class="Symbol">→</a> <a id="5425" href="/type-theory/2018/02/14/induction-on-identity-types/#5246" class="Function">D</a> <a id="5427" href="/type-theory/2018/02/14/induction-on-identity-types/#5402" class="Bound">x</a> <a id="5429" href="/type-theory/2018/02/14/induction-on-identity-types/#5404" class="Bound">y</a> <a id="5431" href="/type-theory/2018/02/14/induction-on-identity-types/#5412" class="Bound">p</a>
    <a id="5437" href="/type-theory/2018/02/14/induction-on-identity-types/#5395" class="Function">f</a> <a id="5439" class="Symbol">=</a> <a id="5441" href="/type-theory/2018/02/14/induction-on-identity-types/#pi" class="Function">pi</a> <a id="5444" href="/type-theory/2018/02/14/induction-on-identity-types/#5246" class="Function">D</a> <a id="5446" href="/type-theory/2018/02/14/induction-on-identity-types/#5343" class="Function">d</a></pre>

<h2 id="references">References</h2>

<ul>
  <li>
    <p><span id="hottbook">Univalent Foundations Program, T. (2013). <i>Homotopy Type Theory: Univalent Foundations of Mathematics</i>. Institute for Advanced Study. Retrieved from http://saunders.phil.cmu.edu/book/hott-online.pdf</span></p>
  </li>
  <li>
    <p><span id="Grayson2017">Grayson, D. R. (2017). An introduction to univalent foundations for mathematicians. Retrieved from http://arxiv.org/abs/1711.01477</span></p>
  </li>
</ul>

  

  <!-- <h2> References </h2> -->
  <ol class="bibliography"></ol>
  <!-- </ -->

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/type-theory/2018/04/08/HoTT-book/">
            HoTT-Book Exercises
            <small>08 Apr 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/type-theory/2018/02/20/equivalences/">
            Equivalences
            <small>20 Feb 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/type-theory/2018/02/16/path-algebra-in-HoTT/">
            Path Algebra in HoTT
            <small>16 Feb 2018</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://jonaprieto-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </div>
      
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    <!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));
     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);
     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');
     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Script which renders TeX using tex.s2cms.ru -->
<script src="//tex.s2cms.ru/latex.js"></script>
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "$$" + tex + "$$";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<p class=\"equation\">" +
                 "$$" + tex + "$$" +
                "</p>";
     });
</script>


    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>

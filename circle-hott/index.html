<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
      
        Circle Equivalences |
      
        jonaprieto
    
  </title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Circle Equivalences" />
<meta name="author" content="Jonathan Prieto-Cubides" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is a work in progress jointly with Marc Bezem. Some of the following proofs are collapsed or hidden to reduce the size of the document. Nevertheless, the reader can click on them to open the full description. Pictures are also clickable." />
<meta property="og:description" content="This is a work in progress jointly with Marc Bezem. Some of the following proofs are collapsed or hidden to reduce the size of the document. Nevertheless, the reader can click on them to open the full description. Pictures are also clickable." />
<link rel="canonical" href="http://jonaprieto.github.io/circle-hott/" />
<meta property="og:url" content="http://jonaprieto.github.io/circle-hott/" />
<meta property="og:site_name" content="jonaprieto" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-01T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"This is a work in progress jointly with Marc Bezem. Some of the following proofs are collapsed or hidden to reduce the size of the document. Nevertheless, the reader can click on them to open the full description. Pictures are also clickable.","author":{"@type":"Person","name":"Jonathan Prieto-Cubides"},"@type":"BlogPosting","url":"http://jonaprieto.github.io/circle-hott/","headline":"Circle Equivalences","dateModified":"2018-11-02T17:25:54+01:00","datePublished":"2018-05-01T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jonaprieto.github.io/circle-hott/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<meta name="description" content="This is a work in progress jointly with Marc Bezem. Some of the following proofs are collapsed or hidden to reduce the size of the document. Nevertheless, th...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="preload" as="script" href="/assets/main.js" >

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">

  <link rel="manifest" href="/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114360791-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114360791-1');
  </script>

  
</head>




  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item" >
    <p style="text-decoration:left">Jonathan Prieto-Cubides</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    <!--  -->
    <!-- 
      
    
      
    
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/all/">All</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/references/">List of references</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/plans/">Plans</a>
        
      
     -->

    <a class="sidebar-nav-item" href="/about/">About</a>
    <!-- <a class="sidebar-nav-item" href="/plans/">Plans</a> -->
    <a class="sidebar-nav-item" href="http://github.com/jonaprieto/jonaprieto.github.io">GitHub</a>
    <!-- <span class="sidebar-nav-item">Currently v0.0.2</span> -->
  </nav>
</div>

    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://github.com/jonaprieto"><img alt="@jonaprieto" class="avatar float-left mr-1" src="https://avatars3.githubusercontent.com/u/1428088?s=40&amp;v=4" height="20" width="20"></a>
            <a href="/" title="Home">jonaprieto</a>
            <small style="text-decoration:left">∷ WorkInProgress</small>
          </h3>
        </div>
      
      <div class="container content">
        






<div class="post">

  <div class="print-version">
    <center>
      <h1>Circle Equivalences </h1><br/>
        <div class="print-authors">
          <div class="print-info">
            <div class="print-author">
              <div class="print-author-name">
                
                  Jonathan Prieto-Cubides
                
              </div>
              <div class="print-author-affiliation">
                
                  University of Bergen
                
                </div>
            </div>
          </div>
          
          <div class="print-info">
            <div class="print-author">
              <div class="print-author-name">Marc Bezem</div>
              
              <div class="print-author-affiliation">University of Bergen</div>
              
            </div>
          </div>
          
        </div>
        <div class="print-date">01 May 2018</div>
        
        
    </center>
  </div>

  
  <div class="main-heading">
    <div class="main-title">
      <div class="main-title-prefix">Latest change:</div>
      <div class="main-commit-message">
            <a href="http://github.com/jonaprieto/jonaprieto.github.io/blob/f42f7d7e18c1724642edd549dfb33f331685c391/blog/_src/notes/2018-05-01-circle-puzzle.lagda.lagda">
              [ bitacora ] Adding lemmas 2 nov</a>
      </div>
    </div>

    <div class="main-last-date">
      Latest commit <a href="http://github.com/jonaprieto/jonaprieto.github.io/blob/f42f7d7e18c1724642edd549dfb33f331685c391/blog/_src/notes/2018-05-01-circle-puzzle.lagda.lagda">f42f7d7e </a> on  02 Nov 2018
    </div>
  </div>
  
  <h1 class="post-title" id="stickyTitle"><svg height="22" class="octicon octicon-bookmark" viewBox="0 0 10 16" version="1.1" width="13" aria-hidden="true"><path fill-rule="evenodd" d="M9 0H1C.27 0 0 .27 0 1v15l5-3.09L10 16V1c0-.73-.27-1-1-1zm-.78 4.25L6.36 5.61l.72 2.16c.06.22-.02.28-.2.17L5 6.6 3.12 7.94c-.19.11-.25.05-.2-.17l.72-2.16-1.86-1.36c-.17-.16-.14-.23.09-.23l2.3-.03.7-2.16h.25l.7 2.16 2.3.03c.23 0 .27.08.09.23h.01z"/></svg> Circle Equivalences
  </h1>
  
  <div class="toc">
    <nav>
    <h2 class="table-of-contents"> Table of Contents </h2>
      <ul>
  <li><a href="#s-type"><code>S¹</code> type</a>
    <ul>
      <li><a href="#definition">Definition</a></li>
      <li><a href="#recursion-principle">Recursion principle</a></li>
      <li><a href="#induction-principle">Induction principle</a></li>
    </ul>
  </li>
  <li><a href="#ps-type"><code>pS</code> type</a>
    <ul>
      <li><a href="#recursion-principle-1">Recursion principle</a></li>
      <li><a href="#induction-principle-1">Induction principle</a></li>
    </ul>
  </li>
  <li><a href="#s--ps"><code>S¹ ≃ pS</code></a>
     -  <a href="#outgoing-functions">Outgoing functions</a>
     -  <a href="#f--g--id"><code>f ∘ g ~ id</code></a>
     -  <a href="#g--f--id">g ∘ f ~ id</a></li>
  <li><a href="#Σ-s-p--ps"><code>Σ S¹ P ≃ pS</code></a>
    <ul>
      <li><a href="#f--Σ-s-p--ps"><code>f : Σ S¹ P → pS</code></a></li>
      <li><a href="#g--ps--Σ-s-p"><code>g : pS → Σ S¹ P</code></a></li>
      <li><a href="#f--g--id-1"><code>f ∘ g ∼ id</code></a></li>
      <li><a href="#g--f--id-1"><code>g ∘ f ∼ id</code></a></li>
    </ul>
  </li>
</ul>

    </nav>
  </div>
  

  <noscript>
  <h6>You need to turn on Javascript to see the content of this entry correctly.<h6><br/>
  </noscript>

  <p class="only-website"><em>This is a work in progress jointly with Marc Bezem. Some of
  the following proofs are collapsed or hidden to reduce the size of the document.
  Nevertheless, the reader can click on them to open the full description.
  Pictures are also clickable.</em></p>

<p>In this entry, we want to show some equivalences
between the circle and other higher inductive types.</p>

<p>\begin{code}
{-# OPTIONS –without-K #-}
open import Agda.Primitive using ( Level ; lsuc; lzero; <em>⊔</em> )</p>

<p>open import 2018-07-06-mini-hott
module _ where
\end{code}</p>

<h2 id="s-type"><code>S¹</code> type</h2>

<p>The circle is the higher inductive type with one point and one no trivial path
called <em>path</em> as we can see in the following picture.</p>

<p><img src="/assets/ipe-images/circle.png" alt="path" width="40%" />
<em>Figure 1. The circle type <code>S¹</code>.</em></p>

<h3 id="definition">Definition</h3>

<p>\begin{code}
– Definition of the Circle S¹ using an Agda hack.
module _ where
  private
    data !S¹ : Type₀ where
      !base : !S¹</p>

<p>S¹ : Type₀
  S¹ = !S¹</p>

<p>base : S¹
  base = !base</p>

<p>– Nontrivial path on the circle.
  postulate
    loop : base == base
\end{code}</p>

<p class="foldable" until="0">\begin{code}
  – Def. loop^2
  _²
    : ∀ {ℓ} {A : Type ℓ} {a : A}
    → a == a
    ——–
    → a == a</p>

<p>p ² = p · p
\end{code}</p>

<h3 id="recursion-principle">Recursion principle</h3>

<p>Recursion principle on points:</p>

<p>\begin{code}
  – Def.
  S¹-rec
    : ∀ {ℓ}
    → (A : Type ℓ)
    → (a : A)
    → (p : a == a)
    ————–
    → (S¹ → A)</p>

<p>S¹-rec A a p !base = a
\end{code}</p>

<p>Recursion on paths:</p>

<p>\begin{code}
  – Postulate.
  postulate
    S¹-βrec
      : ∀ {ℓ}
      → (A : Type ℓ)
      → (a : A)
      → (p : a == a)
      —————————–
      → ap (S¹-rec A a p) loop == p
\end{code}</p>

<h3 id="induction-principle">Induction principle</h3>

<p>Induction principle on points:</p>

<p>\begin{code}
  – Def.
  S¹-ind
    : ∀ {ℓ} (P : S¹ → Type ℓ)
    → (x : P base)
    → (x == x [ P ↓ loop ])
    ————————
    → ((t : S¹) → P t)</p>

<p>S¹-ind P x p !base = x
\end{code}</p>

<p>Induction principle on paths:</p>

<p>\begin{code}
  – Postulate.
  postulate
    S¹-βind
      : ∀ {ℓ} (P : S¹ → Type ℓ)
      → (x : P base)
      → (p : x == x [ P ↓ loop ])
      ——————————-
      → apd (S¹-ind P x p) loop == p
\end{code}</p>

<h2 id="ps-type"><code>pS</code> type</h2>

<p>The <code>pS</code> type as the figure below shows, it is a circle with two edges
in opposite direction between two points. Notice this HIT is just different
form the suspension of booleans (Σ 2) by reversing one arrow.</p>

<p><img src="/assets/ipe-images/tour-type.png" alt="path" width="40%" />
<em>Figure 2. <code>pS</code> Type.</em></p>

<p>\begin{code}
– Definition of pS type using an Agda hack.
module _ where
  private
    data #!pS : Type lzero where
      #!pS₀ : #!pS
      #!pS₁ : #!pS</p>

<pre><code>data !pS : Type lzero where
  !ps : #!pS → (Unit → Unit) → !pS
</code></pre>

<p>pS : Type₀
  pS = !pS</p>

<p>pS₀ : pS
  pS₀ = !ps #!pS₀ _</p>

<p>pS₁ : pS
  pS₁ = !ps #!pS₁ _</p>

<p>postulate
    p₀₁ : pS₀ == pS₁
    p₁₀ : pS₁ == pS₀
\end{code}</p>

<h3 id="recursion-principle-1">Recursion principle</h3>

<p>Recursion principle on points:</p>

<p>\begin{code}
  – Def.
  pS-rec
    : (C : Type₀)
    → (c₀ c₁ : C)
    → (p₀₁’  : c₀ == c₁)
    → (p₁₀’  : c₁ == c₀)
    ——————–
    → (pS → C)</p>

<p>pS-rec C c₀ c₁ p₀₁’ p₁₀’ (!ps #!pS₀ x₁) = c₀
  pS-rec C c₀ c₁ p₀₁’ p₁₀’ (!ps #!pS₁ x₁) = c₁
\end{code}</p>

<p>Recursion principle on paths:</p>

<p>\begin{code}
  – Postulate.
  postulate
    pS-βrec₀₁
      : (C : Type₀)
      → (c₀ c₁ : C)
      → (p₀₁’  : c₀ == c₁)
      → (p₁₀’  : c₁ == c₀)
      ——————————————-
      → ap (pS-rec C c₀ c₁ p₀₁’ p₁₀’) p₀₁ == p₀₁’</p>

<pre><code>pS-βrec₁₀
  : (C : Type₀)
  → (c₀ c₁ : C)
  → (p₀₁'  : c₀ == c₁)
  → (p₁₀'  : c₁ == c₀)
  --------------------------------------------
  →  ap (pS-rec C c₀ c₁ p₀₁' p₁₀') p₁₀ == p₁₀' \end{code}
</code></pre>

<h3 id="induction-principle-1">Induction principle</h3>

<p>Induction principle on points:</p>

<p>\begin{code}
  – Def.
  pS-ind
    : ∀ {ℓ} (C : pS → Type ℓ)
    → (c₀ : C pS₀)
    → (c₁ : C pS₁)
    → (q₁ : c₀ == c₁ [ C ↓ p₀₁ ])
    → (q₂ : c₁ == c₀ [ C ↓ p₁₀ ])
    —————————–
    → ((t : pS) → C t)</p>

<p>pS-ind C c₀ c₁ q₁ q₂ (!ps #!pS₀ x₁) = c₀
  pS-ind C c₀ c₁ q₁ q₂ (!ps #!pS₁ x₁) = c₁
\end{code}</p>

<p>Induction principle on paths:</p>

<p>\begin{code}
  – Postulate.
  postulate
    pS-βind₀₁
      : ∀ {ℓ} (C : pS → Type ℓ)
      → (c₀   : C pS₀)
      → (c₁   : C pS₁)
      → (p₀₁’ : c₀ == c₁ [ C ↓ p₀₁ ])
      → (p₁₀’ : c₁ == c₀ [ C ↓ p₁₀ ])
      → ((t : pS) → C t)
      ——————————————–
      → apd (pS-ind C c₀ c₁ p₀₁’ p₁₀’) p₀₁ == p₀₁’</p>

<pre><code>pS-βind₁₀
  : ∀ {ℓ} (C : pS → Type ℓ)
  → (c₀   : C pS₀)
  → (c₁   : C pS₁)
  → (p₀₁' : c₀ == c₁ [ C ↓ p₀₁ ])
  → (p₁₀' : c₁ == c₀ [ C ↓ p₁₀ ])
  → ((t : pS) → C t)
  -------------------------------------------
  → apd (pS-ind C c₀ c₁ p₀₁' p₁₀') p₁₀ == p₁₀' \end{code}
</code></pre>

<h2 id="s--ps"><code>S¹ ≃ pS</code></h2>

<p><strong>Lemma 1</strong> . <script type="math/tex">\mathsf{S}^{1} \simeq \mathsf{pS}.</script></p>

<p><strong>Proof</strong>. We proceed as usual. Defining the outgoing functions and proving
the homotopies. We prove the equivalence by quasiinverse equivalence.</p>

<p>For this equivalence, we need to find a proper candidate to correspond
with the <code>loop</code> path of <code>S¹</code>. Our propose is <code>p₀₀</code>, the path <code>p₀₁ · p₁₀</code>.
This choice makes sense because
<code>p₀₀</code> suggests a loop, closing the circuit with the arrows.</p>

<p>\begin{code}
p₀₀ : pS₀ == pS₀
p₀₀ = p₀₁ · p₁₀
\end{code}</p>

<h4 id="outgoing-functions">Outgoing functions</h4>

<p>We define the function <code>f</code> that goes from <code>S¹</code> to <code>pS</code> type.
Which it means we need to use the recursion principle of the circle.
We map <code>base</code> to <code>pS₀</code> and the action on <code>loop</code> to
<code>(tr (λ p → pS₀ == pS₀) loop p₀₀)</code>.</p>

<p>\begin{code}
module Lemma₁ where</p>

<p>private
    f : S¹ → pS
    f = S¹-rec pS pS₀ (tr (λ p → pS₀ == pS₀) loop p₀₀)
\end{code}</p>

<p>For the inverse function of <code>f</code> we have <code>g</code> which goes from <code>pS</code> to <code>S¹</code>. <code>g</code> is
defined by the recursion principle of <code>pS</code> type. The correspondence in this case
maps all the points to <code>base</code> in S¹, and the arrows <code>p₀₁</code> and <code>p₁₀</code> to <code>loop ²</code>
and <code>loop ⁻¹</code> respectively. The reason for these last choices is because their
concatenation gives a <code>loop</code> which is exactly the correspondence that we want to
have. Another possible choices would be if we take instead <code>loop</code> and <code>refl
base</code> but that would give us a different proof and <code>p₀₀</code> could be something
else.</p>

<p>\begin{code}
  – Inverse
    g : pS → S¹
    g = pS-rec S¹ base base (loop ²) (loop ⁻¹)
\end{code}</p>

<p>Now, let’s prove the respective homotopies to show the equivalence.</p>

<h4 id="f--g--id"><code>f ∘ g ~ id</code></h4>

<p>To prove the homotopy <script type="math/tex">f ∘ g \sim \mathsf{id}</script>, we also need recursion
principle of <code>pS</code> type as it follows.</p>

<ul>
  <li>Case <code>pS₁</code>:</li>
</ul>

<p>\begin{code}
  – Def.
  q₁ : f (g pS₁) == pS₁
  q₁ = ! p₀₀ · ! p₀₀ · p₀₁
\end{code}</p>

<p>Case on paths:</p>

<p class="foldable" until="2">\begin{code}
  – Def.
  dpath₀ :  refl pS₀ == q₁ [ (λ z → (f ∘ g) z == id z) ↓ p₀₁ ]
  dpath₀ =
    begin
      transport (λ z → (f ∘ g) z == id z) p₀₁ idp
        ==⟨ transport-eq-fun (f ∘ g) id p₀₁ idp ⟩
      ! ap (f ∘ g) p₀₁ · idp · ap id p₀₁
        ==⟨ ·-assoc _ idp (ap id p₀₁) ⟩
      ! ap (f ∘ g) p₀₁ · (idp · ap id p₀₁)
        ==⟨ ap (λ r → ! ap (f ∘ g) p₀₁ · r) (·-lunit (ap id p₀₁)) ⟩
      ! ap (f ∘ g) p₀₁  · (ap id p₀₁)
        ==⟨ ap (λ r → ! ap (f ∘ g) p₀₁ · r) (ap-id p₀₁) ⟩
      ! ap (f ∘ g) p₀₁ · p₀₁
        ==⟨ ap (λ r → ! r · p₀₁) (! (ap-comp g f p₀₁)) ⟩
      ! ap f (ap g p₀₁) · p₀₁
        ==⟨ ap (λ r → ! ap f r · p₀₁) (pS-βrec₀₁ S¹ base base (loop · loop) idp) ⟩
      ! ap f (loop ²) · p₀₁
        ==⟨ ap (λ r → ! r · p₀₁) (ap-· f loop loop) ⟩
      ! (ap f loop · ap f loop) · p₀₁
        ==⟨ ap (λ r → ! (r · ap f loop) · p₀₁)
          (S¹-βrec pS pS₀ (transport (λ _ → pS₀ == pS₀) loop p₀₀)) ⟩
      ! (transport (λ p → pS₀ == pS₀) loop p₀₀ · ap f loop) · p₀₁
        ==⟨ ap (λ r → ! (r · ap f loop) · p₀₁) (transport-const loop p₀₀) ⟩
      ! (p₀₀ · ap f loop) · p₀₁
        ==⟨ ap (λ r → ! (p₀₀ · r) · p₀₁)
               (S¹-βrec pS pS₀ (transport (λ _ → pS₀ == pS₀) loop p₀₀)) ⟩
      ! (p₀₀ · transport (λ p → pS₀ == pS₀) loop p₀₀) · p₀₁
        ==⟨ ap (λ r → ! (p₀₀ · r) · p₀₁)(transport-const loop p₀₀) ⟩
      ! (p₀₀ · p₀₀) · p₀₁
        ==⟨ ap (_· p₀₁) (!-· p₀₀ p₀₀) ⟩
      q₁
    ∎
\end{code}</p>

<p class="foldable" until="2">\begin{code}
  – Def.
  dpath₁ : q₁ == refl pS₀ [ (λ z → (f ∘ g) z == id z) ↓ p₁₀ ]
  dpath₁ =
    begin
      transport  (λ z → (f ∘ g) z == id z) p₁₀ q₁
        ==⟨ transport-eq-fun (f ∘ g) id p₁₀ q₁ ⟩
      ! ap (f ∘ g) p₁₀ · q₁ · ap id p₁₀
        ==⟨ ap (λ r → ! ap (f ∘ g) p₁₀ · q₁ · r) (ap-id p₁₀) ⟩
      ! ap (f ∘ g) p₁₀ · q₁ · p₁₀
        ==⟨ ap (λ r → ! r · q₁ · p₁₀) (! (ap-comp g f p₁₀)) ⟩
      ! ap f (ap g p₁₀) · q₁ · p₁₀
        ==⟨ ap (λ r → ! ap f r · q₁ · p₁₀) (pS-βrec₁₀ S¹ base base idp (! loop)) ⟩
      ! ap f (! loop) · q₁ · p₁₀
        ==⟨ ap (λ r → ! r · q₁ · p₁₀) (ap-inv f loop) ⟩
      (! ! ap f loop) · q₁ · p₁₀
        ==⟨ ap (λ r → r · q₁ · p₁₀) (involution {p = ap f loop}) ⟩
      ap f loop · q₁ · p₁₀
        ==⟨ ap (λ r → r · q₁ · p₁₀)
               (S¹-βrec pS pS₀
               (transport (λ _ → pS₀ == pS₀) loop (p₀₁ · p₁₀))) ⟩
      (transport (λ p → pS₀ == pS₀) loop p₀₀) · q₁ · p₁₀
        ==⟨ ap (λ r → r · q₁ · p₁₀) (transport-const loop p₀₀) ⟩
      p₀₀ · q₁ · p₁₀
        ==⟨ idp ⟩
      p₀₀ · (! p₀₀ · ! p₀₀ · p₀₁) · p₁₀
        ==⟨ ap (λ r → p₀₀ · r · p₁₀) (·-assoc (! p₀₀) (! p₀₀) p₀₁) ⟩
      p₀₀ · (! p₀₀ · (! p₀₀ · p₀₁)) · p₁₀
        ==⟨ ap (λ r → r · p₁₀) (! (·-assoc p₀₀ (! p₀₀) (! p₀₀ · p₀₁))) ⟩
      (p₀₀ · ! p₀₀ ) · (! p₀₀ · p₀₁) · p₁₀
        ==⟨ ap (λ r → r · (! p₀₀ · p₀₁) · p₁₀)  (·-rinv p₀₀) ⟩
      idp · (! p₀₀ · p₀₁) · p₁₀
        ==⟨ ap (_· p₁₀) ( ! ·-lunit ((! p₀₀ · p₀₁))) ⟩
      (! p₀₀ · p₀₁) · p₁₀
        ==⟨ ·-assoc (! p₀₀) p₀₁ p₁₀ ⟩
      ! p₀₀ · (p₀₁ · p₁₀)
        ==⟨⟩
      ! p₀₀ · p₀₀
        ==⟨ ·-linv p₀₀ ⟩
      idp
        ==⟨⟩
      refl pS₀
    ∎
\end{code}</p>

<p>Finally, by path induction on <code>pS</code> type, we got the homotopy.</p>

<p>\begin{code}
  – Homotopy.
  H₁ : f ∘ g ∼ id
  H₁ = pS-ind _ (refl pS₀) q₁ dpath₀ dpath₁
\end{code}</p>

<h4 id="g--f--id">g ∘ f ~ id</h4>

<p>To prove the homotopy <script type="math/tex">g ∘ f \sim \mathsf{id}</script>, we proceed by induction on
the circle. For the <code>base</code> case, <code>refl base</code> works since <code>g (f base)</code> is
definitionally equal to <code>base</code>.</p>

<p>\begin{code}
  – Def.
  H₂-base : g (f base) == base
  H₂-base = refl base
\end{code}</p>

<p>Action on <code>loop</code> case:</p>

<p class="foldable" until="2">\begin{code}
  – Def.
  H₂-loop : refl base == refl base [ (λ z → (g ∘ f) z == id z) ↓ loop ]
  H₂-loop =
    (begin
      transport (λ z → (g ∘ f) z == id z) loop idp
        ==⟨ transport-eq-fun (g ∘ f) id loop idp ⟩
      ! (ap (g ∘ f) loop) · idp · ap id loop
        ==⟨ ap (λ r → ! (ap (g ∘ f) loop) · idp · r) (ap-id loop) ⟩
      ! (ap (g ∘ f) loop) · idp · loop
        ==⟨ ·-assoc _ idp loop ⟩
      ! (ap (g ∘ f) loop) · (idp · loop)
        ==⟨ ap (λ r → ! (ap (g ∘ f) loop) · r) (·-lunit loop) ⟩
      ! (ap (g ∘ f) loop) · loop
        ==⟨ ap  (λ r → ! r · loop) (! (ap-comp f g loop)) ⟩
      ! ap g (ap f loop) · loop
        ==⟨ ap {A = pS₀ == pS₀} (λ r → ( ! (ap g r)) · loop)
                                (S¹-βrec pS pS₀ <em>) ⟩
      ! ap g (transport (λ p → pS₀ == pS₀) loop p₀₀) · loop
        ==⟨ ap {A = pS₀ == pS₀} (λ r → ! ap g r · loop)
                (transport-const loop p₀₀) ⟩
      ! ap g p₀₀ · loop
        ==⟨ ap (λ r → ! r · loop)  (ap-· g p₀₁ p₁₀) ⟩
      ! (ap g p₀₁ · ap g p₁₀) · loop
        ==⟨ ap {A = base == base} (λ r → ! (r · ap g p₁₀) · loop)
               (pS-βrec₀₁ S¹ base base (loop · loop) idp) ⟩
      ! ((loop ²) · ap g p₁₀) · loop
        ==⟨ ap {A = base == base} (λ r → ! ( loop · loop · r) · loop)
               (pS-βrec₁₀ S¹ base base idp (inv loop)) ⟩
      ! ((loop ²) · ! loop) · loop
        ==⟨ ap (λ r →  ! r · loop) aux-path ⟩
      ! loop · loop
        ==⟨ ·-linv loop ⟩
       idp
    ∎)
    where
      aux-path : (loop ²) · (loop ⁻¹) == loop
      aux-path =
        begin
          (loop ²) · (loop ⁻¹)
            ==⟨ ·-assoc loop loop (! loop) ⟩
          loop · (loop · ! loop)
            ==⟨ ap (loop ·</em>) (·-rinv loop) ⟩
          loop · idp
            ==⟨ ! (·-runit loop) ⟩
          loop
        ∎
\end{code}</p>

<p>\begin{code}
  – Homotopy
  H₂ : g ∘ f ∼ id
  H₂ = S¹-ind _ H₂-base H₂-loop
\end{code}</p>

<p>Now, everything we needed to prove the equivalence is
and the equivalence is by quasiinverse equivalence.</p>

<p>\begin{code}
  – Equivalence.
  S¹-≃-pS : S¹ ≃ pS
  S¹-≃-pS = qinv-≃ f (g , H₁ , H₂)
\end{code}</p>

<h2 id="Σ-s-p--ps"><code>Σ S¹ P ≃ pS</code></h2>

<p><strong>Lemma 3.</strong> <script type="math/tex">\Sigma~S^{1}~P~\simeq~pS</script> where
<script type="math/tex">P (\mathsf{base}) :≡ \mathsf{Bool}</script> and <script type="math/tex">\mathsf{ap~P~loop~=~ua~(neg)}</script>.</p>

<p><code>P</code> is a type family defined by the recursion principle of the circle.
When it is the <code>base</code> case, <code>P base</code> is definitionally equal to the booleans <code>Bool</code>.
When <code>P</code> is acting on <code>loop</code>, a path of type <code>Bool == Bool</code> is given
by Univalence Axiom and the equivalence <code>neg</code>, the negation function for booleans.</p>

<p><img src="/assets/ipe-images/Bid.png" alt="path" width="40%" />
<em>Figure 3. <code>P</code> type family.</em></p>

<p>Let’s define this type family formally.</p>

<p>\begin{code}
module Lemma₃ where</p>

<p>– Def.
  neg : Bool → Bool
  neg true  = false
  neg false = true</p>

<p>– Equiv.
  neg-eq : Bool ≃ Bool
  neg-eq = qinv-≃ neg (neg , h , h)
    where
      h : neg ∘ neg ∼ id
      h true  = idp
      h false = idp
\end{code}</p>

<p>The type family <code>P : S¹ → Type₀</code>.</p>

<p>\begin{code}
  – Def
  P : S¹ → Type₀
  P = S¹-rec Type₀ Bool (ua neg-eq)
\end{code}</p>

<p>As we saw in the Fig. 3, the paths <code>γ₀₁</code> and <code>γ₁₀</code> are defined as pathovers.</p>

<p>\begin{code}
  – Defs.
  γ₀₁ : tr P loop false == true
  γ₀₁ = transport-ua P loop neg-eq (S¹-βrec Type₀ Bool (ua neg-eq)) false</p>

<p>γ₁₀ : tr P loop true == false
  γ₁₀ = transport-ua P loop neg-eq (S¹-βrec Type₀ Bool (ua neg-eq)) true
\end{code}</p>

<p><strong>Proof.</strong> We proceed as usual to show the equivalence.
We define the outgoing functions <code>f : Σ S¹ P → pS</code>, <code>g : pS → Σ S¹ P</code>
and the homotopies <code>f ∘ g ~ id</code> and <code>g ∘ f ∼ id</code>. Let’s start defining
the function <code>f</code>.</p>

<h3 id="f--Σ-s-p--ps"><code>f : Σ S¹ P → pS</code></h3>

<p>To define <code>f</code> we need to use the recursor principle of Sigma types which gives a
pair <code>(b , x)</code> in order to provide a definition for the uncurried version of
<code>f</code>, <code>f̰ : (b : S¹) → P b → pS</code>. Since <code>f̰</code> is a dependent function, we define
it using induction principle on the circle. In this case, we maps <code>base</code> to <code>ct</code>
and <code>p̰</code> as evidence of the pathover of <code>ct</code> and <code>ct</code> along the <code>loop</code> in the
family <code>(λ z → P z → pS)</code>.</p>

<p>\begin{code}
  – Def.
  ct : P base → pS
  ct true  = pS₁
  ct false = pS₀
\end{code}</p>

<p class="foldable" until="2">\begin{code}
  – Def.
  p̰ : ct == ct [ (λ z → P z → pS) ↓ loop ]
  p̰ =
    (begin
      transport (λ z → P z → pS) loop ct
        ==⟨ transport-fun loop ct ⟩
      (λ (x : P base) → transport (λ z → pS) loop
                          (ct (transport (λ z → P z) (! loop) x)))
        ==⟨ funext (λ (pb : P base) → transport-const loop
                          (ct (transport (λ z → P z) (! loop) pb))) ⟩
      (λ (x : P base) → (ct (transport (λ z → P z) (! loop) x)))
        ==⟨ funext (λ (pb : P base) → ap ct (helper₁ pb)) ⟩
      (λ (x : P base) → ct (neg x) )
        ==⟨ funext helper₂ ⟩
      ct
     ∎)
     where
       helper₁ : (x : P base) → x == neg x [ P ↓ ! loop ]
       helper₁ x =
         let
           apP!loop :  ap P (! loop) == ua (invEqv neg-eq)
           apP!loop =
             begin
               ap P (! loop)
                 ==⟨ ap-inv P loop ⟩
               ! ap P loop
                 ==⟨ ap (!_) (S¹-βrec Type₀ Bool (ua (neg-eq))) ⟩
               ! ua (neg-eq)
                 ==⟨ ! (ua-inv neg-eq) ⟩
               ua (invEqv neg-eq)
             ∎
         in
         begin
           transport P (! loop) x
             ==⟨ transport-ua P (! loop) (invEqv neg-eq) apP!loop x ⟩
           fun≃ (invEqv (neg-eq)) x
             ==⟨⟩
           fun≃ (neg-eq) x
             ==⟨⟩
           neg x
         ∎</p>

<pre><code>   helper₂ : (x : P base) → ct (neg x) == ct x
   helper₂ true  = p₀₁
   helper₂ false = p₁₀ \end{code}
</code></pre>

<p>\begin{code}
  – Def.
  f̰ : (b : S¹) → P b → pS
  f̰ = S¹-ind (λ z → P z → pS) ct p̰
\end{code}</p>

<p>\begin{code}
  – Def.
  f :  Σ S¹ P → pS
  f (b , x) = f̰ b x
\end{code}</p>

<h3 id="g--ps--Σ-s-p"><code>g : pS → Σ S¹ P</code></h3>

<p>We define <code>g</code> as the inverse function of <code>f</code> by recursion on <code>pS</code> type. Since
<code>pS</code> and <code>Σ S¹ P</code> both have two points, two arrows and their graphs are actually
isomorphic, <code>g</code> entitled such a correspond as it is expected. <code>false</code> maps to
<code>(base , false)</code>, <code>true</code> maps to <code>(base, true)</code>. For the paths, the subindexes will suggest
the correspondence: <code>p₀₁</code> maps to <code>(base , false) == (base , true )</code>, and <code>p₁₀</code> maps to
<code>(base , true) == (base, false)</code>. For these last paths, we use
Theorem 2.9.7 in <a href="#hottbook">(Univalent Foundations Program, 2013)</a> to get the respective dependent pair equalities, this is
by using the <code>pair=</code> function.</p>

<p>\begin{code}
– Def.
  ctp : P base → Σ S¹ P
  ctp b = base , b</p>

<p>ptp : (y : P base) → ctp y == ctp (neg y)
  ptp false = pair= (loop , γ₀₁)
  ptp true  = pair= (loop , γ₁₀)</p>

<p>g : pS → Σ S¹ P
  g = pS-rec (Σ S¹ P)
            (ctp false)  – false ↦ (base , false)
            (ctp true)   – true ↦ (base , true)
            (ptp false)  – p₀₁ ↦ (base , false) = (base , true)
            (ptp true)   – p₁₀ ↦ (base , true ) = (base , false)
\end{code}</p>

<h3 id="f--g--id-1"><code>f ∘ g ∼ id</code></h3>

<p>To show that this homotopy holds, we proceed by induction principle of <code>pS</code>
type. This means we need to show the identity types <code>(f ∘ g) pS₀ == id pS₀</code> and
<code>(f ∘ g) pS₁ == id pS₁</code> are inhabited but also the pathovers along <code>p₀₁</code> and
<code>p₁₀</code> respectively. These are the terms <code>q₀</code>, <code>q₁</code>, <code>pover₁</code>, and <code>pover₂</code> in
the following. To define <code>pover₁</code> and <code>pover₂</code> we need the following lemmas
based on Lemma 6.12.8 in (missing reference) and postulated here because of its
complexity.</p>

<p>\begin{code}
  – Lemma 6.12.8
  postulate
    lemma-ap-f-γ₀₁ : ap f (ptp false) == p₀₁
    lemma-ap-f-γ₁₀ : ap f (ptp true) == p₁₀
\end{code}</p>

<p>\begin{code}
  – Def.
  q₀ : (f ∘ g) pS₀ == id pS₀
  q₀ = p₀₁ · p₁₀
\end{code}</p>

<p>\begin{code}
  – Def.
  q₁ : (f ∘ g) pS₁ == id pS₁
  q₁ = p₁₀ · p₀₁
\end{code}</p>

<p class="foldable" until="2">\begin{code}
  – Def.
  pover₁ : q₀ == q₁ [ (λ z → (f ∘ g) z == id z) ↓ p₀₁ ]
  pover₁ =
    (begin
      transport (λ z → (f ∘ g) z == id z) p₀₁ q₀
        ==⟨ transport-eq-fun (f ∘ g) id p₀₁ q₀ ⟩
      ! ap (f ∘ g) p₀₁ · q₀ · ap id p₀₁
        ==⟨ ap (! ap (f ∘ g) p₀₁ · q₀ ·<em>) (ap-id p₀₁) ⟩
      ! ap (f ∘ g) p₀₁ · q₀ · p₀₁
        ==⟨ ap (λ r → ! r · q₀ · p₀₁) (! ap-comp g f p₀₁) ⟩
      ! ap f (ap g p₀₁) · q₀ · p₀₁
        ==⟨ ap (λ r → ! ap f r · q₀ · p₀₁) (pS-βrec₀₁ (Σ S¹ (λ b → P b)) (ctp false) (ctp true) (ptp false) (ptp true)) ⟩
      ! ap f (ptp false) · q₀ · p₀₁
        ==⟨ ap (λ r → ! r · q₀ · p₀₁) lemma-ap-f-γ₀₁ ⟩
      ! p₀₁ · q₀ · p₀₁
        ==⟨ idp ⟩
      ! p₀₁ · (p₀₁ · p₁₀) · p₀₁
        ==⟨ ! (·-assoc (! p₀₁) p₀₁ p₁₀) |in-ctx (</em>· p₀₁) ⟩
      (! p₀₁ · p₀₁) · p₁₀ · p₀₁
        ==⟨ ·-linv p₀₁ |in-ctx (λ r → r · p₁₀ · p₀₁) ⟩
      idp · p₁₀ · p₀₁
        ==⟨⟩
      q₁
    ∎)
\end{code}</p>

<p class="foldable" until="2">\begin{code}
  – Def.
  pover₂ : q₁ == q₀ [ (λ z → (f ∘ g) z == id z) ↓ p₁₀ ]</p>

<p>pover₂ =
    (begin
      transport (λ z → (f ∘ g) z == id z) p₁₀ q₁
        ==⟨ transport-eq-fun (f ∘ g) id p₁₀ q₁ ⟩
      ! ap (f ∘ g) p₁₀ · q₁ · ap id p₁₀
        ==⟨ ap (! ap (f ∘ g) p₁₀ · q₁ ·<em>) (ap-id p₁₀) ⟩
      ! ap (f ∘ g) p₁₀ · q₁ · p₁₀
        ==⟨ ap (λ r → ! r · q₁ · p₁₀) (! ap-comp g f p₁₀) ⟩
      ! ap f (ap g p₁₀) · q₁ · p₁₀
        ==⟨ ap (λ r → ! ap f r · q₁ · p₁₀)
               (pS-βrec₁₀ (Σ S¹ (λ b → P b)) (ctp false) (ctp true) (ptp false) (ptp true)) ⟩
      ! ap f (ptp true) · q₁ · p₁₀
        ==⟨ ap (λ r → ! r · q₁ · p₁₀) lemma-ap-f-γ₁₀ ⟩
      ! p₁₀ · q₁ · p₁₀
        ==⟨⟩
      ! p₁₀ · (p₁₀ · p₀₁) · p₁₀
        ==⟨ ! (·-assoc (! p₁₀) p₁₀ p₀₁) |in-ctx (</em>· p₁₀) ⟩
      (! p₁₀ · p₁₀) · p₀₁ · p₁₀
        ==⟨ ·-linv p₁₀ |in-ctx (λ r → r · p₀₁ · p₁₀) ⟩
      idp ·  p₀₁ · p₁₀
        ==⟨⟩
      q₀
    ∎)
\end{code}</p>

<p>Finally, our homotopy holds:</p>

<p>\begin{code}
  – Homotopy
  f-g : f ∘ g ∼ id
  f-g = pS-ind (λ ps → (f ∘ g) ps == id ps) q₀ q₁ pover₁ pover₂
\end{code}</p>

<h3 id="g--f--id-1"><code>g ∘ f ∼ id</code></h3>

<p>This homotopy is a very more complex. To show that for all <code>x : S¹</code> it holds <code>g
(f x) == id x</code> we must proceed by induction three times. We perform this in the
following order: Sigma induction, Circle induction and <code>pS</code> induction.</p>

<p>Since the last two cases are induction on HITs, these inductions take into
account the action on their path constructors. We have taken inspiration to
finish this proof from Flattening lemma’s proof in Section 6 in <a href="#hottbook">(Univalent Foundations Program, 2013)</a>.</p>

<p>By Sigma induction, we must to provide the uncurried function <code>g-f'</code> of <code>g-f : g
∘ f ∼ id</code>, that has type <code>Π (s : S¹) Π (b : P s).(g ∘ f) (s , b) == id (s , b)</code>.
Therefore, the next step is by induction on the circle. For the <code>base</code> case we
have <code>c</code> defined as fallows. For acting on paths, we define a short name <code>Q</code> for
the type family <code>λ z → (b : P z) → (g ∘ f) (z , b) == id (z , b)</code> in order to
get a pathover between <code>c</code> and itself along <code>loop</code> in the type family <code>Q</code>, this
path is <code>cpath</code>.  To define <code>cpath</code> we require a few auxiliary lemmas that
an interested reader can make them explicit by clicking on the helpers section
below. The equivalence follows by showing that <code>f</code> defines a quasiinverse
equivalence (<code>ΣS¹P-≃-pS</code>).</p>

<p>\begin{code}
  – Def.
  c : (b : P base) → (g ∘ f) (base , b) == id (base , b)
  c true  = refl (base , true)
  c false = refl (base , false)
\end{code}</p>

<p>\begin{code}
  – Def.
  Q : (s : S¹) → Type lzero
  Q = λ z → (b : P z) → (g ∘ f) (z , b) == id (z , b)
\end{code}</p>

<p class="foldable" until="1">\begin{code}
  – Helpers and auxiliar lemmas</p>

<p>– Def.
  auxAP : ∀ {x y : P base}{p : base == base}
      → (q : tr (λ x → P x) p x == y)
      →  ap (λ w → ctp w ) q == pair= (refl base , q)</p>

<p>auxAP idp = idp</p>

<p>stepFalse1
    : ∀ {x y : P base}
    → (q : tr (λ x → P x) loop x == y)
    → pair= (loop , refl (tr (λ z → P z) loop x)) · pair= (refl base , q) == pair= (loop , q)</p>

<p>stepFalse1 {x = x} idp =
    begin
        pair= (loop , refl (tr (λ z → P z) loop x)) · pair= (refl base , idp)
    ==⟨ idp ⟩
        pair= (loop , refl (tr (λ z → P z) loop x)) · idp
    ==⟨ ! ·-runit (pair= (loop , refl (tr P loop x))) ⟩
        pair= (loop , refl (tr (λ z → P z) loop x))
    ==⟨ idp ⟩
        pair= (loop , idp)
    ∎</p>

<p>stepFalse2
    : c (tr (λ x → P x) loop false)
      == tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₀₁)) (c (neg false))</p>

<p>stepFalse2 = begin
    c (tr (λ x → P x) loop false)
      ==⟨ ! (apd (λ x → c x) (! γ₀₁)) ⟩
    tr (λ b → (g ∘ f) (base , b) == id (base , b)) (! γ₀₁) (c (neg false))
      ==⟨ transport-family (! γ₀₁) (c (neg false)) ⟩
    tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₀₁)) (c (neg false))
    ∎</p>

<p>– Def.
  p : (b : P base) → tr (λ w → (g ∘ f) w == id w) (ptp b) (c b) == c (neg b)</p>

<p>p true  =
    begin
      tr (λ w → (g ∘ f) w == id w) (ptp true) (c true)
        ==⟨ idp ⟩
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , γ₁₀)) idp
        ==⟨ transport-eq-fun (g ∘ f) id (pair= (loop , γ₁₀)) idp ⟩
      ! ap (g ∘ f) (pair= (loop , γ₁₀)) · idp · ap id (pair= (loop , γ₁₀))
        ==⟨ ap (λ r → ! (ap (g ∘ f) (pair= (loop , γ₁₀))) · idp · r) (ap-id (pair= (loop , γ₁₀))) ⟩
      ! ap (g ∘ f) (pair= (loop , γ₁₀)) · idp · (pair= (loop , γ₁₀))
        ==⟨ ap (λ r → r · pair= (loop , γ₁₀)) (! (·-runit (! ap (g ∘ f) (pair= (loop , γ₁₀))))) ⟩
      ! ap (g ∘ f) (pair= (loop , γ₁₀)) · (pair= (loop , γ₁₀))
        ==⟨ ap (λ r → ! r · pair= (loop , γ₁₀)) (! ap-comp f g (pair= (loop , γ₁₀))) ⟩
      ! ap g (ap f (pair= (loop , γ₁₀))) · (pair= (loop , γ₁₀))
        ==⟨ ap (λ r → ! ap g r · pair= (loop , γ₁₀)) lemma-ap-f-γ₁₀ ⟩
      ! ap g p₁₀ · (pair= (loop , γ₁₀))
        ==⟨ ap (λ r → ! r · pair= (loop , γ₁₀)) (pS-βrec₁₀ (Σ S¹ P) (base , false) (base , true) (ptp false) (ptp true)) ⟩
      ! (ptp true) · (pair= (loop , γ₁₀))
        ==⟨ idp ⟩
      ! (pair= (loop , γ₁₀)) · (pair= (loop , γ₁₀))
        ==⟨ ·-linv (pair= (loop , γ₁₀)) ⟩
      idp
    ∎</p>

<p>p false =
    begin
      tr (λ w → (g ∘ f) w == id w) (ptp false) (c false)
        ==⟨ idp ⟩
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , γ₀₁)) idp
        ==⟨ transport-eq-fun (g ∘ f) id (pair= (loop , γ₀₁)) idp ⟩
      ! ap (g ∘ f) (pair= (loop , γ₀₁)) · idp · ap id (pair= (loop , γ₀₁))
        ==⟨ ap (λ r → ! (ap (g ∘ f) (pair= (loop , γ₀₁))) · idp · r) (ap-id (pair= (loop , γ₀₁))) ⟩
      ! ap (g ∘ f) (pair= (loop , γ₀₁)) · idp · (pair= (loop , γ₀₁))
        ==⟨ ap (λ r → r · pair= (loop , γ₀₁)) (! (·-runit (! ap (g ∘ f) (pair= (loop , γ₀₁))))) ⟩
      ! ap (g ∘ f) (pair= (loop , γ₀₁)) · (pair= (loop , γ₀₁))
        ==⟨ ap (λ r → ! r · pair= (loop , γ₀₁)) (! ap-comp f g (pair= (loop , γ₀₁))) ⟩
      ! ap g (ap f (pair= (loop , γ₀₁))) · (pair= (loop , γ₀₁))
        ==⟨ ap (λ r → ! ap g r · pair= (loop , γ₀₁)) lemma-ap-f-γ₀₁ ⟩
      ! ap g p₀₁ · (pair= (loop , γ₀₁))
        ==⟨ ap (λ r → ! r · pair= (loop , γ₀₁)) (pS-βrec₀₁ (Σ S¹ P) (base , false) (base , true) (ptp false) (ptp true)) ⟩
      ! (ptp false) · (pair= (loop , γ₀₁))
        ==⟨ idp ⟩
      ! (pair= (loop , γ₀₁)) · (pair= (loop , γ₀₁))
        ==⟨ ·-linv (pair= (loop , γ₀₁)) ⟩
      idp
    ∎
  ——————————————————————————</p>

<p>– Def.
  stepFalse3 :
    tr (λ w → (g ∘ f) w == id w)
       ((pair= (loop , refl (tr (λ z → P z) loop false))) · ap  (λ x → ctp x) γ₀₁ )
       (c false) == c (neg false)</p>

<p>stepFalse3  =
    begin
        tr (λ w → (g ∘ f) w == id w)
                  ( (pair= (loop , refl (tr (λ z → P z) loop false)))
                  · ap (λ x → ctp x) γ₀₁
                  )
                  (c false)
    ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) ((pair= (loop , refl (tr (λ z → P z) loop false))) · r ) (c false)) (auxAP {p = loop} γ₀₁) ⟩
     tr (λ w → (g ∘ f) w == id w)
                  ((pair= (loop , refl (tr (λ z → P z) loop false)))
                  ·  pair= (refl base , γ₀₁))
                  (c false)
    ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c false)) (stepFalse1 γ₀₁) ⟩
        tr (λ w → (g ∘ f) w == id w)
                  (pair= (loop , γ₀₁))
                  (c false)
    ==⟨ p false ⟩
      c (neg false)
    ∎</p>

<p>– Def.
  stepFalse4 :
    tr (λ w → (g ∘ f) w == id w)
      (pair= (loop , refl (tr (λ z → P z) loop false)) · (ap (λ x → ctp x) (γ₀₁)) ) (c false)
      ==  c (neg false)
    →
    tr (λ w → (g ∘ f) w == id w)
      (pair= (loop , refl (tr (λ z → P z) loop false))) (c false)
    == tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₀₁)) (c (neg false))</p>

<p>stepFalse4 p =
    begin
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false))) (c false)
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c false)) (·-runit (pair= (loop , refl (tr (λ z → P z) loop false)))) ⟩
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false)) · idp) (c false)
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false)) · r) (c false)) (! (·-rinv (ap (λ x → ctp x) (γ₀₁)))) ⟩
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false)) · ((ap (λ x → ctp x) (γ₀₁)) · ! (ap (λ x → ctp x) (γ₀₁)))) (c false)
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c false)) (! ·-assoc (pair= (loop , refl (tr (λ z → P z) loop false))) ((ap (λ x → ctp x) (γ₀₁))) (! (ap (λ x → ctp x) (γ₀₁)))) ⟩
      tr (λ w → (g ∘ f) w == id w) ( (pair= (loop , refl (tr (λ z → P z) loop false)) · ((ap (λ x → ctp x) (γ₀₁))) · ! (ap (λ x → ctp x) (γ₀₁)))) (c false)
        ==⟨ ! (transport-comp-h (pair= (loop , refl (tr (λ z → P z) loop false)) · ap (λ x → ctp x) γ₀₁) (! (ap (λ x → ctp x) (γ₀₁))) (c false)) ⟩
      tr (λ w → (g ∘ f) w == id w) (! (ap (λ x → ctp x) (γ₀₁))) (tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false)) · ((ap (λ x → ctp x) (γ₀₁)))) (c false))
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) (! (ap (λ x → ctp x) (γ₀₁))) r) p ⟩
      tr (λ w → (g ∘ f) w == id w) (! (ap (λ x → ctp x) (γ₀₁))) (c (neg false))
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c (neg false))) (! ap-inv (λ x → ctp x) γ₀₁) ⟩
      tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₀₁)) (c (neg false))
    ∎</p>

<p>– Def.
  stepFalse5 :
    tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false))) (c false)
    == tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₀₁)) (c (neg false))</p>

<p>stepFalse5 = stepFalse4 stepFalse3</p>

<p>– Def.
  stepTrue1
    : ∀ {x y : P base}
    → (q : tr P loop x == y)
    → pair= (loop , refl (tr P loop x)) · pair= (refl base , q) == pair= (loop , q)</p>

<p>stepTrue1 {x = x} idp =
    begin
        pair= (loop , refl (tr P loop x)) · pair= (refl base , idp)
    ==⟨ idp ⟩
        pair= (loop , refl (tr P loop x)) · idp
    ==⟨ ! ·-runit (pair= (loop , refl (tr P loop x))) ⟩
        pair= (loop , refl (tr P loop x))
    ==⟨ idp ⟩
        pair= (loop , idp)
    ∎</p>

<p>– Def.
  stepTrue2
    : c (tr (λ x → P x) loop true)
      == tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₁₀)) (c (neg true))</p>

<p>stepTrue2 = begin
    c (tr (λ x → P x) loop true)
      ==⟨ ! (apd (λ x → c x) (! γ₁₀)) ⟩
    tr (λ b → (g ∘ f) (base , b) == id (base , b)) (! γ₁₀) (c (neg true))
      ==⟨ transport-family (! γ₁₀) (c (neg true)) ⟩
    tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₁₀)) (c (neg true))
    ∎</p>

<p>– Def.
  stepTrue3
    : tr (λ w → (g ∘ f) w == id w)
         ((pair= (loop , refl (tr (λ z → P z) loop true))) · ap  (λ x → ctp x) γ₁₀ )
         (c true) == c (neg true)</p>

<p>stepTrue3  =
    begin
        tr (λ w → (g ∘ f) w == id w)
                  ( (pair= (loop , refl (tr (λ z → P z) loop true)))
                  · ap (λ x → ctp x) γ₁₀
                  )
                  (c true)
    ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) ( (pair= (loop , refl (tr (λ z → P z) loop true))) · r ) (c true)) (auxAP {p = loop}  γ₁₀) ⟩
     tr (λ w → (g ∘ f) w == id w)
                  ((pair= (loop , refl (tr (λ z → P z) loop true)))
                  ·  pair= (refl base , γ₁₀))
                  (c true)
    ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c true)) (stepTrue1 γ₁₀) ⟩
        tr (λ w → (g ∘ f) w == id w)
                  (pair= (loop , γ₁₀))
                  (c true)
    ==⟨ p true ⟩
      c (neg true)
    ∎</p>

<p>– Def.
  stepTrue4 :
    tr (λ w → (g ∘ f) w == id w)
      (pair= (loop , refl (tr (λ z → P z) loop true)) · (ap (λ x → ctp x) (γ₁₀)) ) (c true)
      ==  c (neg true)
    →
    tr (λ w → (g ∘ f) w == id w)
      (pair= (loop , refl (tr (λ z → P z) loop true))) (c true)
    == tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₁₀)) (c (neg true))</p>

<p>stepTrue4 p =
    begin
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true))) (c true)
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c true)) (·-runit (pair= (loop , refl (tr (λ z → P z) loop true)))) ⟩
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true)) · idp) (c true)
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true)) · r) (c true)) (! (·-rinv (ap (λ x → ctp x) (γ₁₀)))) ⟩
      tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true)) · ((ap (λ x → ctp x) (γ₁₀)) · ! (ap (λ x → ctp x) (γ₁₀)))) (c true)
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c true)) (! ·-assoc (pair= (loop , refl (tr (λ z → P z) loop true))) ((ap (λ x → ctp x) (γ₁₀))) (! (ap (λ x → ctp x) (γ₁₀)))) ⟩
      tr (λ w → (g ∘ f) w == id w) ( (pair= (loop , refl (tr (λ z → P z) loop true)) · ((ap (λ x → ctp x) (γ₁₀))) · ! (ap (λ x → ctp x) (γ₁₀)))) (c true)
        ==⟨ ! (transport-comp-h (pair= (loop , refl (tr (λ z → P z) loop true)) · ap (λ x → ctp x) γ₁₀) (! (ap (λ x → ctp x) (γ₁₀))) (c true)) ⟩
      tr (λ w → (g ∘ f) w == id w) (! (ap (λ x → ctp x) (γ₁₀))) (tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true)) · ((ap (λ x → ctp x) (γ₁₀)))) (c true))
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) (! (ap (λ x → ctp x) (γ₁₀))) r) p ⟩
      tr (λ w → (g ∘ f) w == id w) (! (ap (λ x → ctp x) (γ₁₀))) (c (neg true))
        ==⟨ ap (λ r → tr (λ w → (g ∘ f) w == id w) r (c (neg true))) (! ap-inv (λ x → ctp x) γ₁₀) ⟩
      tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₁₀)) (c (neg true))
    ∎</p>

<p>– Def.
  stepTrue5
    : tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true))) (c true)
      == tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₁₀)) (c (neg true))</p>

<p>stepTrue5 = stepTrue4 stepTrue3</p>

<p>– Def.
  helper
    : (b : P base)
    → tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop b)))
      (c b) == c (tr (λ x → P x) loop b)</p>

<p>helper false =
      begin
        tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop false))) (c false)
          ==⟨ stepFalse5 ⟩
        tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₀₁)) (c (neg false))
          ==⟨ ! stepFalse2 ⟩
        c (tr (λ x → P x) loop false)
      ∎</p>

<p>helper true =
      begin
          tr (λ w → (g ∘ f) w == id w) (pair= (loop , refl (tr (λ z → P z) loop true))) (c true)
      ==⟨ stepTrue5 ⟩
          tr (λ w → (g ∘ f) w == id w) (ap (λ x → ctp x) (! γ₁₀)) (c (neg true))
      ==⟨ ! stepTrue2 ⟩
         c (tr (λ x → P x) loop true)
      ∎
\end{code}</p>

<p>\begin{code}
  – Def.
  cpath : PathOver (λ s → (b : P s) → g (f (s , b)) == s , b) loop c c
  cpath = funext-transport-dfun-r loop c c helper
\end{code}</p>

<p>And the homotopy is as follows:</p>

<p>\begin{code}
– Homotopy
  – Def. by Sigma induction. Step 1.
  g-f : g ∘ f ∼ id
  g-f (s , b) = g-f’ s b
    where
      – Def. by S¹ induction. Step 2.
      g-f’ : (s : S¹) → (b : P s) → (g ∘ f) (s , b) == id (s , b)
      g-f’ = S¹-ind (λ s → (b : P s) → (g ∘ f) (s , b) == id (s , b)) c cpath
\end{code}</p>

<p>Finally, the equivalence:</p>

<p>\begin{code}
  – Equiv.
  ΣS¹P-≃-pS : Σ S¹ P ≃ pS
  ΣS¹P-≃-pS = qinv-≃ f (g , f-g , g-f)
\end{code}</p>


  <div class="cited-references" markdown="1">
  <ol class="bibliography"><li><span id="hottbook">Univalent Foundations Program, T. (2013). <i>Homotopy Type Theory: Univalent Foundations of Mathematics</i>. Retrieved from http://saunders.phil.cmu.edu/book/hott-online.pdf</span></li></ol>
  </div>


  
  <div id="citation">
  <h2> Citation </h2>
  If you want to cite the content of this post,
  we suggest to use the following latex bibtex entry.
  This is generated automatically.

  <br/>
  <br/>
  <pre class="bibtex"
       data-bibtextag ="prietobezem:circle"
       data-bibtexauthors ="Prieto-Cubides, Jonathan and Bezem, Marc"
       data-year ="2018"
       data-lastchecked ="2018-11-02"
       data-originalyear ="2018-05-01"
       data-title ="Circle Equivalences"
       data-url ="http://jonaprieto.github.io/circle-hott/"
  ></pre>
  </div>
  

  <div id="github-links">
    <div class="view-source">
      <a href="https://raw.githubusercontent.com/jonaprieto/jonaprieto.github.io/f42f7d7e18c1724642edd549dfb33f331685c391/blog/_src/notes/2018-05-01-circle-puzzle.lagda.lagda" download target="_blank"><svg height="12" class="octicon octicon-file-code right left" viewBox="0 0 12 16" version="1.1" width="9" aria-hidden="true"><path fill-rule="evenodd" d="M8.5 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V4.5L8.5 1zM11 14H1V2h7l3 3v9zM5 6.98L3.5 8.5 5 10l-.5 1L2 8.5 4.5 6l.5.98zM7.5 6L10 8.5 7.5 11l-.5-.98L8.5 8.5 7 7l.5-1z"/></svg> Raw</a>
      <a href="http://github.com/jonaprieto/jonaprieto.github.io/blob/f42f7d7e18c1724642edd549dfb33f331685c391/blog/_src/notes/2018-05-01-circle-puzzle.lagda.lagda" target="_blank"><svg height="12" class="octicon octicon-mark-github right left" viewBox="0 0 16 16" version="1.1" width="12" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg> Github</a>
      <a href="http://github.com/jonaprieto/jonaprieto.github.io/edit/sources/blog/_src/notes/2018-05-01-circle-puzzle.lagda.lagda" target="_blank"><svg height="12" class="octicon octicon-pencil right left" viewBox="0 0 14 16" version="1.1" width="10" aria-hidden="true"><path fill-rule="evenodd" d="M0 12v3h3l8-8-3-3-8 8zm3 2H1v-2h1v1h1v1zm10.3-9.3L12 6 9 3l1.3-1.3a.996.996 0 0 1 1.41 0l1.59 1.59c.39.39.39 1.02 0 1.41z"/></svg> Edit</a>
      <a href="http://github.com/jonaprieto/jonaprieto.github.io/commits/f42f7d7e18c1724642edd549dfb33f331685c391/blog/_src/notes/2018-05-01-circle-puzzle.lagda.lagda" target="_blank"><svg height="12" class="octicon octicon-history right left" viewBox="0 0 14 16" version="1.1" width="10" aria-hidden="true"><path fill-rule="evenodd" d="M8 13H6V6h5v2H8v5zM7 1C4.81 1 2.87 2.02 1.59 3.59L0 2v4h4L2.5 4.5C3.55 3.17 5.17 2.3 7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-.34.03-.67.09-1H.08C.03 7.33 0 7.66 0 8c0 3.86 3.14 7 7 7s7-3.14 7-7-3.14-7-7-7z"/></svg> History</a>
      <a  href="#" onclick="window.print();return false;" target="_blank"><svg height="12" class="octicon octicon-file-pdf right left" viewBox="0 0 12 16" version="1.1" width="9" aria-hidden="true"><path fill-rule="evenodd" d="M8.5 1H1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V4.5L8.5 1zM1 2h4a.68.68 0 0 0-.31.2 1.08 1.08 0 0 0-.23.47 4.22 4.22 0 0 0-.09 1.47c.06.609.173 1.211.34 1.8A21.78 21.78 0 0 1 3.6 8.6c-.5 1-.8 1.66-.91 1.84a7.156 7.156 0 0 0-.69.3c-.362.165-.699.38-1 .64V2zm4.42 4.8a5.65 5.65 0 0 0 1.17 2.09c.275.237.595.417.94.53-.64.09-1.23.2-1.81.33-.618.15-1.223.347-1.81.59s.22-.44.61-1.25c.365-.74.67-1.51.91-2.3l-.01.01zM11 14H1.5a.743.743 0 0 1-.17 0 2.12 2.12 0 0 0 .73-.44 10.14 10.14 0 0 0 1.78-2.38c.31-.13.58-.23.81-.31l.42-.14c.45-.13.94-.23 1.44-.33s1-.16 1.48-.2c.447.216.912.394 1.39.53.403.11.814.188 1.23.23h.38V14H11zm0-4.86a3.743 3.743 0 0 0-.64-.28 4.221 4.221 0 0 0-.75-.11c-.411.003-.822.03-1.23.08a3 3 0 0 1-1-.64 6.07 6.07 0 0 1-1.29-2.33c.111-.661.178-1.33.2-2 .02-.25.02-.5 0-.75a1.05 1.05 0 0 0-.2-.88.82.82 0 0 0-.61-.23H8l3 3v4.14z"/></svg> Print</a>
      <a  href="#citation"><svg height="12" class="octicon octicon-quote right left" viewBox="0 0 14 16" version="1.1" width="10" aria-hidden="true"><path fill-rule="evenodd" d="M6.16 3.5C3.73 5.06 2.55 6.67 2.55 9.36c.16-.05.3-.05.44-.05 1.27 0 2.5.86 2.5 2.41 0 1.61-1.03 2.61-2.5 2.61-1.9 0-2.99-1.52-2.99-4.25 0-3.8 1.75-6.53 5.02-8.42L6.16 3.5zm7 0c-2.43 1.56-3.61 3.17-3.61 5.86.16-.05.3-.05.44-.05 1.27 0 2.5.86 2.5 2.41 0 1.61-1.03 2.61-2.5 2.61-1.89 0-2.98-1.52-2.98-4.25 0-3.8 1.75-6.53 5.02-8.42l1.14 1.84h-.01z"/></svg> Cite
      </a>

      <a href="mailto:prieto.jona@gmail.com?Subject=[ ?]Circle Equivalences - Commit f42f7d7e" target="_top"><svg height="12" class="octicon octicon-mail right left" viewBox="0 0 14 16" version="1.1" width="10" aria-hidden="true"><path fill-rule="evenodd" d="M0 4v8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1zm13 0L7 9 1 4h12zM1 5.5l4 3-4 3v-6zM2 12l3.5-3L7 10.5 8.5 9l3.5 3H2zm11-.5l-4-3 4-3v6z"/></svg> Send Mail</a>

    </div>
  </div>

</div>

<!-- https://octicons.github.com/ -->





<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$'],['\\[','\\]']],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js","color.js"],
      TagSide: "left",
      Macros: {
        field: ['\\mathbb{#1}', 1],
        C: ['\\field{C}'],
        F: ['\\field{F}'],
        N: ['\\field{N}'],
        Q: ['\\field{Q}'],
        R: ['\\field{R}'],
        Z: ['\\field{Z}'],

        U: ['\\mathcal{U}'],
        to: ['\\rightarrow'],
        zero: ['\\field{0}'],
        one: ['\\field{1}'],
        two: ['\\field{2}'],
        id: ['\\mathsf{Id}'],

        true: ['\\mathsf{true}'],
        false: ['\\mathsf{false}'],

        proj: ['\\mathsf{proj}'],

        trans: ['\\mathsf{trans}'],
        refl: ['\\mathsf{refl}'],
        sym: ['\\mathsf{sym}'],

        Fin:['\\mathsf{Fin}\\,'],
        ind: ['\\mathsf{ind}'],
        rec:['\\mathsf{rec}'],

        zeros: ['\\mathbf{0}'],
        ud: ['\\,\\mathrm{d}'],

        vect:['\\boldsymbol{\\mathbf{#1}}',1],
        abs: ['\\lvert#1\\rvert', 1],
        abslr:['\\left\\lvert#1\\right\\rvert', 1],
        norm: ['\\lVert#1\\rVert', 1],
        normlr: ['\\left\\lVert#1\\right\\rVert', 1],

        lcm: ['\\mathop{\\mathrm{lcm}}'],
        interior: ['\\mathop{\\mathrm{int}}'],
        exterior: ['\\mathop{\\mathrm{ext}}'],
        volume: ['\\mathop{\\mathrm{vol}}'],

        E: ['{\\rm I\\kern-.3em E}'],
        Var: ['\\mathop{\\mathrm{Var}}'],
        Cov: ['\\mathop{\\mathrm{Cov}}'],
        Binom: ['\\mathop{\\mathrm{Binom}}'],
        Exp: ['\\mathop{\\mathrm{Exp}}'],
        Poi: ['\\mathop{\\mathrm{Poi}}'],

        GL: ['\\mathrm{GL}'],
        SL: ['\\mathrm{SL}'],
        Aut: ['\\mathrm{Aut}'],
        ker: ['\\mathrm{ker}'],

        Re: ['\\mathop{\\mathrm{Re}}'],
        Im: ['\\mathop{\\mathrm{Im}}'],
        Res: ['\\mathop{\\mathrm{Res}}'],



        Type : ['\\mathsf{Type}\\,'],
        Iso : ['{#1}\\,\\simeq_{\\mathsf{Iso}}{#2}\\,',2],
        Graph : ['\\mathsf{Graph}\\,'],
        Face : ['\\mathsf{Face}\\,'],
        Node : ['\\mathsf{Node}\\,'],
        Edge : ['\\mathsf{Edge}\\,'],
        Path : ['\\mathsf{Path}\\,'],

        minimize : ['\\mathsf{minimize}'],
        maximize : ['\\mathsf{maximize}'],
        st : ['\\mathsf{st}'],

        and : ['\\,\\wedge\\, '],
        or : ['\\,\\vee\\,']



      }
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>



<script>
  // When the user scrolls the page, execute myFunction
function stickyToogle(obj, sticky) {
  if (window.pageYOffset > sticky) {
    obj.classList.add("sticky");
  } else {
    obj.classList.remove("sticky");
  }
};

// Get the header
function stickyThing(idObj){
  var obj = document.getElementById(idObj);
  if (obj){
    // Get the offset position of the navbar
    stickyToogle(obj, obj.offsetTop);
    // Add the sticky class to the obj when you reach its scroll position. Remove "sticky" when you leave the scroll position
  }
};

window.onscroll = function() {
  stickyThing("stickyTitle");
};

</script>



      </div>
      
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
<script src="/assets/jquery.min.js"></script>



<script type="text/javascript">
WebFontConfig = {
 google: { families: [ 'PT+Serif:400,700,400italic:latin', 'PT+Sans:400:latin' ] }
};
(function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js';
      wf.async = true;
      s.parentNode.insertBefore(wf, s);
   })(document);
</script>


<!-- FOLDABLE  -->
<script type="text/javascript">
 $('pre.foldable').each(function(){
     var lineHeight = parseFloat($(this).css('line-height'));
     var plus    = $('<div><svg height="12" class="octicon octicon-fold" viewBox="0 0 14 16" version="1.1" width="10" aria-hidden="true"><path fill-rule="evenodd" d="M7 9l3 3H8v3H6v-3H4l3-3zm3-6H8V0H6v3H4l3 3 3-3zm4 2c0-.55-.45-1-1-1h-2.5l-1 1h3l-2 2h-7l-2-2h3l-1-1H1c-.55 0-1 .45-1 1l2.5 2.5L0 10c0 .55.45 1 1 1h2.5l1-1h-3l2-2h7l2 2h-3l1 1H13c.55 0 1-.45 1-1l-2.5-2.5L14 5z"/></svg></div>');
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight
       });

     var until = parseFloat($(this).attr('until'));
     if ( isNaN(until) ) { until= 1; }
     if ( until <= 0 ){
       $(this).hide();
     }
     else{
       var newHeight = ((1.2 * until) + 0.7) + "rem";
       //                               ^^^----------- for the padding
       //                ^^-- line-height

       // console.log('afuera-until: ', until);
       // console.log('afuera-newheight: ', newHeight );
       $(this).css("padding", "0.5rem 1rem");
       $(this).css("overflow", "hidden");
       $(this).css("height", newHeight);
       $(this).attr("original", "false");

       $(this).click(function(){

         // console.log('dentro-original: ', $(this).attr('original') );
         // console.log('dentro-newheight: ', newHeight );

         if ( $(this).attr('original') == "true" ) {
           $(this).css("overflow", "hidden");
           $(this).css("height", newHeight);
           $(this).attr("original", "false");
           $(this).css("padding", "0.5rem 1rem");
           // plus.show();
         }
         else {
           $(this).height('auto');
           $(this).attr("original", "true");
           // plus.hide();
         }
       });
     }
 });
</script>






<script type="text/javascript">
  if ( $('div').hasClass('cited-references') ){
    $('.cited-references').append( $('.references').html() );
    $('.references').hide();
    $(".cited-references").prepend("<h2 id='refs'>References</h2>");
    $(".toc nav>ul").append("<li><a href='#refs'>References</a></li>");
  }
</script>



<script type="text/javascript">
var pre, title, id, tag, url, coauthor, year, lastchecked, originalyear;

$('#citation').hide();
$('#citation pre').each(function(){

    var pre           = $(this);
    var title         = $(this).data('title');
    var title         = $(this).data('title');
    var id            = $(this).data('url');
    var year          = $(this).data('year');
    var lastchecked   = $(this).data('lastchecked');
    var originalyear  = $(this).data('originalyear');
    var url           = $(this).data('url');

    var bibtextag     = $(this).data('bibtextag');
    var bibtexauthors = $(this).data('bibtexauthors');

    if (bibtexauthors == ""){
      bibtexauthors = "Prieto-Cubides, Jonathan";
    }

    if (bibtextag == "")
    {
      bibtextag = "prieto" + lastchecked
    }

    pre.append(
    "@online{ " + bibtextag + ",\n" +
    "  author  = { " + bibtexauthors +" },\n" +
    "  title   = { " + title + " },\n" +
    "  url     = { \\url{" + url   + "} }\n" +
    "  year    = { " + year  + " }\n" +
    "  lastchecked  = { " + lastchecked  + " }\n" +
    "  originalyear = { " + originalyear  + " }\n" +
    "}\n"
    );
  });

$('#citation').show();
</script>




    <script>
      (function(document) {
        var toggle   = document.querySelector('.sidebar-toggle');
        var sidebar  = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>

    
    <script src="/assets/galleryjs/lightgallery.js"></script>

    <script src="/assets/galleryjs/lg-thumbnail.min.js"></script>
    <script src="/assets/galleryjs/lg-fullscreen.min.js"></script>

    <script  type="text/javascript">
      $(document).ready(function() {
        $('.post img').wrap(function(){
          return "<div class='gallery' data-src='" + $( this ).attr("src") + "'></div>";
        });

        lightGallery(document.querySelector('.post'),
          { selector     : ".gallery"
          // , mode         : 'slide'
          , thumbnail    : true
          , animateThumb: false
          , closable     : true
          , counter      : true
          , enableTouch  : true
          , enableDrag   : true
          , showThumbByDefault   : false
          , thumbWidth           : 90
          , thumbMargin          : 5,
          });
      });
    </script>
    
  </body>
</html>

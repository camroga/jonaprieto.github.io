---
layout: "post"
title: "Circle puzzle"
date: "2018-05-01"
categories: type-theory
---

Moebius type family:

<p class="equation">
$$
\mathsf{rec}_{\mathbb{S}^1}\, \mathcal{U}\, 2\, (\mathsf{ua}(\mathsf{rec}_{2}\,2\,1_{2}\,0_{2})):
\mathbb{S}^1 \to \mathcal{U}.
$$
</p>

<div class="exercise">
Prove the equivalence of

<p class="equation">
$$\sum\,{\mathbb{S}^1}}\,(\mathsf{rec}_{\mathbb{S}^1}\, \mathcal{U}\,  2\, (\mathsf{ua}(\mathsf{rec}_{2}2 1_{2} 0_{2}))) \simeq \mathbb{S}^1.$$
</p>
</div>

To solve this problem, let us recall the following results:

- The univalence axiom: for all $$A : \mathcal{U}$$ and $$B : \mathcal{U}$$,

<p class="equation">
$$
\mathsf{ua} : A\simeq B \to A =_{\mathcal{U}} B.
$$
</p>

- Circle is a higher inductive type generated by
    - a point $$\mathsf{base} : \mathbb{S}^1$$, and
    - a path $$\mathsf{loop} : \mathsf{base} \equiv \mathsf{base}$$
    - Theorem: $$ \mathsf{loop} \not \equiv \mathsf{refl}_{\mathsf{base}}$$
    - Recursion principle $$\mathsf{rec}$$:

      $$\begin{align*}
      &\mathsf{ref} : (f : \mathbb{S}^1 \to \mathsf{A}) \to (\mathbb{S}^1 \to \mathcal{U})\\
      &\mathsf{ref}~f~\mathsf{base}~=~f~\mathsf{base}\\
      &\mathsf{ref}~f~\mathsf{loop}~=~\mathsf{ap}_{f}~\mathsf{loop}
      \end{align*}
      $$

- The type for equivalence from $$A$$ to $$B$$

$$
  (A \simeq B) :\equiv \sum\limits_{f : A \to B} \mathsf{isequiv}(f),
$$

where

$$
\mathsf{isequiv(f)} :\equiv
  \left (\sum\limits_{g : B \to A} (f \circ g \sim \mathsf{id}_{B})\right) \times
  \left (\sum\limits_{h : B \to A} (h \circ f \sim \mathsf{id}_{A})\right).
$$

- The homotopy concept:

Let $$f , g : \prod\limits_{(x:A)} P(x)$$ be two sections of a
type family $$P : A \to \mathcal{U}$$. A **homotopy** from $$f$$ to $$g$$
is a dependent function of type

$$
(f \sim g) :\equiv \prod\limits_{x : A} (f(x) \equiv g(x)).
$$

![path-triangle](/assets/ipe-images/Bid.png)

## Experiment in Agda

Using HoTT-Agda:

\begin{code}
{-# OPTIONS --without-K #-}

open import HoTT

b : S¹
b = base

l : base == base
l = loop

id : Bool → Bool
id = λ z → z

neg : Bool → Bool
neg false = true
neg true  = false

id-equiv : Bool ≃ Bool
id-equiv = equiv id id helper helper
  where
    helper : (b : Bool) → id (id b) == b
    helper true  = ap id idp
    helper false = ap id idp

neg-equiv : Bool ≃ Bool
neg-equiv = equiv neg neg helper₁ helper₁
  where
    helper₁ : (b₁ : Bool) → neg (neg b₁) == b₁
    helper₁ false = ap neg idp
    helper₁ true  = ap neg idp

-- open import S₁Rec


B : S¹ → Type₀
B = S¹-rec Bool (ua neg-equiv)

-- (ua neg-equiv) x)

module RR = S¹Rec {A = Type₀} Bool (ua neg-equiv)

postulate
  eq1 : B base == Bool

-- _ : B base == Bool
-- _ = ua (equiv f g {!!} {!!})
--   where
--     f : B base → Bool
--     f x = true

--     g : Bool → B base
--     g true  = {!!}
--     g false = {!!}

a_ : _
a_ = transport

s : S¹ ≃ Σ S¹ B
s = equiv f g f-g g-f
  where
    f : S¹ → Σ S¹ B
    f base = (base , {!   !})

    g : Σ S¹ B → S¹
    g (b , _) = b

    f-g : (b₁ : Σ S¹ B) → f (g b₁) == b₁
    f-g = {! !}

    g-f : (a : S¹) → g (f a) == a
    g-f = {! !}

\end{code}

<div class="exercise" id="exercise-2.13">
Show that $$(2 \simeq 2) \simeq 2$$.
</div>

\begin{code}
module Ex2-13 where
  baby-step
    : Bool
    → ((x : S¹) → B x)
  baby-step true  = {! λ x → true  !}
  baby-step false = {! λ x → B x   !}

  proof : (Bool ≃ Bool) ≃ Bool
  proof = equiv h f
    h-f
    {! f-h  !}
    where
      h : Bool ≃ Bool → Bool
      h (f , _) = f true

      f : Bool → Bool ≃ Bool
      f false = neg-equiv
      f true  = id-equiv

      h-f : (b : Bool) → h (f b) == b
      h-f false = idp
      h-f true  = idp

      f-h : (a : Bool ≃ Bool) → f (h a) == a
      f-h (g , record
                  { g = g′
                  ; f-g = f-g
                  ; g-f = g-f
                  ; adj = adj
                  }) = {! f-g  !}
\end{code}



## References

{::options parse_block_html="true" /}
<div class="references">
- {% reference hottbook %}
</div>
{::options parse_block_html="false" /}

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
      
        Mini HoTT library in Agda |
      
        jonaprieto
    
  </title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Mini HoTT library in Agda" />
<meta name="author" content="Jonathan Prieto-Cubides" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Jonathan Prieto-Cubides" />
<meta property="og:description" content="Jonathan Prieto-Cubides" />
<link rel="canonical" href="http://jonaprieto.github.io/assets/png-images/2018-07-06-mini-hott.lagda" />
<meta property="og:url" content="http://jonaprieto.github.io/assets/png-images/2018-07-06-mini-hott.lagda" />
<meta property="og:site_name" content="jonaprieto" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-06T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"Jonathan Prieto-Cubides","author":{"@type":"Person","name":"Jonathan Prieto-Cubides"},"@type":"BlogPosting","url":"http://jonaprieto.github.io/assets/png-images/2018-07-06-mini-hott.lagda","headline":"Mini HoTT library in Agda","dateModified":"2018-09-20T20:23:14+02:00","datePublished":"2018-07-06T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jonaprieto.github.io/assets/png-images/2018-07-06-mini-hott.lagda"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<meta name="description" content="Jonathan Prieto-Cubides">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="preload" as="script" href="/assets/main.js" >

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">

  <link rel="manifest" href="/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  
  <link rel="preload" as="script" href="/assets/js/latex.js" >
  
  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114360791-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114360791-1');
  </script>

  
</head>




  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item" >
    <p style="text-decoration:left">Jonathan Prieto-Cubides</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    <!--  -->
    <!-- 
      
    
      
    
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/all/">All</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/references/">List of references</a>
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/plans/">Plans</a>
        
      
     -->

    <a class="sidebar-nav-item" href="/about/">About</a>
    <!-- <a class="sidebar-nav-item" href="/plans/">Plans</a> -->
    <a class="sidebar-nav-item" href="http://github.com/jonaprieto/jonaprieto.github.io">GitHub</a>
    <!-- <span class="sidebar-nav-item">Currently v0.0.1</span> -->
  </nav>
</div>

    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://github.com/jonaprieto"><img alt="@jonaprieto" class="avatar float-left mr-1" src="https://avatars3.githubusercontent.com/u/1428088?s=40&amp;v=4" height="20" width="20"></a>
            <a href="/" title="Home">jonaprieto</a>
            <small style="text-decoration:left">‚à∑ WorkInProgress</small>
          </h3>
        </div>
      
      <div class="container content">
        





<div class="post">

  <div class="print-version">
    <center>
      <h1>Mini HoTT library in Agda </h1><br/>
        <div class="print-authors">
          <div class="print-info">
            <div class="print-author">
              <div class="print-author-name">
                
                  Jonathan Prieto-Cubides
                
              </div>
              <div class="print-author-affiliation">
                
                  University of Bergen
                
                </div>
            </div>
          </div>
          
        </div>
        <div class="print-date">06 July 2018</div>
        
        
    </center>
  </div>

  
  <div class="main-heading">
    <div class="main-title">
      <div class="main-title-prefix"> Latest change:</div>
      <div class="main-commit-message">
            <a href="http://github.com/jonaprieto/jonaprieto.github.io/blob/c4f28f442c4609eb0fe2795033803790551d3f6b/assets/png-images/2018-07-06-mini-hott.lagda">
              [ bitacora ] saving progress</a>
      </div>
    </div>

    <div class="main-last-date">
      Latest commit <a href="http://github.com/jonaprieto/jonaprieto.github.io/blob/c4f28f442c4609eb0fe2795033803790551d3f6b/assets/png-images/2018-07-06-mini-hott.lagda">3e5778d </a> on  21 Sep 2018
    </div>
  </div>
  
  <h1 class="post-title">Mini HoTT library in Agda
    <div class="github-links">
      <small class="view-source"><a href="https://raw.githubusercontent.com/jonaprieto/jonaprieto.github.io/c4f28f442c4609eb0fe2795033803790551d3f6b/assets/png-images/2018-07-06-mini-hott.lagda" download target="_blank">Raw</a><a href="http://github.com/jonaprieto/jonaprieto.github.io/blob/c4f28f442c4609eb0fe2795033803790551d3f6b/assets/png-images/2018-07-06-mini-hott.lagda" target="_blank">View source</a><a href="http://github.com/jonaprieto/jonaprieto.github.io/edit/sources/assets/png-images/2018-07-06-mini-hott.lagda" target="_blank">Edit</a><a href="http://github.com/jonaprieto/jonaprieto.github.io/commits/c4f28f442c4609eb0fe2795033803790551d3f6b/assets/png-images/2018-07-06-mini-hott.lagda" target="_blank">History</a><a  href="#" onclick="window.print();return false;" target="_blank">Print</a><a  href="#citation">Cite</a></small>
    </div>
  </h1>
  
  <div class="toc">
    <nav>
    <h2 class="table-of-contents"> Table of Contents </h2>
      

    </nav>
  </div>
  
  ## Introduction

This is a basic overview of homotopy type theory (HoTT) formalized in Agda. It's
only one file and has been type-checked by Agda 2.5.4. No other libraries are
required to type-check this file.

{: .only-website }

  **URL link**: [https://tinyurl.com/mini-hott](https://tinyurl.com/mini-hott).

To be consistent with homotopy type theory, we tell Agda to not use Axiom K for
type-checking by using the option `without-K`. Without Axiom K, Agda's `Set` is
not a good name for universes in HoTT and we rename `Set` to `Type`.

This code is working in progress and it's for my own learning purposes.
Please check out the references at the end of this article.

\begin{code}
{-# OPTIONS --without-K #-}

open import Agda.Primitive using ( Level ; lsuc; lzero; _‚äî_ ) public

Type : (‚Ñì : Level) ‚Üí Set (lsuc ‚Ñì)
Type ‚Ñì = Set ‚Ñì

Type‚ÇÄ : Type (lsuc lzero)
Type‚ÇÄ = Type lzero
\end{code}

## Basic types

### Empty type

The Empty type, representing falsehood.

\begin{code}
-- A datatype without constructors is the empty type.
data ‚ä• {‚Ñì·µ¢} : Type ‚Ñì·µ¢ where

-- synonyms of ‚ä•
Empty = ‚ä•
ùüò     = ‚ä•
\end{code}

Its eliminator:

\begin{code}
-- Ex falso quodlibet
exfalso
  : ‚àÄ {‚Ñì ‚Ñì·µ¢} {A : Type ‚Ñì} ‚Üí ‚ä• {‚Ñì·µ¢} ‚Üí A

exfalso ()

-- synonyms of exfalso
Empty-elim = exfalso
‚ä•-elim     = exfalso
\end{code}

A useful convention
\begin{code}
-- Negation
¬¨
  : ‚àÄ {‚Ñì} ‚Üí Type ‚Ñì ‚Üí Type ‚Ñì

¬¨ A = (A ‚Üí ‚ä• {lzero})
\end{code}

### Unit type

The unit type is defined as record so that we also get the Œ∑-rule
definitionally.

No elimination rule.
\begin{code}
record ‚ä§ : Type‚ÇÄ where
  constructor ‚òÖ

{-# BUILTIN UNIT ‚ä§ #-}

-- synonyms for the data constructor
unit = ‚òÖ

-- synonyms for the Unit type
Unit = ‚ä§
ùüô    = ‚ä§
\end{code}

### Œ£-type

Sigma types are a particular case of records, but records can be constructed
using only sigma types. Note that l ‚äî q is the maximum of two hierarchy levels l
and q. This way, we define sigma types in full generality, at each universe.

\begin{code}
infixr 60 _,_
record Œ£ {‚Ñì·µ¢ ‚Ñì‚±º} (A : Type ‚Ñì·µ¢)(C : A ‚Üí Type ‚Ñì‚±º) : Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º) where
  constructor _,_
  field
    œÄ‚ÇÅ : A
    œÄ‚ÇÇ : C œÄ‚ÇÅ

  -- synonyms for data constructors
  proj‚ÇÅ = œÄ‚ÇÅ
  proj‚ÇÇ = œÄ‚ÇÇ
  fst   = œÄ‚ÇÅ
  snd   = œÄ‚ÇÇ
open Œ£ public
\end{code}

### Œ†-types
Shorter notation for Œ†-types.

\begin{code}
Œ†
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}
  ‚Üí (A : Type ‚Ñì·µ¢) (P : A ‚Üí Type ‚Ñì‚±º)
  --------------------------------
  ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)

Œ† A P = (x : A) ‚Üí P x
\end{code}

### Product type

Product type as a particular case of the sigma

\begin{code}
_√ó_
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}
  ‚Üí (A : Type ‚Ñì·µ¢) (B : Type ‚Ñì‚±º)
  ----------------------------
  ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)

A √ó B = Œ£ A (Œª _ ‚Üí B)
\end{code}

### Coproduct

Sum types as inductive types

\begin{code}
infixr 80 _+_
data _+_ {‚Ñì·µ¢ ‚Ñì‚±º} (A : Type ‚Ñì·µ¢) (B : Type ‚Ñì‚±º) : Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º) where
  inl : A ‚Üí A + B
  inr : B ‚Üí A + B
\end{code}

### Boolean

Boolean type, two constants true and false

\begin{code}
data Bool : Type‚ÇÄ where
  true  : Bool
  false : Bool
\end{code}

*Booleans can be also defined using the coproduct.*

### Natural numbers

Natural numbers are the initial algebra for a constant and a
successor function. The `BUILTIN` declaration allows us to use
natural numbers in Arabic notation.

\begin{code}
data ‚Ñï : Type‚ÇÄ where
  zero : ‚Ñï
  succ : ‚Ñï ‚Üí ‚Ñï

{-# BUILTIN NATURAL ‚Ñï #-}

-- synonyms for natural numbers
Nat = ‚Ñï
\end{code}

## Functions

### Identity function

The identity function with implicit type.
\begin{code}
id
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
  ‚Üí A ‚Üí A

id = Œª x ‚Üí x
\end{code}

The identity function on a type `A` is `idf A`.

\begin{code}
idf
  : ‚àÄ {‚Ñì·µ¢}
  ‚Üí (A : Type ‚Ñì·µ¢)
  ---------------
  ‚Üí (A ‚Üí A)

idf A = Œª x ‚Üí x
\end{code}

### Constant function

Constant function at some point `b` is `cst b`

\begin{code}
cst
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º}
  ‚Üí (b : B)
  ---------
  ‚Üí (A ‚Üí B)

cst b = Œª _ ‚Üí b
\end{code}

### Composition

A more sophisticated composition function that can handle dependent functions.

\begin{code}
_‚àò_
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {B : A ‚Üí Type ‚Ñì‚±º} {C : (a : A) ‚Üí (B a ‚Üí Type ‚Ñì‚Çñ)}
  ‚Üí (g : {a : A} ‚Üí Œ† (B a) (C a))
  ‚Üí (f : Œ† A B)
  -------------------------------
  ‚Üí Œ† A (Œª a ‚Üí C a (f a))

g ‚àò f = Œª x ‚Üí g (f x)
infixr 80 _‚àò_
\end{code}

Synonym for composition (diagrammatic version)
\begin{code}
_//_
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {B : A ‚Üí Type ‚Ñì‚±º} {C : (a : A) ‚Üí (B a ‚Üí Type ‚Ñì‚Çñ)}
  ‚Üí (f : Œ† A B)
  ‚Üí (g : {a : A} ‚Üí Œ† (B a) (C a))
  -------------------------------
  ‚Üí Œ† A (Œª a ‚Üí C a (f a))

f // g = g ‚àò f
\end{code}

### Application

\begin{code}
infixr 0 _$_
_$_
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : A ‚Üí Type ‚Ñì‚±º}
  ‚Üí (‚àÄ x ‚Üí B x)
  -------------
  ‚Üí (‚àÄ x ‚Üí B x)

f $ x = f x
\end{code}

### Curryfication

\begin{code}
curry
  : ‚àÄ {i j k} {A : Type i} {B : A ‚Üí Type j} {C : Œ£ A B ‚Üí Type k}
  ‚Üí (‚àÄ s ‚Üí C s)
  ---------------------
  ‚Üí (‚àÄ x y ‚Üí C (x , y))

curry f x y = f (x , y)
\end{code}

### Uncurryfication

\begin{code}
uncurry
  : ‚àÄ {i j k} {A : Type i} {B : A ‚Üí Type j} {C : ‚àÄ x ‚Üí B x ‚Üí Type k}
  ‚Üí (‚àÄ x y ‚Üí C x y)
  -------------------------
  ‚Üí (‚àÄ s ‚Üí C (œÄ‚ÇÅ s) (œÄ‚ÇÇ s))

uncurry f (x , y) = f x y
\end{code}

### Instance search

\begin{code}
-- how to use it ‚ùì
‚ü®‚ü©
  : ‚àÄ {i} {A : Type i}  ‚Üí A

‚ü®‚ü©  = a
\end{code}

## Equality type

In HoTT, we have a different interpretation of type theory in which the
set-theoretical notion of *sets* for *types* is replaced by the topological
notion of *spaces*. A type judgment like `x : A` means that the point `x`‚Äå‚Äå is
*in* the topological space `A`‚Äå‚Äå. Furthermore, we include the *Identity type* as
a primary type. The inhabitants of these identity types will not be longer
interpreted as *proofs of equalities* but as *paths* in a Path space, an
Identity type.

### Homogeneous equality

The Identity type is defined as an inductive type. Its induction principle is
the J-eliminator.

\begin{code}
data _==_ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} (a : A) : A ‚Üí Type ‚Ñì·µ¢ where
  idp : a == a

infix 30 _==_
{-# BUILTIN EQUALITY _==_ #-}

-- synonyms for identity type
Path = _==_
\end{code}

\begin{code}
refl
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢}
  ‚Üí (a : A)
  ---------
  ‚Üí a == a

refl {‚Ñì·µ¢}{A} a = idp {‚Ñì·µ¢ = ‚Ñì·µ¢}{A = A}
\end{code}

#### J eliminator

The elimination principle for the identity type is the path induction. It allows
us to define an outgoing function from the identity type to a dependent type ‚Äå‚Äå
as we see in the `J` definition below.

*Paulin-Mohring J rule*

{: .foldable until="6" }
\begin{code}
J
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {a : A}
  ‚Üí (B : (a' : A) (p : a == a') ‚Üí Type ‚Ñì‚±º)
  ‚Üí (d : B a idp)
  ----------------------------------------
  ‚Üí {a' : A} (p : a == a') ‚Üí B a' p

J {a = a} B d idp = d
\end{code}

{: .foldable until="6" }
\begin{code}
J'
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {a : A}
  ‚Üí (B : (a' : A) (p : a' == a) ‚Üí Type ‚Ñì‚±º)
  ‚Üí (d : B a idp)
  ----------------------------------------
  ‚Üí {a' : A} (p : a' == a) ‚Üí B a' p

J' {a = a} B d idp = d
\end{code}

#### Composition of paths

{: .foldable until="6" }
\begin{code}
_¬∑_
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {x y z : A}
  ‚Üí (p : x == y)
  ‚Üí (q : y == z)
  --------------
  ‚Üí x == z

_¬∑_ idp q = q

infixl 50 _¬∑_
\end{code}

![path](/assets/ipe-images/path-concatenation.png){: width="60%" }

#### Inverse of paths

\begin{code}
inv
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí a == b
  --------
  ‚Üí b == a

inv idp = idp

-- synonyms for inverse path
infixl 60 _‚Åª¬π
_‚Åª¬π = inv

infixr 60 !_
!_  = inv
\end{code}

#### Associativity of composition

- Left associativity

{: .foldable until="5" }
\begin{code}
‚àò-lassoc
  : ‚àÄ {‚Ñì} {A B C D : Type ‚Ñì}
  ‚Üí (h : C ‚Üí D) ‚Üí (g : B ‚Üí C) ‚Üí (f : A ‚Üí B)
  -----------------------------------------
  ‚Üí (h ‚àò (g ‚àò f)) == ((h ‚àò g) ‚àò f)

‚àò-lassoc h g f = idp {a = (Œª x ‚Üí h (g (f x)))}
\end{code}

- Right associativity

{: .foldable until="5" }
\begin{code}
‚àò-rassoc
  : ‚àÄ {‚Ñì} {A B C D : Type ‚Ñì}
  ‚Üí (h : C ‚Üí D) ‚Üí (g : B ‚Üí C) ‚Üí (f : A ‚Üí B)
  -----------------------------------------
  ‚Üí ((h ‚àò g) ‚àò f) == (h ‚àò (g ‚àò f))

‚àò-rassoc h g f = (‚àò-lassoc h g f) ‚Åª¬π
\end{code}

### Heterogeneous equality

\begin{code}
data HEq {‚Ñì} (A : Type ‚Ñì)
           : (B : Type ‚Ñì)
           ‚Üí (Œ± : A == B) (a : A) (b : B)
           ‚Üí Type ‚Ñì where
  idp : ‚àÄ {a : A} ‚Üí HEq A A idp a a
\end{code}

## Equational reasoning

Equational reasoning is a way to write readable chains of equalities.


```agda
  t : a == e
  t = a =‚ü® p ‚ü©
      b =‚ü® q ‚ü©
      c =‚ü® r ‚ü©
      d =‚ü® s ‚ü©
      e ‚àé
```


where `p` is a path from `a` to `b`, `q` is a path from `b` to `c`, and so on.

\begin{code}
module EquationalReasoning {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} where
\end{code}

Definitional equals:

\begin{code}
  _==‚ü®‚ü©_
    : ‚àÄ (x {y} : A)
    ‚Üí x == y ‚Üí x == y

  _ ==‚ü®‚ü© p = p

  -- synonyms for _==‚ü®‚ü©
  _==‚ü®idp‚ü©_  = _==‚ü®‚ü©_
  _==‚ü®refl‚ü©_ = _==‚ü®‚ü©_

  infixr 2 _==‚ü®‚ü©_
\end{code}

\begin{code}
  -- chain
  _==‚ü®_‚ü©_
    : (x : A) {y z : A}
    ‚Üí x == y
    ‚Üí y == z
    ‚Üí x == z

  _ ==‚ü® thm ‚ü© q = thm ¬∑ q

  infixr 2 _==‚ü®_‚ü©_
\end{code}

\begin{code}
  -- Q.E.D
  infix 3 _‚àé
  _‚àé
    : (x : A)
    ‚Üí x == x

  _‚àé = Œª x ‚Üí idp
\end{code}

\begin{code}
  -- Begin
  infix 1 begin_
  begin_
    : {x y : A}
    ‚Üí x == y
    ‚Üí x == y

  begin_ p = p
\end{code}

\begin{code}
open EquationalReasoning public
\end{code}
## Actions on paths

Functions are functors to equalities.  In other words, functions
preserve equalities.

{: .foldable until="6" }
\begin{code}
ap
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º}
  ‚Üí (f : A ‚Üí B) {a‚ÇÅ a‚ÇÇ : A}
  ‚Üí a‚ÇÅ == a‚ÇÇ
  --------------
  ‚Üí f a‚ÇÅ == f a‚ÇÇ

ap f idp = idp
\end{code}

Now, we can define a convenient syntax sugar for `ap` in
equational reasoning.

\begin{code}
infixl 40 ap
syntax ap f p = p |in-ctx f
\end{code}

Let's suppose we have a lemma:

```agda
  lemma : a == b
  lemma = _
```

used in an equational reasoning like:

```agda
  t : a == e
  t = f a =‚ü® ap f lemma ‚ü©
      f b
      ‚àé
```


Then, we can now put the lemma in front:

```agda
  t : a == e
  t = f a =‚ü® lemma |in-ctx f ‚ü©
      f b
      ‚àé
```


Lastly, we can also define actions on two paths:

{: .foldable until="7" }
\begin{code}
ap‚ÇÇ
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {C : Type ‚Ñì‚Çñ}  {b‚ÇÅ b‚ÇÇ : B}
  ‚Üí (f : A ‚Üí B ‚Üí C)
  ‚Üí {a‚ÇÅ a‚ÇÇ : A} ‚Üí (a‚ÇÅ == a‚ÇÇ)
  ‚Üí {b‚ÇÅ b‚ÇÇ : B} ‚Üí (b‚ÇÅ == b‚ÇÇ)
  --------------------------
  ‚Üí f a‚ÇÅ b‚ÇÅ  == f a‚ÇÇ b‚ÇÇ

ap‚ÇÇ f idp idp = idp
\end{code}

### Lemmas

{: .foldable until="5" }
\begin{code}
ap-¬∑
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {a b c : A}
  ‚Üí (f : A ‚Üí B) ‚Üí (p : a == b) ‚Üí (q : b == c)
  -------------------------------------------
  ‚Üí ap f (p ¬∑ q) == ap f p ¬∑ ap f q

ap-¬∑ f idp q = refl (ap f q)
\end{code}

{: .foldable until="5" }
\begin{code}
ap-inv
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {a b : A}
  ‚Üí (f : A ‚Üí B) ‚Üí (p : a == b)
  ----------------------------
  ‚Üí ap f (p ‚Åª¬π) == (ap f p) ‚Åª¬π

ap-inv f idp = idp

-- synonyms
ap-! = ap-inv
\end{code}

{: .foldable until="7" }
\begin{code}
ap-comp
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {C : Type ‚Ñì‚Çñ} {a b : A}
  ‚Üí (f : A ‚Üí B)
  ‚Üí (g : B ‚Üí C)
  ‚Üí (p : a == b)
  -------------------------------
  ‚Üí ap g (ap f p) == ap (g ‚àò f) p

ap-comp f g idp = idp
\end{code}

{: .foldable until="5" }
\begin{code}
ap-id
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {a b : A}
  ‚Üí (p : a == b)
  --------------
  ‚Üí ap id p == p

ap-id idp = idp
\end{code}

{: .foldable until="5" }
\begin{code}
ap-const
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {C : Type ‚Ñì‚±º} {a b : A} {c : C}
  ‚Üí (p : a == b)
  -----------------------
  ‚Üí ap (Œª _ ‚Üí c) p == idp

ap-const {c = c} idp = refl (refl c)
\end{code}

## Properties on the groupoid

Some properties on the groupoid structure of equalities

{: .foldable until="5" }
\begin{code}
¬∑-runit
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí (p : a == b)
  --------------
  ‚Üí p == p ¬∑ idp

¬∑-runit idp = idp
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-lunit
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí (p : a == b)
  --------------
  ‚Üí p == idp ¬∑ p

¬∑-lunit idp = idp
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-linv
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí (p : a == b)
  ----------------
  ‚Üí ! p ¬∑ p == idp

¬∑-linv idp = idp
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-rinv
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí (p : a == b)
  ----------------
  ‚Üí p ¬∑ ! p == idp

¬∑-rinv idp = idp
\end{code}

{: .foldable until="5" }
\begin{code}
involution
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí {p : a == b}
  ---------------
  ‚Üí ! (! p) == p

involution {p = idp} = idp
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-assoc
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b c d : A}
  ‚Üí (p : a == b) ‚Üí (q : b == c) ‚Üí (r : c == d)
  --------------------------------------------
  ‚Üí p ¬∑ q ¬∑ r == p ¬∑ (q ¬∑ r)

¬∑-assoc idp q r = idp
\end{code}

{: .foldable until="6" }
\begin{code}
¬∑-cancellation
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a : A}
  ‚Üí (p : a == a) ‚Üí (q : a == a)
  ‚Üí p ¬∑ q == p
  -----------------------------
  ‚Üí q == refl a

¬∑-cancellation {a = a} p q Œ± =
    begin
      q             ==‚ü® ap (_¬∑ q) (! (¬∑-linv p)) ‚ü©
      ! p ¬∑ p ¬∑ q   ==‚ü® (¬∑-assoc (! p) _ _) ‚ü©
      ! p ¬∑ (p ¬∑ q) ==‚ü® (ap (! p ¬∑_) Œ±) ‚ü©
      ! p ¬∑ p       ==‚ü® ¬∑-linv p ‚ü©
      refl a
    ‚àé
\end{code}

Moving a term from one side to the other is a common task,
so let's define some handy functions for that.

{: .foldable until="5" }
\begin{code}
¬∑-left-to-right-l
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b c : A} {p : a == b} {q : b == c} {r : a == c}
  ‚Üí p ¬∑ q == r
  ------------------
  ‚Üí     q == ! p ¬∑ r

¬∑-left-to-right-l {a = a}{b = b}{c = c} {p} {q} {r} Œ± =
  begin
    q
      ==‚ü® ¬∑-lunit q ‚ü©
    refl b ¬∑ q
      ==‚ü® ap (_¬∑ q) (! (¬∑-linv p)) ‚ü©
    (! p ¬∑ p) ¬∑ q
      ==‚ü® ¬∑-assoc (! p) p q ‚ü©
    ! p ¬∑ (p ¬∑ q)
      ==‚ü® ap (! p ¬∑_) Œ± ‚ü©
    ! p ¬∑ r
  ‚àé
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-left-to-right-r
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b c : A} {p : a == b} {q : b == c} {r : a == c}
  ‚Üí p ¬∑ q == r
  -------------------
  ‚Üí      p == r ¬∑ ! q

¬∑-left-to-right-r {a = a}{b = b}{c = c} {p} {q} {r} Œ± =
  begin
    p
      ==‚ü® ¬∑-runit p ‚ü©
    p ¬∑ refl b
      ==‚ü® ap (p ¬∑_) (! (¬∑-rinv q)) ‚ü©
    p ¬∑ (q ¬∑ ! q)
      ==‚ü® ! (¬∑-assoc p q (! q)) ‚ü©
    (p ¬∑ q) ¬∑ ! q
      ==‚ü® ap (_¬∑ ! q) Œ± ‚ü©
    r ¬∑ ! q
  ‚àé
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-right-to-left-r
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b c : A} {p : a == c} {q : a == b} {r : b == c}
  ‚Üí       p == q ¬∑ r
  -------------------
  ‚Üí p ¬∑ ! r == q

¬∑-right-to-left-r {a = a}{b = b}{c = c} {p} {q} {r} Œ± =
  begin
    p ¬∑ ! r
      ==‚ü® ap (_¬∑ ! r) Œ± ‚ü©
    (q ¬∑ r) ¬∑ ! r
      ==‚ü® ¬∑-assoc q r (! r) ‚ü©
    q ¬∑ (r ¬∑ ! r)
      ==‚ü® ap (q ¬∑_) (¬∑-rinv r) ‚ü©
    q ¬∑ refl b
      ==‚ü® ! (¬∑-runit q) ‚ü©
    q
    ‚àé
\end{code}

{: .foldable until="5" }
\begin{code}
¬∑-right-to-left-l
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b c : A} {p : a == c} {q : a == b} {r : b == c}
  ‚Üí       p == q ¬∑ r
  ------------------
  ‚Üí ! q ¬∑ p == r

¬∑-right-to-left-l {a = a}{b = b}{c = c} {p} {q} {r} Œ± =
  begin
    ! q ¬∑ p
      ==‚ü® ap (! q ¬∑_) Œ± ‚ü©
    ! q ¬∑ (q ¬∑ r)
      ==‚ü® ! (¬∑-assoc (! q) q r) ‚ü©
    ! q ¬∑ q ¬∑ r
      ==‚ü® ap (_¬∑ r) (¬∑-linv q) ‚ü©
    refl b ¬∑ r
      ==‚ü® ! (¬∑-lunit r) ‚ü©
    r
  ‚àé
\end{code}

Finally, when we invert a path composition this is what we got.

{: .foldable until="6" }
\begin{code}
!-¬∑
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {a b : A}
  ‚Üí (p : a == b)
  ‚Üí (q : b == a)
  --------------------------
  ‚Üí ! (p ¬∑ q) == ! q ¬∑ ! p

!-¬∑ idp q = ¬∑-runit (! q)
\end{code}

## Transport

![path](/assets/ipe-images/transport-fiber-minihott.png){: width="60%" }

{: .foldable until="6" }
\begin{code}
transport
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢}
  ‚Üí (C : A ‚Üí Type ‚Ñì‚±º) {a‚ÇÅ a‚ÇÇ : A}
  ‚Üí (p : a‚ÇÅ == a‚ÇÇ)
  -------------------------------
  ‚Üí (C a‚ÇÅ ‚Üí C a‚ÇÇ)

transport C idp = (Œª x ‚Üí x)
\end{code}

\begin{code}
-- synonyms
tr     = transport
transp = transport
\end{code}

Star notation for transport

{: .foldable until="5" }
\begin{code}
_‚ú∂
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {C : A ‚Üí Type ‚Ñì‚±º} {a‚ÇÅ a‚ÇÇ : A}
  ‚Üí (p : a‚ÇÅ == a‚ÇÇ)
  ----------------
  ‚Üí (C a‚ÇÅ ‚Üí C a‚ÇÇ)

_‚ú∂ {‚Ñì·µ¢}{‚Ñì‚±º}{C = C} = transport {‚Ñì·µ¢ = ‚Ñì·µ¢} {‚Ñì‚±º = ‚Ñì‚±º} C
\end{code}

{: .foldable until="5" }
\begin{code}
coe
  : ‚àÄ {‚Ñì} {A B : Type ‚Ñì}
  ‚Üí A == B
  ---------
  ‚Üí (A ‚Üí B)

coe p A = transport (Œª X ‚Üí X) p A
\end{code}

### Pathover

Let be `A : Type`, `a‚ÇÅ, a‚ÇÇ : A`, `C : A ‚Üí Type`, `c‚ÇÅ : C a‚ÇÅ` and `c‚ÇÇ : C a‚ÇÇ`.
Using the same notation from <a href="#hottbook">(Univalent Foundations Program, 2013)</a>, one of the definitions for the
Pathover type is as the shorthand for the path between the transport along a
path `Œ± : a‚ÇÅ = a‚ÇÇ` of the point `c‚ÇÅ : C a‚ÇÅ` and the point `c‚ÇÇ` in the fiber `C
a‚ÇÇ`. That is, a pathover is a term that inhabit the type `transport C Œ± c‚ÇÅ = c‚ÇÇ`
also denoted by `PathOver C Œ± c‚ÇÅ c‚ÇÇ`.

![path](/assets/ipe-images/pathover-3-minihott.png){: width="60%" }

\begin{code}
PathOver
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢}(C : A ‚Üí Type ‚Ñì‚±º) {a‚ÇÅ a‚ÇÇ : A}
  ‚Üí (Œ± : a‚ÇÅ == a‚ÇÇ) (c‚ÇÅ : C a‚ÇÅ) (c‚ÇÇ : C a‚ÇÇ)
  ----------------------------------------
  ‚Üí Type ‚Ñì‚±º

PathOver C Œ± c‚ÇÅ c‚ÇÇ = tr C Œ± c‚ÇÅ == c‚ÇÇ
\end{code}

\begin{code}
infix 30 PathOver
syntax PathOver B p u v = u == v [ B ‚Üì p ]
\end{code}

### Lemmas

Some lemmas on the transport operation

{: .foldable until="6" }
\begin{code}
lift
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {a‚ÇÅ a‚ÇÇ : A} {‚Ñì‚±º} {C : A ‚Üí Type ‚Ñì‚±º}
  ‚Üí (u : C a‚ÇÅ)
  ‚Üí (Œ± : a‚ÇÅ == a‚ÇÇ)
  -----------------------------
  ‚Üí (a‚ÇÅ , u) == (a‚ÇÇ , tr C Œ± u)

lift {a‚ÇÅ = a‚ÇÅ} u idp = refl (a‚ÇÅ , u)
\end{code}

{: .foldable until="6" }
\begin{code}
transport-const
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {a‚ÇÅ  a‚ÇÇ : A} {‚Ñì‚±º} {B : Type ‚Ñì‚±º}
  ‚Üí (p : a‚ÇÅ == a‚ÇÇ)
  ‚Üí (b : B)
  -----------------------
  ‚Üí tr (Œª _ ‚Üí B) p b == b

transport-const idp b = refl b
\end{code}

{: .foldable until="6" }
\begin{code}
transport-concat-r
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {a : A} {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (q : a == x)
  ---------------------------------
  ‚Üí  tr (Œª x ‚Üí a == x) p q == q ¬∑ p

transport-concat-r idp q = ¬∑-runit q
\end{code}

{: .foldable until="6" }
\begin{code}
transport-concat-l
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {a : A} {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (q : x == a)
  ----------------------------------
  ‚Üí tr (Œª x ‚Üí x == a) p q == ! p ¬∑ q

transport-concat-l idp q = idp
\end{code}

{: .foldable until="6" }
\begin{code}
transport-concat
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (q : x == x)
  ---------------------------------------
  ‚Üí tr (Œª x ‚Üí x == x) p q == ! p ¬∑ q ¬∑ p

transport-concat idp q = ¬∑-runit q
\end{code}

{: .foldable until="7" }
\begin{code}
transport-eq-fun
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {‚Ñì‚±º} {B : Type ‚Ñì‚±º}
  ‚Üí (f g : A ‚Üí B) {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (q : f x == g x)
  --------------------------------------------------------
  ‚Üí tr (Œª z ‚Üí f z == g z) p q == ! (ap f p) ¬∑ q ¬∑ (ap g p)

transport-eq-fun f g idp q = ¬∑-runit q
\end{code}

{: .foldable until="6" }
\begin{code}
transport-comp
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢}{‚Ñì‚±º} {a b c : A} {P : A ‚Üí Type ‚Ñì‚±º}
  ‚Üí (p : a == b)
  ‚Üí (q : b == c)
  ---------------------------------------
  ‚Üí ((tr P q) ‚àò (tr P p)) == tr P (p ¬∑ q)

transport-comp {P = P} idp q = refl (transport P q)
\end{code}

{: .foldable until="7" }
\begin{code}
transport-comp-h
  : ‚àÄ {‚Ñì·µ¢} {A : Type ‚Ñì·µ¢} {‚Ñì‚±º} {a b c : A} {P : A ‚Üí Type ‚Ñì‚±º}
  ‚Üí (p : a == b)
  ‚Üí (q : b == c)
  ‚Üí (x : P a)
  -------------------------------------------
  ‚Üí ((tr P q) ‚àò (tr P p)) x == tr P (p ¬∑ q) x

transport-comp-h {P = P} idp q x = refl (transport P q x)
\end{code}

{: .foldable until="6" }
\begin{code}
transport-eq-fun-l
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {b : B} (f : A ‚Üí B) {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (q : f x == b)
  -------------------------------------------
  ‚Üí tr (Œª z ‚Üí f z == b) p q == ! (ap f p) ¬∑ q

transport-eq-fun-l {b = b} f p q =
  begin
    transport (Œª z ‚Üí f z == b) p q   ==‚ü® transport-eq-fun f (Œª _ ‚Üí b) p q ‚ü©
    ! (ap f p) ¬∑ q ¬∑ ap (Œª _ ‚Üí b) p  ==‚ü® ap (! (ap f p) ¬∑ q ¬∑_) (ap-const p) ‚ü©
    ! (ap f p) ¬∑ q ¬∑ idp             ==‚ü® ! (¬∑-runit _) ‚ü©
    ! (ap f p) ¬∑ q
  ‚àé
\end{code}

{: .foldable until="7" }
\begin{code}
transport-eq-fun-r
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {b : B}
  ‚Üí (g : A ‚Üí B) {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (q : b == g x)
  ------------------------------------------------
  ‚Üí tr (Œª z ‚Üí b == g z) p q == q ¬∑ (ap g p)

transport-eq-fun-r {b = b} g p q =
  begin
    transport (Œª z ‚Üí b == g z) p q    ==‚ü® transport-eq-fun (Œª _ ‚Üí b) g p q ‚ü©
    ! (ap (Œª _ ‚Üí b) p) ¬∑ q ¬∑ ap g p   ==‚ü® ¬∑-assoc (! (ap (Œª _ ‚Üí b) p)) q (ap g p) ‚ü©
    ! (ap (Œª _ ‚Üí b) p) ¬∑ (q ¬∑ ap g p) ==‚ü® ap (Œª u ‚Üí ! u ¬∑ (q ¬∑ ap g p)) (ap-const p) ‚ü©
    (q ¬∑ ap g p)
  ‚àé
\end{code}

{: .foldable until="6" }
\begin{code}
transport-inv
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {X : Type ‚Ñì·µ¢}{A : X ‚Üí Type ‚Ñì‚±º}{x y : X}
  ‚Üí (p : x == y)
  ‚Üí {a : A y}
  --------------------------------------
  ‚Üí tr (Œª v ‚Üí A v) p (tr A (! p) a) == a

transport-inv {A = A}  idp {a = a} =
  begin
    tr (Œª v ‚Üí A v) idp (tr A (! idp) a)
      ==‚ü® idp ‚ü©
    tr A (! idp ¬∑ idp) a
      ==‚ü®‚ü©
    tr A idp a
      ==‚ü® idp ‚ü©
    a
  ‚àé
\end{code}

{: .foldable until="6" }
\begin{code}
coe-inv-l
  : ‚àÄ {‚Ñì} {A B : Type ‚Ñì}
  ‚Üí (p : A == B)
  ‚Üí (b : B)
  --------------------------------------------
  ‚Üí tr (Œª v ‚Üí v) p (tr (Œª v ‚Üí v) (! p) b) == b

coe-inv-l idp b = idp
\end{code}

{: .foldable until="6" }
\begin{code}
coe-inv-r
  : ‚àÄ {‚Ñì} {A B : Type ‚Ñì}
  ‚Üí (p : A == B)
  ‚Üí (a : A)
  -----------------------------------------------------------
  ‚Üí tr (Œª v ‚Üí v) (! p) (tr (Œª v ‚Üí v) p a) == a

coe-inv-r idp b = idp
\end{code}

{: .foldable until="7" }
\begin{code}
transport-family
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {P : B ‚Üí Type ‚Ñì‚Çñ}
  ‚Üí {f : A ‚Üí B} ‚Üí {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (u : P (f x))
  -----------------------------------
  ‚Üí tr (P ‚àò f) p u == tr P (ap f p) u

transport-family idp u = idp
\end{code}

{: .foldable until="6" }
\begin{code}
transport-family-id
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {P : A ‚Üí Type ‚Ñì‚Çñ} ‚Üí {x y : A}
  ‚Üí (p : x == y)
  ‚Üí (u : P x)
  ----------------------------------------------
  ‚Üí transport (Œª a ‚Üí P a) p u == transport P p u

transport-family-id idp u = idp
\end{code}

{: .foldable until="6" }
\begin{code}
transport-fun
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {X : Type ‚Ñì·µ¢} {x y : X} {A : X ‚Üí Type ‚Ñì‚±º} {B : X ‚Üí Type ‚Ñì‚Çñ}
  ‚Üí (p : x == y)
  ‚Üí (f : A x ‚Üí B x)
  -----------------------------------------------------------------
  ‚Üí tr (Œª x ‚Üí (A x ‚Üí B x)) p f == (Œª x ‚Üí tr B p (f (tr A (! p) x)))

transport-fun idp f = idp
\end{code}

\begin{code}
-- synonyms
back-and-forth = transport-fun
\end{code}

![path](/assets/ipe-images/transport-fun.png){: width="100%" }

{: .foldable until="7" }
\begin{code}
transport-fun-h
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {X : Type ‚Ñì·µ¢} {A : X ‚Üí Type ‚Ñì‚±º} {B : X ‚Üí Type ‚Ñì‚Çñ}
  ‚Üí {x y : X}
  ‚Üí (p : x == y) ‚Üí (f : A x ‚Üí B x)
  ‚Üí (b : A y)
  --------------------------------------------------------------
  ‚Üí (tr (Œª x ‚Üí (A x ‚Üí B x)) p f) b == tr B p (f (tr A (! p) b))

transport-fun-h idp f b = idp
\end{code}

\begin{code}
-- synonyms
back-and-forth-h = transport-fun-h
\end{code}

Now, when we transport dependent functions this is what we got:

![path](/assets/ipe-images/transport-fun-dependent.png){: width="100%" }

{: .foldable until="9" }
\begin{code}
transport-fun-dependent-h
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {X : Type ‚Ñì·µ¢} {A : X ‚Üí Type ‚Ñì‚±º}
  ‚Üí {B : (x : X) ‚Üí (a : A x) ‚Üí Type ‚Ñì‚Çñ} {x y : X}
  ‚Üí (p : x == y)
  ‚Üí (f : (a : A x) ‚Üí B x a)
  ---------------------------------------------------------------------
  ‚Üí (a' : A y)
  ‚Üí (tr (Œª x ‚Üí (a : A x) ‚Üí B x a) p f) a'
    == tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (! lift a' (! p)) (f (tr A (! p) a'))

transport-fun-dependent-h idp f a' = idp
\end{code}

\begin{code}
-- synonyms
dependent-back-and-forth-h = transport-fun-dependent-h
\end{code}

{: .foldable until="9" }
\begin{code}
transport-fun-dependent
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {X : Type ‚Ñì·µ¢} {A : X ‚Üí Type ‚Ñì‚±º}
  ‚Üí {B : (x : X) ‚Üí (a : A x) ‚Üí Type ‚Ñì‚Çñ} {x y : X}
  ‚Üí (p : x == y)
  ‚Üí (f : (a : A x) ‚Üí B x a)
  ---------------------------------------------------------------------
  ‚Üí (tr (Œª x ‚Üí (a : A x) ‚Üí B x a) p f)
    == Œª (a' : A y)
      ‚Üí tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (! lift a' (! p)) (f (tr A (! p) a'))

transport-fun-dependent idp f = idp
\end{code}

\begin{code}
-- synonyms
dependent-back-and-forth = transport-fun-dependent
\end{code}

Action on PathOvers, this was suggested by Fredrik Nordvall:

{: .foldable until="9"}
\begin{code}
apOver
  : {A A' : Type‚ÇÄ} {C : A ‚Üí Type‚ÇÄ} {C' : A' ‚Üí Type‚ÇÄ}  -- types
  ‚Üí {a a' : A} {b : C a} {b' : C a'}                  -- points
  ‚Üí (f : A ‚Üí A')
  ‚Üí (g : {x : A} ‚Üí C x ‚Üí C' (f x))
  ‚Üí (p : a == a')
  ‚Üí b == b' [ C ‚Üì p ]
  --------------------------------
  ‚Üí g b == g b' [ C' ‚Üì ap f p ]

apOver f g idp q = ap g q
\end{code}

## Basic type lemmas

### Sigma type

Our context:

\begin{code}
module Sigma {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {P : A ‚Üí Type ‚Ñì‚±º} where
\end{code}

Two dependent pairs are equal if they are componentwise equal.

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  Œ£-componentwise
    : {v w : Œ£ A P}
    ‚Üí v == w
    ----------------------------------------------
    ‚Üí Œ£ (œÄ‚ÇÅ v == œÄ‚ÇÅ w) (Œª p ‚Üí (p ‚ú∂) (œÄ‚ÇÇ v) == œÄ‚ÇÇ w)

  Œ£-componentwise  idp = (idp , idp)
\end{code}

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  Œ£-bycomponents
    : {v w : Œ£ A P}
    ‚Üí Œ£ (œÄ‚ÇÅ v == œÄ‚ÇÅ w) (Œª p ‚Üí (p ‚ú∂) (œÄ‚ÇÇ v) == œÄ‚ÇÇ w)
    -----------------------------------------------
    ‚Üí v == w

  Œ£-bycomponents (idp , idp) = idp

  -- synonym of Œ£-bycomponents
  pair= = Œ£-bycomponents
\end{code}

A trivial consequence is the following identification:

{: .foldable until="6"}
\begin{code}
-- Lemma.
  lift-pair=
    : ‚àÄ {x y : A} {u : P x}
    ‚Üí (p : x == y)
    --------------------------------------------------------
    ‚Üí lift {A = A}{C = P} u p == pair= (p , refl (tr P p u))

  lift-pair= idp = idp
\end{code}

\begin{code}
-- Uniqueness principle property for products
  uppt : (x : Œ£ A P) ‚Üí (œÄ‚ÇÅ x , œÄ‚ÇÇ x) == x
  uppt (a , b) = idp
\end{code}

{: .foldable until="6"}
\begin{code}
-- Lemma.
  Œ£-ap-œÄ‚ÇÅ
    : {a‚ÇÅ a‚ÇÇ : A} {b‚ÇÅ : P a‚ÇÅ} {b‚ÇÇ : P a‚ÇÇ}
    ‚Üí (Œ± : a‚ÇÅ == a‚ÇÇ)
    ‚Üí (Œ≥ : transport P Œ± b‚ÇÅ == b‚ÇÇ)
    ------------------------------
    ‚Üí ap œÄ‚ÇÅ (pair= (Œ± , Œ≥)) == Œ±

  Œ£-ap-œÄ‚ÇÅ idp idp = idp

  -- synonym for this lemma
  ap-œÄ‚ÇÅ-pair= = Œ£-ap-œÄ‚ÇÅ
\end{code}

\begin{code}
open Sigma public
\end{code}

{: .foldable until="10"}
\begin{code}
transport-fun-dependent-bezem
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {X : Type ‚Ñì·µ¢} {A : X ‚Üí Type ‚Ñì‚±º}
      {B : (x : X) ‚Üí (a : A x) ‚Üí Type ‚Ñì‚±º} {x y : X}
  ‚Üí (p : x == y)
  ‚Üí (f : (a : A x) ‚Üí B x a)
  ‚Üí (a' : A y)
  ----------------------------------------------------------
  ‚Üí (tr (Œª x ‚Üí (a : A x) ‚Üí B x a) p f) a'
    == tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w))
          (pair= (p , transport-inv p )) (f (tr A (! p) a'))

transport-fun-dependent-bezem idp f a' = idp
\end{code}

### Cartesian product

\begin{code}
module CartesianProduct {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where
\end{code}

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  prodComponentwise
    : {x y : A √ó B}
    ‚Üí (x == y)
    ---------------------------------
    ‚Üí (œÄ‚ÇÅ x == œÄ‚ÇÅ y) √ó (œÄ‚ÇÇ x == œÄ‚ÇÇ y)

  prodComponentwise {x = x} idp = refl (œÄ‚ÇÅ x) , refl (œÄ‚ÇÇ x)
\end{code}

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  prodByComponents
    : {x y : A √ó B}
    ‚Üí (œÄ‚ÇÅ x == œÄ‚ÇÅ y) √ó (œÄ‚ÇÇ x == œÄ‚ÇÇ y)
    ---------------------------------
    ‚Üí (x == y)

  prodByComponents {x = a , b} (idp , idp) = refl (a , b)
\end{code}

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  prodCompInverse
    : {x y : A √ó B}
    ‚Üí (b : (œÄ‚ÇÅ x == œÄ‚ÇÅ y) √ó (œÄ‚ÇÇ x == œÄ‚ÇÇ y))
    ---------------------------------------------
    ‚Üí prodComponentwise (prodByComponents b) == b

  prodCompInverse {x} (idp , idp) = refl (refl (œÄ‚ÇÅ x) , refl (œÄ‚ÇÇ x))
\end{code}

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  prodByCompInverse
    : {x y : A √ó B}
    ‚Üí (b : x == y)
    ---------------------------------------------
    ‚Üí prodByComponents (prodComponentwise b) == b

  prodByCompInverse {x = x} idp = refl (refl x)
\end{code}

\begin{code}
open CartesianProduct
\end{code}

## Action on dependent paths

{: .foldable until="5"}
\begin{code}
apd
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢}  {P : A ‚Üí Type ‚Ñì‚±º} {a b : A}
  ‚Üí (f : (a : A) ‚Üí P a) ‚Üí (p : a == b)
  ------------------------------------
  ‚Üí transport P p (f a) == f b

apd f idp = idp
\end{code}

## Homotopy

> In a type-theoretical sense, a homotopy between two
> functions is a family of equalities between their applications.

The context:
\begin{code}
module Homotopy {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {P : A ‚Üí Type ‚Ñì‚±º} where
\end{code}

Let $$f , g : \prod\limits_{(x:A)} P(x)$$ be two sections of a
type family $$P : A \to \mathcal{U}$$. A **homotopy** from $$f$$ to $$g$$
is a dependent function of type

{: .equation }
  $$ (f \sim g) :\equiv \prod\limits_{x : A} (f(x) = g(x)). $$

{: .foldable until="5"}
\begin{code}
  -- Lemma.
  homotopy
    : (f g : Œ† A P)
    ---------------
    ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)

  homotopy f g = ‚àÄ (x : A) ‚Üí f x == g x
\end{code}

\begin{code}
  -- Usual notation for homotopy
  _‚àº_ : (f g : ((x : A) ‚Üí P x)) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
  f ‚àº g = homotopy f g
\end{code}

{: .foldable until="5"}
\begin{code}
  -- Homotopy is an equivalence relation
  h-refl
    : (f : Œ† A P)
    -------------
    ‚Üí f ‚àº f

  h-refl f x = idp
\end{code}

{: .foldable until="6"}
\begin{code}
  -- Lemma.
  h-sym
    : (f g : Œ† A P)
    ‚Üí f ‚àº g
    -------
    ‚Üí g ‚àº f

  h-sym _ _ e x = ! (e x)
\end{code}

{: .foldable until="7"}
\begin{code}
  -- Lemma.
  h-comp
    : {f g h : Œ† A P}
    ‚Üí f ‚àº g
    ‚Üí g ‚àº h
    -------
    ‚Üí f ‚àº h

  h-comp u v x = (u x) ¬∑ (v x)
\end{code}

{: .foldable until="7"}
\begin{code}
  -- synonym for h-comp
  _‚óè_
    : {f g h : Œ† A P}
    ‚Üí f ‚àº g
    ‚Üí g ‚àº h
    -------
    ‚Üí f ‚àº h

  Œ± ‚óè Œ≤ = h-comp Œ± Œ≤
\end{code}

\begin{code}
open Homotopy public
\end{code}

### Composition with homotopies

\begin{code}
module HomotopyComposition {‚Ñì·µ¢ ‚Ñì‚±º ‚Ñì‚Çñ} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} {C : Type ‚Ñì‚Çñ} where
\end{code}

{: .foldable until="8"}
\begin{code}
  -- Lemma.
  hl-comp
    : {f g : A ‚Üí B}
    ‚Üí {j k : B ‚Üí C}
    ‚Üí f ‚àº g
    ‚Üí j ‚àº k
    -------------------
    ‚Üí (j ‚àò f) ‚àº (k ‚àò g)

  hl-comp {g = g}{j = j} f-g j-k = Œª x ‚Üí ap j (f-g x) ¬∑ j-k (g x)
\end{code}


{: .foldable until="7"}
\begin{code}
  -- Lemma.
  rcomp-‚àº
    : (f : A ‚Üí B)
    ‚Üí {j k : B ‚Üí C}
    ‚Üí j ‚àº k
    -------------------
    ‚Üí (j ‚àò f) ‚àº (k ‚àò f)

  rcomp-‚àº f j-k = hl-comp (h-refl f) j-k
\end{code}

{: .foldable until="7"}
\begin{code}
  -- Lemma.
  lcomp-‚àº
    : {f g : A ‚Üí B}
    ‚Üí (j : B ‚Üí C)
    ‚Üí f ‚àº g
    -------------------
    ‚Üí (j ‚àò f) ‚àº (j ‚àò g)

  lcomp-‚àº j Œ± = hl-comp Œ± (h-refl j)
\end{code}

\begin{code}
open HomotopyComposition
\end{code}

### Naturality

\begin{code}
module Naturality {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where
\end{code}

Homotopy is natural, meaning that it satisfies the following
square commutative diagram.

![path](/assets/ipe-images/h-naturality.png){: width="40%" }

{: .foldable until="7"}
\begin{code}
  -- Lemma.
  h-naturality
    : {f g : A ‚Üí B} ‚Üí {x y : A}
    ‚Üí (H : f ‚àº g)
    ‚Üí (p : x == y)
    ------------------------------
    ‚Üí H x ¬∑ ap g p == ap f p ¬∑ H y

  h-naturality {x = x} H idp = ! (¬∑-runit (H x))
open Naturality
\end{code}

A particular case of naturality on the identity function.

{: .foldable until="5"}
\begin{code}
h-naturality-id
  : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {f : A ‚Üí A} ‚Üí {x : A}
  ‚Üí (H : f ‚àº id)
  -----------------------
  ‚Üí H (f x) == ap f (H x)

h-naturality-id {f = f} {x = x} H =
  begin
    H (f x)
      ==‚ü® ¬∑-runit (H (f x)) ‚ü©
    H (f x) ¬∑ refl (f x)
      ==‚ü® ap (H (f x) ¬∑_) (! (¬∑-rinv (H x))) ‚ü©
    H (f x) ¬∑ ((H x) ¬∑ (! (H x)))
      ==‚ü® ap (H (f x) ¬∑_) (ap (_¬∑ (! (H x))) (! ap-id (H x))) ‚ü©
    H (f x) ¬∑ (ap id (H x) ¬∑ ! (H x))
      ==‚ü® ! (¬∑-assoc (H (f x)) (ap id (H x)) (! (H x))) ‚ü©
    (H (f x) ¬∑ ap id (H x)) ¬∑ ! (H x)
      ==‚ü® ¬∑-right-to-left-r (h-naturality H (H x)) ‚ü©
    ap f (H x)
  ‚àé
\end{code}

## .... REVIWING .... BELOW

## Fibers

Contractible types with a center of contraction.

\begin{code}
module Fibers {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º}  where

  -- The fiber of a map over a point is given by
  fib
    : (f : A ‚Üí B)
    ‚Üí (b : B)
    ---------------
    ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)

  fib f b = Œ£ A (Œª a ‚Üí f a == b)


  -- A function applied over the fiber returns the original point
  fib-eq : {f : A ‚Üí B} ‚Üí {b : B} ‚Üí (h : fib f b) ‚Üí f (œÄ‚ÇÅ h) == b
  fib-eq (a , Œ±) = Œ±

  -- Each point is on the fiber of its image
  fib-image : {f : A ‚Üí B} ‚Üí {a : A} ‚Üí fib f (f a)
  fib-image {f} {a} = a , refl (f a)

open Fibers public
\end{code}

## Contractible types

\begin{code}
-- Contractible.  Contractible types with a center of contraction.
module Contractible where

  -- Contractible types. A contractible type is a type such that every
  -- element is equal to a center of contraction.
  isContr : ‚àÄ {‚Ñì}  (A : Type ‚Ñì) ‚Üí Type ‚Ñì
  isContr A = Œ£ A (Œª a ‚Üí ((x : A) ‚Üí a == x))
open Contractible public

\end{code}

## Equivalence

\begin{code}
module Equivalence where

  module DefinitionOfEquivalence {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where
    -- Contractible maps. A map is contractible if the fiber in any
    -- point is contractible, that is, each element has a unique
    -- preimage.
    isContrMap : (f : A ‚Üí B) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
    isContrMap f = (b : B) ‚Üí isContr (fib f b)
\end{code}

\begin{code}
    -- There exists an equivalence between two types if there exists a
    -- contractible function between them.
    isEquiv : (f : A ‚Üí B) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
    isEquiv = isContrMap
  open DefinitionOfEquivalence public
\end{code}

\begin{code}
  -- Equivalence of types.
  _‚âÉ_ : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}  (A : Type ‚Ñì·µ¢) (B : Type ‚Ñì‚±º) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
  A ‚âÉ B = Œ£ (A ‚Üí B) isEquiv
\end{code}

\begin{code}
  module EquivalenceMaps {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where

    -- Maps of an equivalence
    lemap : A ‚âÉ B ‚Üí (A ‚Üí B)
    lemap = œÄ‚ÇÅ

    ‚âÉ-to-‚Üí = lemap
    fun‚âÉ   = lemap

    remap : A ‚âÉ B ‚Üí (B ‚Üí A)
    remap (f , contrf) b = œÄ‚ÇÅ (œÄ‚ÇÅ (contrf b))

    -- The maps of an equivalence are inverses in particular
    lrmap-inverse : (eq : A ‚âÉ B) ‚Üí {b : B} ‚Üí (lemap eq) ((remap eq) b) == b
    lrmap-inverse (f , eqf) {b} = fib-eq (œÄ‚ÇÅ (eqf b))

    rlmap-inverse : (eq : A ‚âÉ B) ‚Üí {a : A} ‚Üí (remap eq) ((lemap eq) a) == a
    rlmap-inverse (f , eqf) {a} = ap œÄ‚ÇÅ ((œÄ‚ÇÇ (eqf (f a))) fib-image)

    lrmap-inverse-h : (eq : A ‚âÉ B) ‚Üí ((lemap eq) ‚àò (remap eq)) ‚àº id
    lrmap-inverse-h eq = Œª x ‚Üí lrmap-inverse eq {x}

    rlmap-inverse-h : (eq : A ‚âÉ B) ‚Üí ((remap eq) ‚àò (lemap eq)) ‚àº id
    rlmap-inverse-h eq = Œª x ‚Üí rlmap-inverse eq {x}
  open EquivalenceMaps public
\end{code}

\begin{code}
open Equivalence public
\end{code}

## Function extensionality

\begin{code}

module FunExt {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢}
  {B : A ‚Üí Type ‚Ñì‚±º} {f g : (a : A) ‚Üí B a} where
\end{code}

\begin{code}
  -- Application of an homotopy
  happly : f == g ‚Üí ((x : A) ‚Üí f x == g x)
  happly idp x = refl (f x)
\end{code}

\begin{code}
  -- The axiom of function extensionality postulates that the
  -- application of homotopies is an equivalence.
  postulate axiomFunExt : isEquiv happly
\end{code}

\begin{code}
  eqFunExt : (f == g) ‚âÉ ((x : A) ‚Üí f x == g x)
  eqFunExt = happly , axiomFunExt
\end{code}

\begin{code}
  -- From this, the usual notion of function extensionality follows.
  funext : ((x : A) ‚Üí f x == g x) ‚Üí f == g
  funext = remap eqFunExt
\end{code}

\begin{code}
  -- Beta and eta rules for function extensionality
  funext-Œ≤ : (h : ((x : A) ‚Üí f x == g x)) ‚Üí happly (funext h) == h
  funext-Œ≤ h = lrmap-inverse eqFunExt
\end{code}

\begin{code}
  funext-Œ∑ : (p : f == g) ‚Üí funext (happly p) == p
  funext-Œ∑ p = rlmap-inverse eqFunExt
\end{code}

\begin{code}
open FunExt public
\end{code}

- Function extensionality in the transport case

\begin{code}
module FunExt-Transport
  {‚Ñì·µ¢ ‚Ñì‚±º} {X : Type ‚Ñì·µ¢} {A B : X ‚Üí Type ‚Ñì‚±º} {x y : X} where
\end{code}

\begin{code}
  funext-transport
    : (p : x == y) ‚Üí (f : A x ‚Üí B x) ‚Üí (g : A y ‚Üí B y)
    ------------------------------------------------------------
    ‚Üí ((p ‚ú∂) f == g) ‚âÉ ((a : A(x)) ‚Üí (p ‚ú∂) (f a) == g ((p ‚ú∂) a))

  funext-transport idp f g = eqFunExt
\end{code}

\begin{code}
  funext-transport-l
    : (p : x == y)
    ‚Üí (f : A x ‚Üí B x)
    ‚Üí (g : A y ‚Üí B y)
    ‚Üí ((p ‚ú∂) f == g)
    -------------------------------------------
    ‚Üí ((a : A(x)) ‚Üí (p ‚ú∂) (f a) == g ((p ‚ú∂) a))

  funext-transport-l p f g = lemap (funext-transport p _ _)
\end{code}

\begin{code}
  funext-transport-r
    : (p : x == y)
    ‚Üí (f : A x ‚Üí B x)
    ‚Üí (g : A y ‚Üí B y)
    ‚Üí ((a : A(x)) ‚Üí (p ‚ú∂) (f a) == g ((p ‚ú∂) a))
    -------------------------------------------
    ‚Üí ((p ‚ú∂) f == g)

  funext-transport-r p f g = remap (funext-transport p _ _)
\end{code}

\begin{code}
open FunExt-Transport public
\end{code}

\begin{code}
module FunExt-Transport-DFun
  {‚Ñì·µ¢ ‚Ñì‚±º} {X : Type ‚Ñì·µ¢} {A : X ‚Üí Type ‚Ñì‚±º}{B : (x : X) ‚Üí A x ‚Üí Type ‚Ñì‚±º}{x y : X}
  where

  -- Lemma 2.9.7
  funext-transport-dfun
    : (p : x == y)
    ‚Üí (f : (a : A x) ‚Üí B x a)
    ‚Üí (g : (a : A y) ‚Üí B y a)
    ----------------------------------------------------------------------------
    ‚Üí ((p ‚ú∂) f == g)
      ‚âÉ ((a : A x) ‚Üí tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ‚ú∂) a))

  funext-transport-dfun idp f g = eqFunExt

  funext-transport-dfun-l
    : (p : x == y) ‚Üí (f : (a : A x) ‚Üí B x a) ‚Üí (g : (a : A y) ‚Üí B y a)
    ‚Üí ((p ‚ú∂) f == g)
    ---------------------------------------------------------------------------
    ‚Üí ((a : A x) ‚Üí tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ‚ú∂) a))

  funext-transport-dfun-l p f g = lemap (funext-transport-dfun p _ _)

  funext-transport-dfun-r
    : (p : x == y)
    ‚Üí (f : (a : A x) ‚Üí B x a)
    ‚Üí (g : (a : A y) ‚Üí B y a)
    ‚Üí ((a : A x) ‚Üí tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (pair= (p , refl (tr A p a))) (f a) == g ((p ‚ú∂) a))
    --------------------------------------------------------------------------
    ‚Üí ((p ‚ú∂) f == g)

  funext-transport-dfun-r p f g = remap (funext-transport-dfun p _ _)
open FunExt-Transport-DFun public
\end{code}

## Decidable equality

A type has decidable equality if any two of its
elements are equal or different. This would be a particular
instance of the Law of Excluded Middle that holds even if we do not
assume Excluded Middle.

\begin{code}
module DecidableEquality {‚Ñì} where

  -- A type has decidable equality if we can prove that any two of its
  -- elements are equal or different.
  decEq : (A : Type ‚Ñì) ‚Üí Type ‚Ñì
  decEq A = (a b : A) ‚Üí (a == b) + ¬¨ (a == b)

  -- The product of types with decidable equality is a type with
  -- decidable equality.
  decEqProd : {A B : Type ‚Ñì} ‚Üí decEq A ‚Üí decEq B ‚Üí decEq (A √ó B)
  decEqProd da db (a1 , b1) (a2 , b2) with (da a1 a2) | (db b1 b2)
  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inl beq = inl (prodByComponents (aeq , beq))
  decEqProd da db (a1 , b1) (a2 , b2) | inl aeq | inr bnq = inr Œª b ‚Üí bnq (ap œÄ‚ÇÇ b)
  decEqProd da db (a1 , b1) (a2 , b2) | inr anq | u       = inr Œª b ‚Üí anq (ap œÄ‚ÇÅ b)

open DecidableEquality
\end{code}

## Hlevels

### Propositions

Propositions as described on the main text. A type
is a proposition if we can create a function making any two of its
elements equal. We create a type of propositions.

\begin{code}

module Propositions where

  -- A type is a mere proposition if any two inhabitants of the type
  -- are equal
  isProp : ‚àÄ {‚Ñì}  (A : Type ‚Ñì) ‚Üí Type ‚Ñì
  isProp A = ((x y : A) ‚Üí x == y)

  -- The type of mere propositions
  hProp : ‚àÄ {‚Ñì} ‚Üí Type (lsuc ‚Ñì)
  hProp {‚Ñì} = Œ£ (Type ‚Ñì) isProp


  -- The dependent function type to proposition types is itself a
  -- proposition.
  piProp : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} ‚Üí {A : Type ‚Ñì·µ¢} ‚Üí {B : A ‚Üí Type ‚Ñì‚±º}
         ‚Üí ((a : A) ‚Üí isProp (B a)) ‚Üí isProp ((a : A) ‚Üí B a)
  piProp props f g = funext Œª a ‚Üí props a (f a) (g a)

  -- The product of propositions is itself a proposition.
  isProp-prod : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} ‚Üí {A : Type ‚Ñì·µ¢} ‚Üí {B : Type ‚Ñì‚±º}
              ‚Üí isProp A ‚Üí isProp B ‚Üí isProp (A √ó B)
  isProp-prod p q x y = prodByComponents ((p _ _) , (q _ _))

open Propositions public
\end{code}

### Sets

Sets are types without any higher dimensional structure, all
parallel paths are homotopic and the homotopy is given by a
continuous function on the two paths.

\begin{code}
module Sets where

  -- A type is a "set" by definition if any two equalities on the type
  -- are equal.
  isSet : ‚àÄ {‚Ñì}  (A : Type ‚Ñì) ‚Üí Type ‚Ñì
  isSet A = (x y : A) ‚Üí isProp (x == y)

  -- The type of sets.
  hSet : ‚àÄ {‚Ñì} ‚Üí Type (lsuc ‚Ñì)
  hSet {‚Ñì} = Œ£ (Type ‚Ñì) isSet

  -- Product of sets is a set.
  isSet-prod : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}  {A : Type ‚Ñì·µ¢} ‚Üí {B : Type ‚Ñì‚±º}
             ‚Üí isSet A ‚Üí isSet B ‚Üí isSet (A √ó B)
  isSet-prod sa sb (a , b) (c , d) p q = begin
     p
      ==‚ü® inv (prodByCompInverse p) ‚ü©
     prodByComponents (prodComponentwise p)
      ==‚ü® ap prodByComponents (prodByComponents (sa a c _ _ , sb b d _ _)) ‚ü©
     prodByComponents (prodComponentwise q)
      ==‚ü® prodByCompInverse q ‚ü©
     q
    ‚àé

open Sets public
\end{code}

### Lemmas

Higher levels of the homotopical structure, where the
first levels are:

- Contractible types (0)
- Propositions (1)
- Sets (2)

They would correspond to homotopy levels. We only work with
these first levels.

\begin{code}

module HLevels where

  -- Propositions are Sets.
  propIsSet : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí isProp A ‚Üí isSet A
  propIsSet {A = A} f a _ p q = lemma p ¬∑ inv (lemma q)
    where
      triang : {y z : A} {p : y == z} ‚Üí (f a y) ¬∑ p == f a z
      triang {y}{p = idp} = inv (¬∑-runit (f a y))

      lemma : {y z : A} (p : y == z) ‚Üí p == ! (f a y) ¬∑ (f a z)
      lemma {y} {z} p =
        begin
          p                       ==‚ü® ap (_¬∑ p) (inv (¬∑-linv (f a y))) ‚ü©
          ! (f a y) ¬∑ f a y ¬∑ p   ==‚ü® ¬∑-assoc (! (f a y)) (f a y) p ‚ü©
          ! (f a y) ¬∑ (f a y ¬∑ p) ==‚ü® ap (! (f a y) ¬∑_) triang ‚ü©
          ! (f a y) ¬∑ (f a z)
        ‚àé

  -- Contractible types are Propositions.
  contrIsProp : ‚àÄ {‚Ñì}  {A : Type ‚Ñì} ‚Üí isContr A ‚Üí isProp A
  contrIsProp (a , p) x y = ! (p x) ¬∑ p y

  -- To be contractible is itself a proposition.
  isContrIsProp : ‚àÄ {‚Ñì}  {A : Type ‚Ñì} ‚Üí isProp (isContr A)
  isContrIsProp {_} {A} (a , p) (b , q) = Œ£-bycomponents (inv (q a) , piProp (AisSet b) _ q)
    where
      AisSet : isSet A
      AisSet = propIsSet (contrIsProp (a , p))

open HLevels public
\end{code}


Equivalence of two types is a proposition
Moreover, equivalences preserve propositions.

\begin{code}

module EquivalenceProp {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where

  -- Contractible maps are propositions
  isContrMapIsProp : (f : A ‚Üí B) ‚Üí isProp (isContrMap f)
  isContrMapIsProp f = piProp Œª a ‚Üí isContrIsProp

  isEquivIsProp : (f : A ‚Üí B) ‚Üí isProp (isEquiv f)
  isEquivIsProp = isContrMapIsProp

  -- Equality of same-morphism equivalences
  sameEqv : {Œ± Œ≤ : A ‚âÉ B} ‚Üí œÄ‚ÇÅ Œ± == œÄ‚ÇÅ Œ≤ ‚Üí Œ± == Œ≤
  sameEqv {(f , œÉ)} {(g , œÑ)} p = Œ£-bycomponents (p , (isEquivIsProp g _ œÑ))

  -- Equivalences preserve propositions
  isProp-‚âÉ : (A ‚âÉ B) ‚Üí isProp A ‚Üí isProp B
  isProp-‚âÉ eq prop x y =
    begin
      x                       ==‚ü® inv (lrmap-inverse eq) ‚ü©
      lemap eq ((remap eq) x) ==‚ü® ap (Œª u ‚Üí lemap eq u) (prop _ _) ‚ü©
      lemap eq ((remap eq) y) ==‚ü® lrmap-inverse eq ‚ü©
      y
    ‚àé

open EquivalenceProp public
\end{code}


### Half-adjoints

Half-adjoints are an auxiliary notion that helps us
to define a suitable notion of equivalence, meaning that it is a
proposition and that it captures the usual notion of equivalence.

\begin{code}
module Halfadjoints {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where

  -- Half adjoint equivalence.
  record ishae (f : A ‚Üí B) : Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º) where
    constructor hae
    field
      g : B ‚Üí A
      Œ∑ : (g ‚àò f) ‚àº id
      Œµ : (f ‚àò g) ‚àº id
      œÑ : (a : A) ‚Üí ap f (Œ∑ a) == Œµ (f a)

  -- Half adjoint equivalences give contractible fibers.
  ishae-contr : (f : A ‚Üí B) ‚Üí ishae f ‚Üí isContrMap f
  ishae-contr f (hae g Œ∑ Œµ œÑ) y = ((g y) , (Œµ y)) , contra
    where
      lemma : (c c' : fib f y) ‚Üí Œ£ (œÄ‚ÇÅ c == œÄ‚ÇÅ c') (Œª Œ≥ ‚Üí (ap f Œ≥) ¬∑ œÄ‚ÇÇ c' == œÄ‚ÇÇ c) ‚Üí c == c'
      lemma c c' (p , q) = Œ£-bycomponents (p , lemma2)
        where
          lemma2 : transport (Œª z ‚Üí f z == y) p (œÄ‚ÇÇ c) == œÄ‚ÇÇ c'
          lemma2 =
            begin
              transport (Œª z ‚Üí f z == y) p (œÄ‚ÇÇ c)
                ==‚ü® transport-eq-fun-l f p (œÄ‚ÇÇ c) ‚ü©
              inv (ap f p) ¬∑ (œÄ‚ÇÇ c)
                ==‚ü® ap (inv (ap f p) ¬∑_) (inv q) ‚ü©
              inv (ap f p) ¬∑ ((ap f p) ¬∑ (œÄ‚ÇÇ c'))
                ==‚ü® inv (¬∑-assoc (inv (ap f p)) (ap f p) (œÄ‚ÇÇ c')) ‚ü©
              inv (ap f p) ¬∑ (ap f p) ¬∑ (œÄ‚ÇÇ c')
                ==‚ü® ap (_¬∑ (œÄ‚ÇÇ c')) (¬∑-linv (ap f p)) ‚ü©
              œÄ‚ÇÇ c'
            ‚àé

      contra : (x : fib f y) ‚Üí (g y , Œµ y) == x
      contra (x , p) = lemma (g y , Œµ y) (x , p) (Œ≥ , lemma3)
        where
          Œ≥ : g y == x
          Œ≥ = inv (ap g p) ¬∑ Œ∑ x

          lemma3 : (ap f Œ≥ ¬∑ p) == Œµ y
          lemma3 =
            begin
              ap f Œ≥ ¬∑ p
                ==‚ü® ap (_¬∑ p) (ap-¬∑ f (inv (ap g p)) (Œ∑ x)) ‚ü©
              ap f (inv (ap g p)) ¬∑ ap f (Œ∑ x) ¬∑ p
                ==‚ü® ¬∑-assoc (ap f (inv (ap g p))) _ p ‚ü©
              ap f (inv (ap g p)) ¬∑ (ap f (Œ∑ x) ¬∑ p)
                ==‚ü® ap (_¬∑ (ap f (Œ∑ x) ¬∑ p)) (ap-inv f (ap g p)) ‚ü©
              inv (ap f (ap g p)) ¬∑ (ap f (Œ∑ x) ¬∑ p)
                ==‚ü® ap (Œª u ‚Üí inv (ap f (ap g p)) ¬∑ (u ¬∑ p)) (œÑ x) ‚ü©
              inv (ap f (ap g p)) ¬∑ (Œµ (f x) ¬∑ p)
                ==‚ü® ap (Œª u ‚Üí inv (ap f (ap g p)) ¬∑ (Œµ (f x) ¬∑ u)) (inv (ap-id p)) ‚ü©
              inv (ap f (ap g p)) ¬∑ (Œµ (f x) ¬∑ ap id p)
                ==‚ü® ap (inv (ap f (ap g p)) ¬∑_) (h-naturality Œµ p) ‚ü©
              inv (ap f (ap g p)) ¬∑ (ap (f ‚àò g) p ¬∑ Œµ y)
                ==‚ü® ap (Œª u ‚Üí inv u ¬∑ (ap (f ‚àò g) p ¬∑ Œµ y)) (ap-comp g f p) ‚ü©
              inv (ap (f ‚àò g) p) ¬∑ (ap (f ‚àò g) p ¬∑ Œµ y)
                ==‚ü® inv (¬∑-assoc (inv (ap (f ‚àò g) p)) _ (Œµ y)) ‚ü©
              (inv (ap (f ‚àò g) p) ¬∑ ap (f ‚àò g) p) ¬∑ Œµ y
                ==‚ü® ap (_¬∑ Œµ y) (¬∑-linv (ap (Œª z ‚Üí f (g z)) p)) ‚ü©
              Œµ y
            ‚àé

  -- Half-adjointness implies equivalence.
  ishae-‚âÉ : {f : A ‚Üí B} ‚Üí ishae f ‚Üí A ‚âÉ B
  ishae-‚âÉ ishaef = _ , (ishae-contr _ ishaef)

open Halfadjoints public
\end{code}

### Quasiinverses

Two functions are quasi-inverses if we can construct a function providing
`(g ‚àò f) x = x` and `(f ‚àò g) y = y` for any given `x` and `y`.

\begin{code}
module Quasiinverses {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : Type ‚Ñì‚±º} where

  -- Definitions for quasi-inverses, left-inverses, right-inverses and
  -- biinverses.
  qinv : (A ‚Üí B) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
  qinv f = Œ£ (B ‚Üí A) (Œª g ‚Üí ((f ‚àò g) ‚àº id) √ó ((g ‚àò f) ‚àº id))

  linv : (A ‚Üí B) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
  linv f = Œ£ (B ‚Üí A) (Œª g ‚Üí (g ‚àò f) ‚àº id)

  rinv : (A ‚Üí B) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
  rinv f = Œ£ (B ‚Üí A) Œª g ‚Üí (f ‚àò g) ‚àº id

  biinv : (A ‚Üí B) ‚Üí Type (‚Ñì·µ¢ ‚äî ‚Ñì‚±º)
  biinv f = linv f √ó rinv f

  qinv-biinv : (f : A ‚Üí B) ‚Üí qinv f ‚Üí biinv f
  qinv-biinv f (g , (u1 , u2)) = (g , u2) , (g , u1)

  biinv-qinv : (f : A ‚Üí B) ‚Üí biinv f ‚Üí qinv f
  biinv-qinv f ((h , Œ±) , (g , Œ≤)) = g , (Œ≤ , Œ¥)
    where
      Œ≥1 : g ‚àº ((h ‚àò f) ‚àò g)
      Œ≥1 = rcomp-‚àº g (h-sym (h ‚àò f) id Œ±)

      Œ≥2 : ((h ‚àò f) ‚àò g) ‚àº (h ‚àò (f ‚àò g))
      Œ≥2 x = idp

      Œ≥ : g ‚àº h
      Œ≥ = Œ≥1 ‚óè (Œ≥2 ‚óè (lcomp-‚àº h Œ≤))

      Œ¥ : (g ‚àò f) ‚àº id
      Œ¥ = (rcomp-‚àº f Œ≥) ‚óè Œ±

  equiv-biinv : (f : A ‚Üí B) ‚Üí isContrMap f ‚Üí biinv f
  equiv-biinv f contrf =
    (remap eq , rlmap-inverse-h eq) , (remap eq , lrmap-inverse-h eq)
    where
      eq : A ‚âÉ B
      eq = f , contrf

  -- Quasiinverses are halfadjoint equivalences.
  qinv-ishae : {f : A ‚Üí B} ‚Üí qinv f ‚Üí ishae f
  qinv-ishae {f} (g , (Œµ , Œ∑)) = record {
      g = g ;
      Œ∑ = Œ∑ ;
      Œµ = Œª b ‚Üí inv (Œµ (f (g b))) ¬∑ ap f (Œ∑ (g b)) ¬∑ Œµ b ;
      œÑ = œÑ
    }
    where
      aux-lemma : (a : A) ‚Üí ap f (Œ∑ (g (f a))) ¬∑ Œµ (f a) == Œµ (f (g (f a))) ¬∑ ap f (Œ∑ a)
      aux-lemma a =
        begin
          ap f (Œ∑ ((g ‚àò f) a)) ¬∑ Œµ (f a)
            ==‚ü® ap (Œª u ‚Üí ap f u ¬∑ Œµ (f a)) (h-naturality-id Œ∑) ‚ü©
          ap f (ap (g ‚àò f) (Œ∑ a)) ¬∑ Œµ (f a)
            ==‚ü® ap (_¬∑ Œµ (f a)) (ap-comp (g ‚àò f) f (Œ∑ a)) ‚ü©
          ap (f ‚àò (g ‚àò f)) (Œ∑ a) ¬∑ Œµ (f a)
            ==‚ü® inv (h-naturality (Œª x ‚Üí Œµ (f x)) (Œ∑ a)) ‚ü©
          Œµ (f (g (f a))) ¬∑ ap f (Œ∑ a)
        ‚àé

      œÑ : (a : A) ‚Üí ap f (Œ∑ a) == (inv (Œµ (f (g (f a)))) ¬∑ ap f (Œ∑ (g (f a))) ¬∑ Œµ (f a))
      œÑ a =
        begin
          ap f (Œ∑ a)
            ==‚ü® ap (_¬∑ ap f (Œ∑ a)) (inv (¬∑-linv (Œµ (f (g (f a)))))) ‚ü©
          inv (Œµ (f (g (f a)))) ¬∑ Œµ (f (g (f a))) ¬∑ ap f (Œ∑ a)
            ==‚ü® ¬∑-assoc (inv (Œµ (f (g (f a))))) _ (ap f (Œ∑ a)) ‚ü©
          inv (Œµ (f (g (f a)))) ¬∑ (Œµ (f (g (f a))) ¬∑ ap f (Œ∑ a))
            ==‚ü® ap (inv (Œµ (f (g (f a)))) ¬∑_) (inv (aux-lemma a)) ‚ü©
          inv (Œµ (f (g (f a)))) ¬∑ (ap f (Œ∑ (g (f a))) ¬∑ Œµ (f a))
            ==‚ü® inv (¬∑-assoc (inv (Œµ (f (g (f a))))) _ (Œµ (f a))) ‚ü©
          inv (Œµ (f (g (f a)))) ¬∑ ap f (Œ∑ (g (f a))) ¬∑ Œµ (f a)
        ‚àé

  -- Quasiinverses create equivalences.
  qinv-‚âÉ : (f : A ‚Üí B) ‚Üí qinv f ‚Üí A ‚âÉ B
  qinv-‚âÉ f = ishae-‚âÉ ‚àò qinv-ishae

  ‚âÉ-qinv : A ‚âÉ B ‚Üí Œ£ (A ‚Üí B) qinv
  ‚âÉ-qinv eq =
    lemap eq , (remap eq , (lrmap-inverse-h eq , rlmap-inverse-h eq))

  -- Half-adjoint equivalences are quasiinverses.
  ishae-qinv : {f : A ‚Üí B} ‚Üí ishae f ‚Üí qinv f
  ishae-qinv {f} (hae g Œ∑ Œµ œÑ) = g , (Œµ , Œ∑)

  ‚âÉ-ishae : (e : A ‚âÉ B)‚Üí ishae (lemap e)
  ‚âÉ-ishae e = qinv-ishae (œÄ‚ÇÇ (‚âÉ-qinv e))

open Quasiinverses public
\end{code}

## Equivalence composition

Composition of equivalences and properties of that composition.

\begin{code}
module EquivalenceComposition where

  -- Composition of quasiinverses
  qinv-comp : ‚àÄ {‚Ñì} {A B C : Type ‚Ñì} ‚Üí Œ£ (A ‚Üí B) qinv ‚Üí Œ£ (B ‚Üí C) qinv ‚Üí Œ£ (A ‚Üí C) qinv
  qinv-comp (f , (if , (Œµf , Œ∑f))) (g , (ig , (Œµg , Œ∑g))) = (g ‚àò f) , ((if ‚àò ig) ,
     ( (Œª x ‚Üí ap g (Œµf (ig x)) ¬∑ Œµg x)
     ,  Œª x ‚Üí ap if (Œ∑g (f x)) ¬∑ Œ∑f x))

  qinv-inv : ‚àÄ {‚Ñì} {A B : Type ‚Ñì} ‚Üí Œ£ (A ‚Üí B) qinv ‚Üí Œ£ (B ‚Üí A) qinv
  qinv-inv (f , (g , (Œµ , Œ∑))) = g , (f , (Œ∑ , Œµ))

  -- Composition of equivalences
  idEqv : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí A ‚âÉ A
  idEqv = id , Œª a ‚Üí (a , refl a) , Œª { (_ , idp) ‚Üí refl (a , refl a) }
\end{code}

\begin{code}
--
  compEqv
    : ‚àÄ {‚Ñì} {A B C : Type ‚Ñì}
    ‚Üí A ‚âÉ B
    ‚Üí B ‚âÉ C
    -------
    ‚Üí A ‚âÉ C

  compEqv {A = A} {C = C} eq-f eq-g = qinv-‚âÉ (œÄ‚ÇÅ qcomp) (œÄ‚ÇÇ qcomp)
   where
     qcomp : Œ£ (A ‚Üí C) qinv
     qcomp = qinv-comp (‚âÉ-qinv eq-f) (‚âÉ-qinv eq-g)

  -- synonym:
  ‚âÉ-trans = compEqv
\end{code}

\begin{code}
  invEqv : ‚àÄ {‚Ñì} {A B : Type ‚Ñì} ‚Üí A ‚âÉ B ‚Üí B ‚âÉ A
  invEqv {‚Ñì} {A} {B} eq-f = qinv-‚âÉ (œÄ‚ÇÅ qcinv) (œÄ‚ÇÇ qcinv)
   where
     qcinv : Œ£ (B ‚Üí A) qinv
     qcinv = qinv-inv (‚âÉ-qinv eq-f)

  -- Lemmas about composition
  compEqv-inv : ‚àÄ {‚Ñì} {A B : Type ‚Ñì} ‚Üí (Œ± : A ‚âÉ B) ‚Üí compEqv Œ± (invEqv Œ±) == idEqv
  compEqv-inv {_} {A} {B} Œ± = sameEqv (
   begin
     œÄ‚ÇÅ (compEqv Œ± (invEqv Œ±)) ==‚ü® refl _ ‚ü©
     œÄ‚ÇÅ (invEqv Œ±) ‚àò œÄ‚ÇÅ Œ±     ==‚ü® funext (rlmap-inverse-h Œ±) ‚ü©
     id
   ‚àé)

open EquivalenceComposition public
\end{code}


## Equivalence reasoning

\begin{code}
module EquivalenceReasoning where

  infixr 2 _‚âÉ‚ü®‚ü©_
  _‚âÉ‚ü®‚ü©_ : ‚àÄ {‚Ñì} (A {B} : Type ‚Ñì) ‚Üí A ‚âÉ B ‚Üí A ‚âÉ B
  _ ‚âÉ‚ü®‚ü© e = e

  infixr 2 _‚âÉ‚ü®_‚ü©_
  _‚âÉ‚ü®_‚ü©_ : ‚àÄ {‚Ñì} (A : Type ‚Ñì) {B C : Type ‚Ñì} ‚Üí A ‚âÉ B ‚Üí B ‚âÉ C ‚Üí A ‚âÉ C
  _ ‚âÉ‚ü® e‚ÇÅ ‚ü© e‚ÇÇ = compEqv e‚ÇÅ e‚ÇÇ
  --
  infix  3 _‚âÉ‚àé
  _‚âÉ‚àé :  ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí A ‚âÉ A
  _‚âÉ‚àé = Œª A ‚Üí idEqv {A = A}

  infix  1 begin‚âÉ_
  begin‚âÉ_ : ‚àÄ {‚Ñì} {A B : Type ‚Ñì} ‚Üí A ‚âÉ B ‚Üí A ‚âÉ B
  begin‚âÉ_ e = e

open EquivalenceReasoning public
\end{code}

## Equivalence with Sigma type

\begin{code}
module SigmaEquivalence {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {P : A ‚Üí Type ‚Ñì‚±º} where

  pair=Equiv : {v w : Œ£ A P}
    ‚Üí Œ£ (œÄ‚ÇÅ v == œÄ‚ÇÅ w) (Œª p ‚Üí tr (Œª a ‚Üí P a) p (œÄ‚ÇÇ v) == œÄ‚ÇÇ w) ‚âÉ v == w
  pair=Equiv = qinv-‚âÉ Œ£-bycomponents (Œ£-componentwise , HŒ£‚ÇÅ , HŒ£‚ÇÇ)
    where
      HŒ£‚ÇÅ : Œ£-bycomponents ‚àò Œ£-componentwise ‚àº id
      HŒ£‚ÇÅ idp = idp

      HŒ£‚ÇÇ : Œ£-componentwise ‚àò Œ£-bycomponents ‚àº id
      HŒ£‚ÇÇ (idp , idp) = idp

  private
    f : {a‚ÇÅ a‚ÇÇ : A} {Œ± : a‚ÇÅ == a‚ÇÇ}{c‚ÇÅ : P a‚ÇÅ} {c‚ÇÇ : P a‚ÇÇ}
      ‚Üí {Œ≤ : a‚ÇÅ == a‚ÇÇ}
      ‚Üí {Œ≥ : transport P Œ≤ c‚ÇÅ == c‚ÇÇ}
      ‚Üí ap œÄ‚ÇÅ (pair= (Œ≤ , Œ≥)) == Œ± ‚Üí Œ≤ == Œ±
    f {Œ≤ = idp} {Œ≥ = idp} idp = idp

    g : {a‚ÇÅ a‚ÇÇ : A} {Œ± : a‚ÇÅ == a‚ÇÇ}{c‚ÇÅ : P a‚ÇÅ} {c‚ÇÇ : P a‚ÇÇ}
      ‚Üí {Œ≤ : a‚ÇÅ == a‚ÇÇ}
      ‚Üí {Œ≥ : transport P Œ≤ c‚ÇÅ == c‚ÇÇ}
      ‚Üí Œ≤ == Œ± ‚Üí ap œÄ‚ÇÅ (pair= (Œ≤ , Œ≥)) == Œ±
    g {Œ≤ = idp} {Œ≥ = idp} idp = idp

    f-g : {a‚ÇÅ a‚ÇÇ : A} {Œ± : a‚ÇÅ == a‚ÇÇ}{c‚ÇÅ : P a‚ÇÅ} {c‚ÇÇ : P a‚ÇÇ}
      ‚Üí {Œ≤ : a‚ÇÅ == a‚ÇÇ}
      ‚Üí {Œ≥ : transport P Œ≤ c‚ÇÅ == c‚ÇÇ}
      ‚Üí f {Œ± = Œ±}{Œ≤ = Œ≤}{Œ≥} ‚àò g {Œ± = Œ±}{Œ≤ = Œ≤} ‚àº id
    f-g {Œ≤ = idp} {Œ≥ = idp} idp = idp

    g-f : {a‚ÇÅ a‚ÇÇ : A} {Œ± : a‚ÇÅ == a‚ÇÇ}{c‚ÇÅ : P a‚ÇÅ} {c‚ÇÇ : P a‚ÇÇ}
      ‚Üí {Œ≤ : a‚ÇÅ == a‚ÇÇ}
      ‚Üí {Œ≥ : transport P Œ≤ c‚ÇÅ == c‚ÇÇ}
      ‚Üí g {Œ± = Œ±}{Œ≤ = Œ≤}{Œ≥} ‚àò f {Œ± = Œ±}{Œ≤ = Œ≤}{Œ≥} ‚àº id
    g-f {Œ≤ = idp} {Œ≥ = idp} idp = idp

  ap-œÄ‚ÇÅ-pair=Equiv : {a‚ÇÅ a‚ÇÇ : A} {c‚ÇÅ : P a‚ÇÅ} {c‚ÇÇ : P a‚ÇÇ}
    ‚Üí (Œ± : a‚ÇÅ == a‚ÇÇ)
    ‚Üí (Œ≥ : Œ£ (a‚ÇÅ == a‚ÇÇ) (Œª Œ±' ‚Üí transport P Œ±' c‚ÇÅ == c‚ÇÇ))
    ‚Üí (ap œÄ‚ÇÅ (pair= Œ≥) == Œ±) ‚âÉ œÄ‚ÇÅ Œ≥ == Œ±
  ap-œÄ‚ÇÅ-pair=Equiv {a‚ÇÅ = a‚ÇÅ} Œ± (Œ≤ , Œ≥) = qinv-‚âÉ f (g , f-g , g-f)

open SigmaEquivalence public
\end{code}

## Univalence

Voevodsky's univalence axiom is postulated. It induces
an equality between any two equivalent types. Some Œ≤ and Œ∑ rules
are provided.

\begin{code}
module Univalence where

  -- Voevodsky's Univalence Axiom.
  module UnivalenceAxiom {‚Ñì} {A B : Type ‚Ñì} where

    idtoeqv : A == B ‚Üí A ‚âÉ B
    idtoeqv p = qinv-‚âÉ
      (transport (Œª X ‚Üí X) p)
      (transport (Œª X ‚Üí X) (inv p) , (coe-inv-l p , coe-inv-r p))

    -- The Univalence axiom induces an equivalence between equalities
    -- and equivalences.
    postulate axiomUnivalence : isEquiv idtoeqv
    eqvUnivalence : (A == B) ‚âÉ (A ‚âÉ B)
    eqvUnivalence = idtoeqv , axiomUnivalence

    -- Introduction rule for equalities.
    ua : A ‚âÉ B ‚Üí A == B
    ua = remap eqvUnivalence

    -- Computation rules
    ua-Œ≤ : (eqv : A ‚âÉ B) ‚Üí idtoeqv (ua eqv) == eqv
    ua-Œ≤ eqv = lrmap-inverse eqvUnivalence

    ua-Œ∑ : (p : A == B) ‚Üí ua (idtoeqv p) == p
    ua-Œ∑ p = rlmap-inverse eqvUnivalence
  open UnivalenceAxiom public
open Univalence public
\end{code}

### Univalence lemmas

\begin{code}
module UnivalenceLemmas {‚Ñì} where
\end{code}

- The identity equivalence creates the trivial path.
{: .foldable}
\begin{code}
  postulate
    ua-id : {A : Type ‚Ñì} ‚Üí ua idEqv == refl A
    -- ua-id {A} =
    --   begin
    --     ua idEqv              ==‚ü® ap ua (sameEqv (refl id)) ‚ü©
    --     ua (idtoeqv (refl A)) ==‚ü® ua-Œ∑ (refl A) ‚ü©
    --     refl A
    --   ‚àé

    -- The composition of equivalences is preserved into composition
    -- of equalities.
\end{code}
-
{: .foldable}
\begin{code}
  postulate
    ua-comp : {A B C : Type ‚Ñì} ‚Üí (Œ± : A ‚âÉ B) ‚Üí (Œ≤ : B ‚âÉ C) ‚Üí ua (compEqv Œ± Œ≤) == ua Œ± ¬∑ ua Œ≤
    -- ua-comp Œ± Œ≤ =
    --   begin
    --     ua (compEqv Œ± Œ≤)                               ==‚ü® ap (Œª x ‚Üí ua (compEqv x Œ≤)) (inv (ua-Œ≤ Œ±)) ‚ü©
    --     ua (compEqv (idtoeqv (ua Œ±)) Œ≤)                ==‚ü® ap (Œª x ‚Üí ua (compEqv (idtoeqv (ua Œ±)) x))
    --                                                        (inv (ua-Œ≤ Œ≤)) ‚ü©
    --     ua (compEqv (idtoeqv (ua Œ±)) (idtoeqv (ua Œ≤))) ==‚ü® ap ua lemma ‚ü©
    --     ua (idtoeqv (ua Œ± ¬∑ ua Œ≤))                     ==‚ü® ua-Œ∑ (ua Œ± ¬∑ ua Œ≤) ‚ü©
    --     ua Œ± ¬∑ ua Œ≤
    --   ‚àé
    --   where
    --     lemma : compEqv (idtoeqv (ua Œ±)) (idtoeqv (ua Œ≤)) == idtoeqv (ua Œ± ¬∑ ua Œ≤)
    --     lemma = sameEqv (
    --       begin
    --         œÄ‚ÇÅ (idtoeqv (ua Œ≤)) ‚àò œÄ‚ÇÅ (idtoeqv (ua Œ±))                 ==‚ü® refl _ ‚ü©
    --         (transport (Œª x ‚Üí x) (ua Œ≤)) ‚àò (transport (Œª x ‚Üí x) (ua Œ±)) ==‚ü® transport-comp (ua Œ±) (ua Œ≤) ‚ü©
    --         transport (Œª x ‚Üí x) (ua Œ± ¬∑ ua Œ≤)                           ==‚ü® refl _ ‚ü©
    --         œÄ‚ÇÅ (idtoeqv (ua Œ± ¬∑ ua Œ≤))
    --       ‚àé)
\end{code}

- Inverses are preserved
{: .foldable}
\begin{code}
  postulate
    ua-inv-r : {A B : Type ‚Ñì} ‚Üí (Œ± : A ‚âÉ B) ‚Üí ua Œ± ¬∑ ua (invEqv Œ±) == refl A
    -- ua-inv-r Œ± =
    --   begin
    --     ua Œ± ¬∑ ua (invEqv Œ±)      ==‚ü® inv (ua-comp Œ± (invEqv Œ±)) ‚ü©
    --     ua (compEqv Œ± (invEqv Œ±)) ==‚ü® ap ua (compEqv-inv Œ±) ‚ü©
    --     ua idEqv                  ==‚ü® ua-id ‚ü©
    --     refl _
    --   ‚àé
\end{code}

- Missing description
{: .foldable}
\begin{code}
  postulate
    ua-inv : {A B : Type ‚Ñì} ‚Üí (Œ± : A ‚âÉ B) ‚Üí ua (invEqv Œ±) == inv (ua Œ±)
    -- ua-inv Œ± =
    --   begin
    --     ua (invEqv Œ±)                       ==‚ü® ap (_¬∑ ua (invEqv Œ±)) (inv (¬∑-linv (ua Œ±))) ‚ü©
    --     inv (ua Œ±) ¬∑ ua Œ± ¬∑ ua (invEqv Œ±)   ==‚ü® ¬∑-assoc (inv (ua Œ±)) _ _ ‚ü©
    --     inv (ua Œ±) ¬∑ (ua Œ± ¬∑ ua (invEqv Œ±)) ==‚ü® ap (inv (ua Œ±) ¬∑_) (ua-inv-r Œ±) ‚ü©
    --     inv (ua Œ±) ¬∑ refl _                 ==‚ü® inv (¬∑-runit (inv ((ua Œ±)))) ‚ü©
    --     inv (ua Œ±)
    --   ‚àé
open UnivalenceLemmas public
\end{code}

### Transport and Univalence

\begin{code}
module TransportUA where

  transport-family-ap
    : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
    ‚Üí (B : A ‚Üí Type ‚Ñì)
    ‚Üí {x y : A}
    ‚Üí (p : x == y)
    ‚Üí (u : B x)
    ---------------------------------------------------
    ‚Üí transport B p u == transport (Œª X ‚Üí X) (ap B p) u
  transport-family-ap B idp u = idp

  transport-family-idtoeqv
    : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
    ‚Üí (B : A ‚Üí Type ‚Ñì)
    ‚Üí {x y : A}
    ‚Üí (p : x == y)
    ‚Üí (u : B x)
    ---------------------------------------------------
    ‚Üí transport B p u == fun‚âÉ (idtoeqv (ap B p)) u
  transport-family-idtoeqv B idp u = idp

  transport-ua
    : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
    ‚Üí (B : A ‚Üí Type ‚Ñì)
    ‚Üí {x y : A}
    ‚Üí (p : x == y)
    ‚Üí (e : B x ‚âÉ B y)
    ‚Üí ap B p == ua e
    -----------------
    ‚Üí (u : B x) ‚Üí transport B p u == (fun‚âÉ e) u
  transport-ua B idp e q u =
    begin
      transport B idp u
        ==‚ü® transport-family-idtoeqv B idp u ‚ü©
      fun‚âÉ (idtoeqv (ap B idp)) u
        ==‚ü® ap (Œª r ‚Üí fun‚âÉ (idtoeqv r) u) q ‚ü©
      fun‚âÉ (idtoeqv (ua e)) u
        ==‚ü® ap (Œª r ‚Üí fun‚âÉ r u) (ua-Œ≤ e) ‚ü©
      fun‚âÉ e u
    ‚àé


  funext-transport-ua
    : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
    ‚Üí (B : A ‚Üí Type ‚Ñì)
    ‚Üí {x y : A}
    ‚Üí (p : x == y)
    ‚Üí (e : B x ‚âÉ B y)
    ‚Üí ap B p == ua e
    -----------------
    ‚Üí transport B p == (fun‚âÉ e)
  funext-transport-ua B p e x‚ÇÅ = funext (transport-ua B p e x‚ÇÅ)
open TransportUA public
\end{code}

\begin{code}
funext-transport-dfun-bezem
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}{X : Type ‚Ñì·µ¢}{A : X ‚Üí Type ‚Ñì‚±º}{B : (x : X) ‚Üí A x ‚Üí Type ‚Ñì‚±º} {x y : X}
  ‚Üí (p : x == y)
  ‚Üí (f : (a : A x) ‚Üí B x a)
  ‚Üí (g : (a : A y) ‚Üí B y a)
  ‚Üí (a : A y)
  ------------------------------------------------------------------------------------
  ‚Üí (tr (Œª x ‚Üí (a : A x) ‚Üí B x a) p f) a == g a
  ‚âÉ  tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (pair= (p , transport-inv p)) (f (((! p) ‚ú∂) a)) == g a

funext-transport-dfun-bezem idp f g a = idEqv
\end{code}

\begin{code}
funext-transport-dfun-bezem-l
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}{X : Type ‚Ñì·µ¢}{A : X ‚Üí Type ‚Ñì‚±º}{B : (x : X) ‚Üí A x ‚Üí Type ‚Ñì‚±º} {x y : X}
  ‚Üí (p : x == y)
  ‚Üí (f : (a : A x) ‚Üí B x a)
  ‚Üí (g : (a : A y) ‚Üí B y a)
  ‚Üí (a : A y)
  ‚Üí (tr (Œª x ‚Üí (a : A x) ‚Üí B x a) p f) a == g a
  ------------------------------------------------------------------------------------
  ‚Üí  tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (pair= (p , transport-inv p)) (f (((! p) ‚ú∂) a)) == g a

funext-transport-dfun-bezem-l p f g a x‚ÇÅ = lemap (funext-transport-dfun-bezem p f g a) x‚ÇÅ
\end{code}

\begin{code}
funext-transport-dfun-bezem-r
  : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º}{X : Type ‚Ñì·µ¢}{A : X ‚Üí Type ‚Ñì‚±º}{B : (x : X) ‚Üí A x ‚Üí Type ‚Ñì‚±º} {x y : X}
  ‚Üí (p : x == y)
  ‚Üí (f : (a : A x) ‚Üí B x a)
  ‚Üí (g : (a : A y) ‚Üí B y a)
  ‚Üí (a : A y)
  ‚Üí  tr (Œª w ‚Üí B (œÄ‚ÇÅ w) (œÄ‚ÇÇ w)) (pair= (p , transport-inv p)) (f (((! p) ‚ú∂) a)) == g a
  ------------------------------------------------------------------------------------
  ‚Üí (tr (Œª x ‚Üí (a : A x) ‚Üí B x a) p f) a == g a

funext-transport-dfun-bezem-r p f g a x‚ÇÅ = remap (funext-transport-dfun-bezem p f g a) x‚ÇÅ
\end{code}

## Truncation

\begin{code}
module Truncation where

  private
    -- Higher inductive type, defined with equalities between any two
    -- members.
    data !‚à•_‚à• {‚Ñì} (A : Type ‚Ñì) : Type ‚Ñì where
      !‚à£_‚à£ : A ‚Üí !‚à• A ‚à•

  ‚à•_‚à• : ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí Type ‚Ñì
  ‚à• A ‚à• = !‚à• A ‚à•

  ‚à£_‚à£ : ‚àÄ {‚Ñì} {X : Type ‚Ñì} ‚Üí X ‚Üí ‚à• X ‚à•
  ‚à£ x ‚à£ = !‚à£ x ‚à£

  -- Any two elements of the truncated type are equal
  postulate trunc : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí isProp ‚à• A ‚à•

  -- Recursion principle
  trunc-rec : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {P : Type ‚Ñì‚±º}
            ‚Üí isProp P
            ‚Üí (A ‚Üí P)
            ---------
            ‚Üí ‚à• A ‚à• ‚Üí P
  trunc-rec _ f !‚à£ x ‚à£ = f x
\end{code}

## Set truncation

An analogous form of truncation for Sets instead of
Propositions. It truncates any higher-dimensional homothopical
structure.

\begin{code}
module SetTruncation where

  private
    -- Higher inductive type
    data !‚à•_‚à•‚ÇÄ {‚Ñì} (A : Type ‚Ñì) : Type ‚Ñì where
      !‚à£_‚à£‚ÇÄ : A ‚Üí !‚à• A ‚à•‚ÇÄ

  ‚à•_‚à•‚ÇÄ : ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí Type ‚Ñì
  ‚à• A ‚à•‚ÇÄ = !‚à• A ‚à•‚ÇÄ

  ‚à£_‚à£‚ÇÄ : ‚àÄ {‚Ñì} {X : Type ‚Ñì} ‚Üí X ‚Üí ‚à• X ‚à•‚ÇÄ
  ‚à£ x ‚à£‚ÇÄ = !‚à£ x ‚à£‚ÇÄ

  -- Any two equalities on the truncated type are equal
  postulate strunc : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí isSet ‚à• A ‚à•‚ÇÄ

  -- Recursion principle
  strunc-rec : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {P : Type ‚Ñì‚±º} ‚Üí isSet P ‚Üí (A ‚Üí P) ‚Üí ‚à• A ‚à•‚ÇÄ ‚Üí P
  strunc-rec _ f !‚à£ x ‚à£‚ÇÄ = f x

  -- Induction principle
  strunc-ind : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {B : ‚à• A ‚à•‚ÇÄ ‚Üí Type ‚Ñì‚±º} ‚Üí ((a : ‚à• A ‚à•‚ÇÄ) ‚Üí isSet (B a))
             ‚Üí (g : (a : A) ‚Üí B ‚à£ a ‚à£‚ÇÄ) ‚Üí (a : ‚à• A ‚à•‚ÇÄ) ‚Üí B a
  strunc-ind _ g !‚à£ x ‚à£‚ÇÄ = g x
\end{code}

## Quotients

\begin{code}
module Quotients where

  record QRel {‚Ñì} (A : Type ‚Ñì) : Type (lsuc ‚Ñì) where
    field
      R : A ‚Üí A ‚Üí Type ‚Ñì
      Aset : isSet A
      Rprop : (a b : A) ‚Üí isProp (R a b)
  open QRel  public

  private
    -- Higher inductive type
    data _!/_ {‚Ñì} (A : Type ‚Ñì) (r : QRel A) : Type (lsuc ‚Ñì) where
      ![_] : A ‚Üí (A !/ r)

  _/_ : ‚àÄ {‚Ñì} (A : Type ‚Ñì) (r : QRel A) ‚Üí Type (lsuc ‚Ñì)
  A / r = (A !/ r)

  [_] : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí A ‚Üí {r : QRel A} ‚Üí (A / r)
  [ a ] = ![ a ]

  -- Equalities induced by the relation
  postulate Req : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {r : QRel A}
                 ‚Üí {a b : A} ‚Üí R  a b ‚Üí [ a ] {r} == [ b ]

  -- The quotient of a set is again a set
  postulate Rtrunc : ‚àÄ {‚Ñì} {A : Type ‚Ñì} {r : QRel A} ‚Üí isSet (A / r)

  -- Recursion principle
  QRel-rec : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {r : QRel A} {B : Type ‚Ñì‚±º}
            ‚Üí (f : A ‚Üí B) ‚Üí ((x y : A) ‚Üí R  x y ‚Üí f x == f y) ‚Üí A / r ‚Üí B
  QRel-rec f p ![ x ] = f x

  -- Induction principle
  QRel-ind : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {r : QRel A} {B : A / r ‚Üí Type ‚Ñì‚±º}
            ‚Üí (f : ((a : A) ‚Üí B [ a ]))
            ‚Üí ((x y : A) ‚Üí (o : R  x y) ‚Üí (transport B (Req o) (f x)) == f y)
            ‚Üí (z : A / r) ‚Üí B z
  QRel-ind f p ![ x ] = f x

  -- Recursion in two arguments
  QRel-rec-bi : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢} {r : QRel A} {B : Type ‚Ñì‚±º}
              ‚Üí (f : A ‚Üí A ‚Üí B) ‚Üí ((x y z t : A) ‚Üí R  x y ‚Üí R  z t ‚Üí f x z == f y t)
              ‚Üí A / r ‚Üí A / r ‚Üí B
  QRel-rec-bi f p ![ x ] ![ y ] = f x y


  Qrel-prod : ‚àÄ {‚Ñì·µ¢}{A : Type ‚Ñì·µ¢} (r : QRel A) ‚Üí QRel (A √ó A)
  Qrel-prod r = record { R = Œª { (a , b) (c , d) ‚Üí (R  a c) √ó (R  b d) }
                       ; Aset = isSet-prod (Aset ) (Aset )
                       ; Rprop = Œª { (x , y) (z , w) ‚Üí isProp-prod (Rprop  x z) (Rprop  y w)} }
\end{code}

## Relation

\begin{code}
module Relation where

  record Rel {‚Ñì} (A : Type ‚Ñì) : Type (lsuc ‚Ñì) where
    field
      R     : A ‚Üí A ‚Üí Type ‚Ñì
      Rprop : (a b : A) ‚Üí isProp (R a b)
  open Rel  public

open Relation public
\end{code}


## Hedberg

\begin{code}
module Hedberg {‚Ñì} where

  module HedbergLemmas (A : Type ‚Ñì) where

    -- A set is a type satisfiying axiom K.
    axiomKisSet : ((a : A) ‚Üí (p : a == a) ‚Üí p == refl a) ‚Üí isSet A
    axiomKisSet k x _ p idp = k x p

    -- Lemma: a reflexive relation on X implying the identity proves
    -- that X is a set.
    reflRelIsSet :  (r : Rel A) ‚Üí
      ((x y : A) ‚Üí R  x y ‚Üí x == y) ‚Üí
      (œÅ : (a : A) ‚Üí R  a a) ‚Üí
      isSet A
    reflRelIsSet r f œÅ x .x p idp = lemma p
      where
        lemma2 : {a : A} (p : a == a) ‚Üí (o : R  a a) ‚Üí
          transport (Œª x ‚Üí a == x) p (f a a o) == f a a (transport (R  a) p o)
        lemma2 {a} p = funext-transport-l p (f a a) (f a a) (apd (f a) p)

        lemma3 : {a : A} (p : a == a) ‚Üí
          (f a a (œÅ a)) ¬∑ p == (f a a (œÅ a))
        lemma3 {a} p = inv (transport-concat-r p _) ¬∑ lemma2 p (œÅ a) ¬∑
                       ap (f a a) (Rprop  a a _ (œÅ a))

        lemma : {a : A} (p : a == a) ‚Üí p == refl a
        lemma {a} p = ¬∑-cancellation ((f a a (œÅ a))) p (lemma3 p)

    -- Lemma: if a type is decidable, then ¬¨¬¨A is actually A.
    lemDoubleNeg : (A + ¬¨ A) ‚Üí (¬¨ (¬¨ A) ‚Üí A)
    lemDoubleNeg (inl x) _ = x
    lemDoubleNeg (inr f) n = exfalso (n f)

  open HedbergLemmas public

  -- Hedberg's theorem. A type with decidable equality is a set.
  hedberg : {A : Type ‚Ñì} ‚Üí ((a b : A) ‚Üí (a == b) + ¬¨ (a == b)) ‚Üí isSet A
  hedberg {A} f = reflRelIsSet A
                (record { R = Œª a b ‚Üí ¬¨ (¬¨ (a == b)) ; Rprop = isPropNeg })
                doubleNegEq (Œª a z ‚Üí z (refl a))
    where
      doubleNegEq : (a b : A) ‚Üí ¬¨ (¬¨ (a == b)) ‚Üí (a == b)
      doubleNegEq a b = lemDoubleNeg (a == b) (f a b)

      isPropNeg : (a b : A) ‚Üí isProp (¬¨ (¬¨ (a == b)))
      isPropNeg a b x y = funext Œª u ‚Üí exfalso (x u)

open Hedberg public
\end{code}


## Algebra

### Monoid

Definition of the algebraic structure of a monoid.

\begin{code}
module Monoids {‚Ñì} where

  record Monoid : Type (lsuc ‚Ñì) where
    field
      -- Operations of a monoid
      G : Type ‚Ñì
      GisSet : isSet G
      _<>_ : G ‚Üí G ‚Üí G  -- Multiplication function
      e : G             -- Unit element

      -- Axioms of a monoid
      lunit : (x : G) ‚Üí (e <> x) == x
      runit : (x : G) ‚Üí (x <> e) == x
      assoc : (x y z : G) ‚Üí (x <> (y <> z)) == ((x <> y) <> z)
open Monoids
\end{code}

### Groups

\begin{code}
module Groups where
  record GroupStructure {‚Ñì} (M : Type ‚Ñì) : Type ‚Ñì where
    constructor group-structure
    field
      -- A group is a monoid
      _*_   : M ‚Üí M ‚Üí M
      e     : M
      lunit : ‚àÄ x ‚Üí (e * x) == x
      runit : ‚àÄ x ‚Üí (x * e) == x
      assoc : ‚àÄ x y z ‚Üí (x * (y * z)) == ((x * y) * z)

      -- With inverses
      ginv : M ‚Üí M
      glinv : ‚àÄ g ‚Üí (g * ginv g) == e
      grinv : ‚àÄ g ‚Üí (ginv g * g) == e

  record Group {‚Ñì} : Type (lsuc ‚Ñì) where
    constructor group
    field
      M : Type ‚Ñì
      str : GroupStructure M
  open Group  public
open Groups
\end{code}

### Naturals

\begin{code}
module Naturals where

  -- Addition of natural numbers
  plus : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  plus zero y = y
  plus (succ x) y = succ (plus x y)

  infixl 60 _+‚Çô_
  _+‚Çô_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  _+‚Çô_ = plus

  -- Lemmas about addition
  plus-lunit : (n : ‚Ñï) ‚Üí zero +‚Çô n == n
  plus-lunit n = refl n

  plus-runit : (n : ‚Ñï) ‚Üí n +‚Çô zero == n
  plus-runit zero = refl zero
  plus-runit (succ n) = ap succ (plus-runit n)

  plus-succ : (n m : ‚Ñï) ‚Üí succ (n +‚Çô m) == (n +‚Çô (succ m))
  plus-succ zero     m = refl (succ m)
  plus-succ (succ n) m = ap succ (plus-succ n m)

  plus-succ-rs : (n m o p : ‚Ñï) ‚Üí n +‚Çô m == o +‚Çô p ‚Üí n +‚Çô (succ m) == o +‚Çô (succ p)
  plus-succ-rs n m o p Œ± = inv (plus-succ n m) ¬∑ ap succ Œ± ¬∑ (plus-succ o p)

  -- Commutativity
  plus-comm : (n m : ‚Ñï) ‚Üí n +‚Çô m == m +‚Çô n
  plus-comm zero     m = inv (plus-runit m)
  plus-comm (succ n) m = ap succ (plus-comm n m) ¬∑ plus-succ m n

  -- Associativity
  plus-assoc : (n m p : ‚Ñï) ‚Üí n +‚Çô (m +‚Çô p) == (n +‚Çô m) +‚Çô p
  plus-assoc zero     m p = refl (m +‚Çô p)
  plus-assoc (succ n) m p = ap succ (plus-assoc n m p)


  -- Decidable equality
  -- Encode-decode technique for natural numbers
  private
    code : ‚Ñï ‚Üí ‚Ñï ‚Üí Type‚ÇÄ
    code 0        0        = ‚ä§
    code 0        (succ m) = ‚ä•
    code (succ n) 0        = ‚ä•
    code (succ n) (succ m) = code n m

  crefl : (n : ‚Ñï) ‚Üí code n n
  crefl zero     = ‚òÖ
  crefl (succ n) = crefl n

  private
    encode : (n m : ‚Ñï) ‚Üí (n == m) ‚Üí code n m
    encode n m p = transport (code n) p (crefl n)

    decode : (n m : ‚Ñï) ‚Üí code n m ‚Üí n == m
    decode zero zero c = refl zero
    decode zero (succ m) ()
    decode (succ n) zero ()
    decode (succ n) (succ m) c = ap succ (decode n m c)

  zero-not-succ : (n : ‚Ñï) ‚Üí ¬¨ (succ n == zero)
  zero-not-succ n = encode (succ n) 0

  -- The successor function is injective
  succ-inj : {n m : ‚Ñï} ‚Üí (succ n == succ m) ‚Üí n == m
  succ-inj {n} {m} p = decode n m (encode (succ n) (succ m) p)

  +-inj : (k : ‚Ñï) {n m : ‚Ñï} ‚Üí (k +‚Çô n == k +‚Çô m) ‚Üí n == m
  +-inj zero   p = p
  +-inj (succ k) p = +-inj k (succ-inj p)

  nat-decEq : decEq ‚Ñï
  nat-decEq zero zero = inl (refl zero)
  nat-decEq zero (succ m) = inr (Œª ())
  nat-decEq (succ n) zero = inr (Œª ())
  nat-decEq (succ n) (succ m) with (nat-decEq n m)
  nat-decEq (succ n) (succ m) | inl p = inl (ap succ p)
  nat-decEq (succ n) (succ m) | inr f = inr Œª p ‚Üí f (succ-inj p)

  nat-isSet : isSet ‚Ñï
  nat-isSet = hedberg nat-decEq

  -- Naturals form a monoid with addition
  ‚Ñï-plus-monoid : Monoid
  ‚Ñï-plus-monoid = record
    { G = ‚Ñï
    ; GisSet = nat-isSet
    ; _<>_ = plus
    ; e = zero
    ; lunit = plus-lunit
    ; runit = plus-runit
    ; assoc = plus-assoc
    }

  -- Ordering
  _<‚Çô_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Type‚ÇÄ
  n <‚Çô m = Œ£ ‚Ñï (Œª k ‚Üí n +‚Çô succ k == m)

  <-isProp : (n m : ‚Ñï) ‚Üí isProp (n <‚Çô m)
  <-isProp n m (k1 , p1) (k2 , p2) = Œ£-bycomponents (succ-inj (+-inj n (p1 ¬∑ inv p2)) , nat-isSet _ _ _ _)

open Naturals public
\end{code}

#### Integers

\begin{code}
module Integers where

  data ‚Ñ§ : Type‚ÇÄ where
    zer : ‚Ñ§
    pos : ‚Ñï ‚Üí ‚Ñ§
    neg : ‚Ñï ‚Üí ‚Ñ§

  -- Inclusion of the natural numbers into the integers
  NtoZ : ‚Ñï ‚Üí ‚Ñ§
  NtoZ zero     = zer
  NtoZ (succ n) = pos n

  -- Successor function
  zsucc : ‚Ñ§ ‚Üí ‚Ñ§
  zsucc zer            = pos 0
  zsucc (pos x)        = pos (succ x)
  zsucc (neg zero)     = zer
  zsucc (neg (succ x)) = neg x

  -- Predecessor function
  zpred : ‚Ñ§ ‚Üí ‚Ñ§
  zpred zer            = neg 0
  zpred (pos zero)     = zer
  zpred (pos (succ x)) = pos x
  zpred (neg x)        = neg (succ x)

  -- Successor and predecessor
  zsuccpred-id : (n : ‚Ñ§) ‚Üí zsucc (zpred n) == n
  zsuccpred-id zer            = refl _
  zsuccpred-id (pos zero)     = refl _
  zsuccpred-id (pos (succ n)) = refl _
  zsuccpred-id (neg n)        = refl _

  zpredsucc-id : (n : ‚Ñ§) ‚Üí zpred (zsucc n) == n
  zpredsucc-id zer            = refl _
  zpredsucc-id (pos n)        = refl _
  zpredsucc-id (neg zero)     = refl _
  zpredsucc-id (neg (succ n)) = refl _

  zpredsucc-succpred : (n : ‚Ñ§) ‚Üí zpred (zsucc n) == zsucc (zpred n)
  zpredsucc-succpred zer = refl zer
  zpredsucc-succpred (pos zero) = refl (pos zero)
  zpredsucc-succpred (pos (succ x)) = refl (pos (succ x))
  zpredsucc-succpred (neg zero) = refl (neg zero)
  zpredsucc-succpred (neg (succ x)) = refl (neg (succ x))

  zsuccpred-predsucc : (n : ‚Ñ§) ‚Üí zsucc (zpred n) == zpred (zsucc n)
  zsuccpred-predsucc n = inv (zpredsucc-succpred n)

  -- Equivalence given by successor and predecessor
  zequiv-succ : ‚Ñ§ ‚âÉ ‚Ñ§
  zequiv-succ = qinv-‚âÉ zsucc (zpred , (zsuccpred-id , zpredsucc-id))

  -- Negation
  - : ‚Ñ§ ‚Üí ‚Ñ§
  - zer     = zer
  - (pos x) = neg x
  - (neg x) = pos x

  double- : (z : ‚Ñ§) ‚Üí - (- z) == z
  double- zer = refl _
  double- (pos x) = refl _
  double- (neg x) = refl _

  zequiv- : ‚Ñ§ ‚âÉ ‚Ñ§
  zequiv- = qinv-‚âÉ - (- , (double- , double-))

  -- Addition on integers
  infixl 60 _+·∂ª_
  _+·∂ª_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§
  zer +·∂ª m = m
  pos zero +·∂ª m = zsucc m
  pos (succ x) +·∂ª m = zsucc (pos x +·∂ª m)
  neg zero +·∂ª m = zpred m
  neg (succ x) +·∂ª m = zpred (neg x +·∂ª m)

  -- Lemmas on addition
  +·∂ª-lunit : (n : ‚Ñ§) ‚Üí n == n +·∂ª zer
  +·∂ª-lunit zer            = refl _
  +·∂ª-lunit (pos zero)     = refl _
  +·∂ª-lunit (pos (succ x)) = ap zsucc (+·∂ª-lunit (pos x))
  +·∂ª-lunit (neg zero)     = refl _
  +·∂ª-lunit (neg (succ x)) = ap zpred (+·∂ª-lunit (neg x))


  +·∂ª-unit-zsucc : (n : ‚Ñ§) ‚Üí zsucc n == (n +·∂ª pos zero)
  +·∂ª-unit-zsucc zer = refl _
  +·∂ª-unit-zsucc (pos zero) = refl _
  +·∂ª-unit-zsucc (pos (succ x)) = ap zsucc (+·∂ª-unit-zsucc (pos x))
  +·∂ª-unit-zsucc (neg zero) = refl _
  +·∂ª-unit-zsucc (neg (succ x)) = inv (zpredsucc-id (neg x)) ¬∑ ap zpred (+·∂ª-unit-zsucc (neg x))

  +·∂ª-unit-zpred : (n : ‚Ñ§) ‚Üí zpred n == (n +·∂ª neg zero)
  +·∂ª-unit-zpred zer = refl _
  +·∂ª-unit-zpred (pos zero) = refl zer
  +·∂ª-unit-zpred (pos (succ x)) = inv (zsuccpred-id (pos x)) ¬∑ ap zsucc (+·∂ª-unit-zpred (pos x))
  +·∂ª-unit-zpred (neg zero) = refl _
  +·∂ª-unit-zpred (neg (succ x)) = ap zpred (+·∂ª-unit-zpred (neg x))


  +·∂ª-pos-zsucc : (n : ‚Ñ§) ‚Üí (x : ‚Ñï) ‚Üí zsucc (n +·∂ª pos x) == n +·∂ª pos (succ x)
  +·∂ª-pos-zsucc zer x = refl _
  +·∂ª-pos-zsucc (pos zero) x = refl _
  +·∂ª-pos-zsucc (pos (succ n)) x = ap zsucc (+·∂ª-pos-zsucc (pos n) x)
  +·∂ª-pos-zsucc (neg zero) x = zsuccpred-id (pos x)
  +·∂ª-pos-zsucc (neg (succ n)) x = zsuccpred-predsucc (neg n +·∂ª pos x) ¬∑ ap zpred (+·∂ª-pos-zsucc (neg n) x)

  +·∂ª-neg-zpred : (n : ‚Ñ§) ‚Üí (x : ‚Ñï) ‚Üí zpred (n +·∂ª neg x) == n +·∂ª neg (succ x)
  +·∂ª-neg-zpred zer x = refl _
  +·∂ª-neg-zpred (pos zero) x = zpredsucc-id (neg x)
  +·∂ª-neg-zpred (pos (succ n)) x = zpredsucc-succpred (pos n +·∂ª neg x) ¬∑ ap zsucc (+·∂ª-neg-zpred (pos n) x)
  +·∂ª-neg-zpred (neg zero) x = refl _
  +·∂ª-neg-zpred (neg (succ n)) x = ap zpred (+·∂ª-neg-zpred (neg n) x)

  +·∂ª-comm : (n m : ‚Ñ§) ‚Üí n +·∂ª m == m +·∂ª n
  +·∂ª-comm zer m = +·∂ª-lunit m
  +·∂ª-comm (pos zero) m = +·∂ª-unit-zsucc m
  +·∂ª-comm (pos (succ x)) m = ap zsucc (+·∂ª-comm (pos x) m) ¬∑ +·∂ª-pos-zsucc m x
  +·∂ª-comm (neg zero) m = +·∂ª-unit-zpred m
  +·∂ª-comm (neg (succ x)) m = ap zpred (+·∂ª-comm (neg x) m) ¬∑ +·∂ª-neg-zpred m x



  -- Decidable equality
  pos-inj : {n m : ‚Ñï} ‚Üí pos n == pos m ‚Üí n == m
  pos-inj {n} {.n} idp = refl n

  neg-inj : {n m : ‚Ñï} ‚Üí neg n == neg m ‚Üí n == m
  neg-inj {n} {.n} idp = refl n

  z-decEq : decEq ‚Ñ§
  z-decEq zer zer = inl (refl zer)
  z-decEq zer (pos x) = inr (Œª ())
  z-decEq zer (neg x) = inr (Œª ())
  z-decEq (pos x) zer = inr (Œª ())
  z-decEq (pos n) (pos m) with (nat-decEq n m)
  z-decEq (pos n) (pos m) | inl p = inl (ap pos p)
  z-decEq (pos n) (pos m) | inr f = inr (f ‚àò pos-inj)
  z-decEq (pos n) (neg m) = inr (Œª ())
  z-decEq (neg n) zer = inr (Œª ())
  z-decEq (neg n) (pos x‚ÇÅ) = inr (Œª ())
  z-decEq (neg n) (neg m) with (nat-decEq n m)
  z-decEq (neg n) (neg m) | inl p = inl (ap neg p)
  z-decEq (neg n) (neg m) | inr f = inr (f ‚àò neg-inj)

  z-isSet : isSet ‚Ñ§
  z-isSet = hedberg z-decEq


  -- Multiplication
  infixl 60 _*·∂ª_
  _*·∂ª_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§
  zer *·∂ª m = zer
  pos zero *·∂ª m = m
  pos (succ x) *·∂ª m = (pos x *·∂ª m) +·∂ª m
  neg zero *·∂ª m = - m
  neg (succ x) *·∂ª m = (neg x *·∂ª m) +·∂ª (- m)


  -- Ordering
  _<·∂ª_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí Type‚ÇÄ
  zer <·∂ª zer = ‚ä•
  zer <·∂ª pos x = ‚ä§
  zer <·∂ª neg x = ‚ä•
  pos x <·∂ª zer = ‚ä•
  pos x <·∂ª pos y = x <‚Çô y
  pos x <·∂ª neg y = ‚ä•
  neg x <·∂ª zer = ‚ä§
  neg x <·∂ª pos y = ‚ä§
  neg x <·∂ª neg y = y <‚Çô x

open Integers
\end{code}

### Integer action

\begin{code}
module IntegerAction {‚Ñì} {M : Type ‚Ñì} (grpst : GroupStructure M) where

  open GroupStructure grpst

    -- Integers acting on a group structure M.
  z-act : ‚Ñ§ ‚Üí M ‚Üí M
  z-act zer            m = e
  z-act (pos zero)     m = m
  z-act (pos (succ x)) m = z-act (pos x) m * m
  z-act (neg zero)     m = ginv m
  z-act (neg (succ x)) m = (z-act (neg x) m) * ginv m


  -- Lemmas on how integers act on a group.
  zsucc-act : ‚àÄ n a ‚Üí z-act (zsucc n) a == (z-act n a * a)
  zsucc-act zer a = inv (lunit a)
  zsucc-act (pos x) a = refl _
  zsucc-act (neg zero) a = inv (grinv a)
  zsucc-act (neg (succ n)) a =
    begin
      z-act (neg n) a                   ==‚ü® inv (runit (z-act (neg n) a)) ‚ü©
      z-act (neg n) a * e               ==‚ü® ap (Œª section ‚Üí _*_ (z-act (neg n) a) section) (inv (grinv a)) ‚ü©
      z-act (neg n) a * (ginv a * a)    ==‚ü® assoc (z-act (neg n) a) (ginv a) a ‚ü©
      ((z-act (neg n) a * ginv a) * a)
    ‚àé

  zpred-act : ‚àÄ n a ‚Üí z-act (zpred n) a == (z-act n a * ginv a)
  zpred-act zer a = inv (lunit (ginv a))
  zpred-act (pos zero) a = inv (glinv a)
  zpred-act (pos (succ x)) a =
    begin
      z-act (zpred (pos (succ x))) a   ==‚ü® refl _ ‚ü©
      z-act (pos x) a                  ==‚ü® inv (runit _) ‚ü©
      z-act (pos x) a * e              ==‚ü® ap (Œª section ‚Üí _*_ (z-act (pos x) a) section) (inv (glinv a)) ‚ü©
      z-act (pos x) a * (a * ginv a)   ==‚ü® assoc (z-act (pos x) a) a (ginv a) ‚ü©
      (z-act (pos x) a * a) * ginv a   ==‚ü® refl _ ‚ü©
      z-act (pos (succ x)) a * ginv a
    ‚àé
  zpred-act (neg x) a = refl _


  act-zsucc : ‚àÄ n a ‚Üí z-act (zsucc n) a == (a * z-act n a)
  act-zsucc zer a = inv (runit a)
  act-zsucc (pos zero) a = refl _
  act-zsucc (pos (succ x)) a =
    begin
       ((z-act (pos x) a * a) * a) ==‚ü® ap (Œª u ‚Üí u * a) (act-zsucc (pos x) a) ‚ü©
       ((a * z-act (pos x) a) * a) ==‚ü® inv (assoc a (z-act (pos x) a) a) ‚ü©
       (a * (z-act (pos x) a * a))
    ‚àé
  act-zsucc (neg zero) a = inv (glinv a)
  act-zsucc (neg (succ x)) a =
    begin
       z-act (neg x) a                    ==‚ü® inv (runit (z-act (neg x) a)) ‚ü©
       (z-act (neg x) a) * e              ==‚ü® ap (Œª section ‚Üí _*_ (z-act (neg x) a) section) (inv (glinv a)) ‚ü©
       (z-act (neg x) a) * (a * ginv a)   ==‚ü® assoc (z-act (neg x) a) a (ginv a) ‚ü©
       ((z-act (neg x) a) * a) * ginv a   ==‚ü® ap (Œª s ‚Üí s * (ginv a)) (inv (zsucc-act (neg x) a)) ‚ü©
       (z-act (zsucc (neg x)) a) * ginv a ==‚ü® ap (Œª s ‚Üí s * (ginv a)) (act-zsucc (neg x) a) ‚ü©
       (a * (z-act (neg x) a)) * ginv a   ==‚ü® inv (assoc a (z-act (neg x) a) (ginv a)) ‚ü©
       (a * (z-act (neg x) a * ginv a))
    ‚àé

  act-zpred : ‚àÄ n a ‚Üí z-act (zpred n) a == (ginv a * z-act n a)
  act-zpred n a =
    begin
      z-act (zpred n) a  ==‚ü® inv (lunit (z-act (zpred n) a)) ‚ü©
      e * z-act (zpred n) a  ==‚ü® ap (Œª section ‚Üí _*_ section (z-act (zpred n) a)) (inv (grinv a)) ‚ü©
      (ginv a * a) * z-act (zpred n) a  ==‚ü® inv (assoc _ a _) ‚ü©
      ginv a * (a * z-act (zpred n) a)  ==‚ü® ap (Œª section ‚Üí _*_ (ginv a) section) (inv (act-zsucc (zpred n) a)) ‚ü©
      ginv a * z-act (zsucc (zpred n)) a ==‚ü® ap (Œª u ‚Üí (ginv a * (z-act u a))) (zsuccpred-id n) ‚ü©
      ginv a * z-act n a
    ‚àé

  z-act+ : ‚àÄ n m a ‚Üí z-act (n +·∂ª m) a == (z-act n a * z-act m a)
  z-act+ zer m a = inv (lunit (z-act m a))
  z-act+ (pos zero) m a = act-zsucc m a
  z-act+ (pos (succ x)) m a =
    begin
      z-act (zsucc (pos x +·∂ª m)) a        ==‚ü® act-zsucc (pos x +·∂ª m) a ‚ü©
      a * z-act (pos x +·∂ª m) a            ==‚ü® ap (Œª s ‚Üí a * s) (z-act+ (pos x) m a) ‚ü©
      a * (z-act (pos x) a * z-act m a)   ==‚ü® assoc a (z-act (pos x) a) (z-act m a) ‚ü©
      (a * z-act (pos x) a) * z-act m a   ==‚ü® ap (_* z-act m a) (inv (act-zsucc (pos x) a)) ‚ü©
      (z-act (pos (succ x)) a) * z-act m a
    ‚àé
  z-act+ (neg zero) m a = act-zpred m a
  z-act+ (neg (succ x)) m a =
    begin
      z-act (zpred (neg x +·∂ª m)) a             ==‚ü® act-zpred (neg x +·∂ª m) a ‚ü©
      ginv a * z-act (neg x +·∂ª m) a            ==‚ü® ap (Œª section ‚Üí _*_ (ginv a) section) (z-act+ (neg x) m a) ‚ü©
      ginv a * (z-act (neg x) a * z-act m a)  ==‚ü® assoc (ginv a) (z-act (neg x) a) (z-act m a) ‚ü©
      (ginv a * z-act (neg x) a) * z-act m a  ==‚ü® inv (ap (Œª s ‚Üí s * (z-act m a)) (act-zpred (neg x) a)) ‚ü©
      z-act (neg (succ x)) a * z-act m a
    ‚àé

open IntegerAction public
\end{code}

## Higher inductive types

### Interval

Interval. An interval is defined by taking two points (two elements) and a path
between them (an element of the equality type). The path is nontrivial.

\begin{code}
module Interval where

  private
    -- The interval is defined as a type with a nontrivial equality
    -- between its two elements.
    data !I : Type‚ÇÄ where
      !Izero : !I
      !Ione : !I

  I : Type‚ÇÄ
  I = !I

  Izero : I
  Izero = !Izero

  Ione : I
  Ione = !Ione

  postulate
    seg : Izero == Ione

  -- Recursion principle on points.
  I-rec : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
        ‚Üí (a b : A)
        ‚Üí (p : a == b)
        --------------
        ‚Üí (I ‚Üí A)
  I-rec a _ _ !Izero = a
  I-rec _ b _ !Ione  = b

  -- Recursion principle on paths.
  postulate
    I-Œ≤rec : ‚àÄ {‚Ñì}
      ‚Üí (A : Type ‚Ñì)
      ‚Üí (a b : A)
      ‚Üí (p : a == b)
      ---------------------------
      ‚Üí ap (I-rec a b p) seg == p

open Interval public
\end{code}

### Circle

The circle type is constructed by postulating a type with
a single element (base) and a nontrivial path (loop).

\begin{code}
module Circle where

  private
    data !S¬π : Type‚ÇÄ where
      !base : !S¬π

  S¬π : Type‚ÇÄ
  S¬π = !S¬π

  base : S¬π
  base = !base

  -- Nontrivial path on the circle.
  postulate
    loop : base == base

  -- Recursion principle on points
  S¬π-rec : ‚àÄ {‚Ñì}
         ‚Üí (A : Type ‚Ñì)
         ‚Üí (a : A)
         ‚Üí (p : a == a)
         --------------
         ‚Üí (S¬π ‚Üí A)
  S¬π-rec A a p !base = a

  -- Recursion principle on paths
  postulate
    S¬π-Œ≤rec : ‚àÄ {‚Ñì} (A : Type ‚Ñì)
            ‚Üí (a : A)
            ‚Üí (p : a == a)
            ------------------------------
            ‚Üí ap (S¬π-rec A a p) loop == p

  -- Induction principle on points
  S¬π-ind : ‚àÄ {‚Ñì} (P : S¬π ‚Üí Type ‚Ñì)
         ‚Üí (x : P base)
         ‚Üí (x == x [ P ‚Üì loop ])
         --------------------------
         ‚Üí ((t : S¬π) ‚Üí P t)
  S¬π-ind P x p !base = x

  -- Induction principle on paths
  postulate
    S¬π-Œ≤ind : ‚àÄ {‚Ñì} (P : S¬π ‚Üí Type ‚Ñì)
            ‚Üí (x : P base)
            ‚Üí (p : x == x [ P ‚Üì loop ])
            -------------------------------
            ‚Üí apd (S¬π-ind P x p) loop == p

\end{code}


### Suspension

\begin{code}
module Suspension where

  module S where

  private
    data Susp‚Çö {‚Ñì} (A : Type ‚Ñì) : Type ‚Ñì where
      N‚Çö : Susp‚Çö A
      S‚Çö : Susp‚Çö A

    data Susp‚Çì {‚Ñì} (A : Type ‚Ñì) : Type ‚Ñì where
      mkSusp : Susp‚Çö A ‚Üí (ùüô ‚Üí ùüô) ‚Üí Susp‚Çì A

  Susp = Susp‚Çì

  -- point-constructors
  North : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí Susp A
  North = mkSusp N‚Çö _

  South : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí Susp A
  South = mkSusp S‚Çö _

  -- path-constructors
  postulate
    merid : ‚àÄ {‚Ñì} {A : Type ‚Ñì}
          ‚Üí A
          ‚Üí Path {‚Ñì}{Susp A} North South

  -- Recursion principle on points
  Susp-rec : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢}{C : Type ‚Ñì‚±º}
           ‚Üí (c‚Çô c‚Çõ  : C)
           ‚Üí (merid' : A ‚Üí c‚Çô == c‚Çõ)
           ------------------------
           ‚Üí (Susp A ‚Üí C)
  Susp-rec c‚Çô _ _ (mkSusp N‚Çö _) = c‚Çô
  Susp-rec _ c‚Çõ _ (mkSusp S‚Çö _) = c‚Çõ

  -- Recursion principle on paths
  postulate
    Susp-Œ≤rec : ‚àÄ {‚Ñì·µ¢ ‚Ñì‚±º} {A : Type ‚Ñì·µ¢}{C : Type ‚Ñì‚±º}
              ‚Üí {c‚Çô c‚Çõ : C} {mer : A ‚Üí c‚Çô == c‚Çõ}
              ‚Üí {a : A}
              -------------------------------------------
              ‚Üí ap (Susp-rec c‚Çô c‚Çõ mer) (merid a) == mer a

  -- Induction principle on points
  Susp-ind : ‚àÄ {‚Ñì} {A : Type ‚Ñì} (C : Susp A ‚Üí Type ‚Ñì)
              ‚Üí (N' : C North)
              ‚Üí (S' : C South)
              ‚Üí (merid' : (x : A) ‚Üí N' == S' [ C ‚Üì (merid x) ])
              --------------------------------------------------
              ‚Üí ((x : Susp A) ‚Üí C x)

  Susp-ind _ N' S' _ (mkSusp N‚Çö _) = N'
  Susp-ind _ N' S' _ (mkSusp S‚Çö _) = S'

  -- Induction principle on paths
  postulate
    Susp-Œ≤ind : ‚àÄ {‚Ñì} {A : Type ‚Ñì} (C : Susp A ‚Üí Type ‚Ñì)
              ‚Üí (N' : C North)
              ‚Üí (S' : C South)
              ‚Üí (merid' : (x : A) ‚Üí N' == S' [ C ‚Üì (merid x)]) {x : A}
              --------------------------------------------------------
              ‚Üí apd (Susp-ind C N' S' merid') (merid x) == merid' x

open Suspension
\end{code}

## Fundamental group

Definition of the fundamental group of a type.
Let a:A be one point of the type. The fundamental group on a is the
group given by proofs of the equality (a=a).

\begin{code}
module FundamentalGroup where

  -- Definition of the fundamental group.
  Œ© : ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí (a : A) ‚Üí Type ‚Ñì
  Œ© A a = (a == a)

  -- Its group structure.
  Œ©-st : ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí (a : A) ‚Üí GroupStructure (Œ© A a)
  Œ©-st A a = group-structure _¬∑_ (refl a)
    (Œª a ‚Üí inv (¬∑-lunit a)) (Œª a ‚Üí inv (¬∑-runit a))
    (Œª x y z ‚Üí inv (¬∑-assoc x y z))
    inv ¬∑-rinv ¬∑-linv

  Œ©-gr : ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí (a : A) ‚Üí Group {‚Ñì}
  Œ©-gr A a = group (a == a) (Œ©-st A a)

  Œ©-st-r : ‚àÄ {‚Ñì} (A : Type ‚Ñì) ‚Üí (a : A) ‚Üí GroupStructure (Œ© A a)
  Œ©-st-r A a = group-structure (Œª x y ‚Üí y ¬∑ x) (refl a)
    (Œª a ‚Üí inv (¬∑-runit a)) (Œª a ‚Üí inv (¬∑-lunit a))
    (Œª x y z ‚Üí ¬∑-assoc z y x)
    inv ¬∑-linv ¬∑-rinv
open FundamentalGroup public
\end{code}

### Circle fundamental group

\begin{code}
module FundGroupCircle where
  open Circle
  -- Winds a loop n times on the circle.
  loops : ‚Ñ§ ‚Üí Œ© S¬π base
  loops n = z-act (Œ©-st S¬π base) n loop

  private
  -- Uses univalence to unwind a path over the integers.
    code : S¬π ‚Üí Type‚ÇÄ
    code = S¬π-rec Type‚ÇÄ ‚Ñ§ (ua zequiv-succ)

  tcode-succ : (n : ‚Ñ§) ‚Üí transport code loop n == zsucc n
  tcode-succ n =
    begin
      transport code loop n ==‚ü® refl _ ‚ü©
      transport ((Œª a ‚Üí a) ‚àò code) loop n ==‚ü® transport-family loop n ‚ü©
      transport (Œª a ‚Üí a) (ap code loop) n ==‚ü® ap (Œª u ‚Üí transport (Œª a ‚Üí a) u n) (S¬π-Œ≤rec _ ‚Ñ§ (ua zequiv-succ)) ‚ü©
      transport (Œª a ‚Üí a) (ua zequiv-succ) n ==‚ü® ap (Œª e ‚Üí (lemap e) n) (ua-Œ≤ zequiv-succ) ‚ü©
      zsucc n
    ‚àé

  tcode-pred : (n : ‚Ñ§) ‚Üí transport code (inv loop) n == zpred n
  tcode-pred n =
    begin
      transport code (inv loop) n
        ==‚ü® refl _ ‚ü©
      transport ((Œª a ‚Üí a) ‚àò code) (inv loop) n
        ==‚ü® transport-family (inv loop) n ‚ü©
      transport (Œª a ‚Üí a) (ap code (inv loop)) n
        ==‚ü® ap (Œª u ‚Üí transport (Œª a ‚Üí a) u n) (ap-inv code loop) ‚ü©
      transport (Œª a ‚Üí a) (inv (ap code loop)) n
        ==‚ü® ap (Œª u ‚Üí transport (Œª a ‚Üí a) (inv u) n) (S¬π-Œ≤rec _ ‚Ñ§ (ua zequiv-succ)) ‚ü©
      transport (Œª a ‚Üí a) (inv (ua zequiv-succ)) n
        ==‚ü® ap (Œª u ‚Üí transport (Œª a ‚Üí a) u n) (inv (ua-inv zequiv-succ)) ‚ü©
      transport (Œª a ‚Üí a) (ua (invEqv zequiv-succ)) n
        ==‚ü® ap (Œª e ‚Üí (lemap e) n) ((ua-Œ≤ (invEqv zequiv-succ))) ‚ü©
      zpred n
    ‚àé

  private
    encode : (x : S¬π) ‚Üí (base == x) ‚Üí code x
    encode x p = transport code p zer

    decode : (x : S¬π) ‚Üí code x ‚Üí (base == x)
    decode = S¬π-ind (Œª x ‚Üí (code x ‚Üí (base == x))) loops (
      begin
        transport (Œª x ‚Üí code x ‚Üí base == x) loop loops
          ==‚ü® transport-fun loop loops ‚ü©
        transport (Œª x ‚Üí base == x) loop ‚àò (loops ‚àò transport code (inv loop))
          ==‚ü® ap (Œª u ‚Üí u ‚àò (loops ‚àò transport code (inv loop))) (funext Œª p ‚Üí transport-concat-r loop p) ‚ü©
        (_¬∑ loop) ‚àò (loops ‚àò transport code (inv loop))
          ==‚ü® ap (Œª u ‚Üí (_¬∑ loop) ‚àò (loops ‚àò u)) (funext tcode-pred) ‚ü©
        (_¬∑ loop) ‚àò (loops ‚àò zpred)
          ==‚ü® funext lemma ‚ü©
        loops
      ‚àé)
      where
        lemma : (n : ‚Ñ§) ‚Üí ((_¬∑ loop) ‚àò (loops ‚àò zpred)) n == loops n
        lemma zer            = ¬∑-linv loop
        lemma (pos zero)     = refl _
        lemma (pos (succ x)) = refl _
        lemma (neg zero) =
          ¬∑-assoc (inv loop) (inv loop) loop ¬∑
          ap (inv loop ¬∑_) (¬∑-linv loop) ¬∑
          inv (¬∑-runit (inv _))
        lemma (neg (succ x)) =
          ¬∑-assoc (loops (neg x) ¬∑ inv loop) _ loop ¬∑
          ap ((loops (neg x) ¬∑ (inv loop)) ¬∑_) (¬∑-linv loop) ¬∑
          inv (¬∑-runit _)

    decode-encode : (x : S¬π) ‚Üí (p : base == x) ‚Üí decode x (encode x p) == p
    decode-encode .base idp = refl (refl base)

    encode-decode : (x : S¬π) ‚Üí (c : code x) ‚Üí encode x (decode x c) == c
    encode-decode x = S¬π-ind
        ((Œª y ‚Üí (c : code y) ‚Üí encode y (decode y c) == c))
        lemma (funext Œª _ ‚Üí z-isSet _ _ _ _) x
      where
        lemma : (n : ‚Ñ§) ‚Üí encode base (loops n) == n
        lemma zer = refl zer
        lemma (pos 0) = tcode-succ zer
        lemma (pos (succ n)) =
          inv (transport-comp-h (loops (pos n)) loop zer) ¬∑
          ap (transport code loop) (lemma (pos n)) ¬∑
          tcode-succ _
        lemma (neg zero) = tcode-pred zer
        lemma (neg (succ n)) =
          inv (transport-comp-h (loops (neg n)) (inv loop) zer) ¬∑
          ap (transport code (inv loop)) (lemma (neg n)) ¬∑
          tcode-pred _

  -- Creates an equivalence between paths and encodings.
  equiv-family : (x : S¬π) ‚Üí (base == x) ‚âÉ code x
  equiv-family x = qinv-‚âÉ (encode x) (decode x , (encode-decode x , decode-encode x))


  -- The fundamental group of the circle is the integers.  In this
  -- proof, univalence is crucial. The next lemma will prove that the
  -- equivalence in fact preserves the group structure.
  fundamental-group-of-the-circle : Œ© S¬π base ‚âÉ ‚Ñ§
  fundamental-group-of-the-circle = equiv-family base

  preserves-composition : ‚àÄ n m ‚Üí loops (n +·∂ª m) == loops n ¬∑ loops m
  preserves-composition n m = z-act+ (Œ©-st S¬π base) n m loop
\end{code}

## Agda references

We based on the following Agda libraries.

{: .links}

  - (Mostly all base code at the beginning was taken from) basic homotopy type theory in Agda: [agda-hott](https://mroman42.github.io/ctlc/agda-hott/Total.html).
  - Higher Inductive types in `hott-agda` from https://github.com/dlicata335/hott-agda/


  <div class="cited-references" markdown="1">
  <ol class="bibliography"><li><span id="hottbook">Univalent Foundations Program, T. (2013). <i>Homotopy Type Theory: Univalent Foundations of Mathematics</i>. Retrieved from http://saunders.phil.cmu.edu/book/hott-online.pdf</span></li></ol>
  </div>


  
  <div class="citation">
  <h2> Citation </h2>
  If you want to cite the content of this post,
  we suggest to use the following latex bibtex entry.
  This is generated automatically.

  <br/>
  <br/>
  <pre class="bibtex"
       data-bibtextag =""
       data-bibtexauthors =""
       data-year ="2018"
       data-lastchecked ="2018-09-21"
       data-originalyear ="2018-07-06"
       data-title ="Mini HoTT library in Agda"
       data-url ="http://jonaprieto.github.io/assets/png-images/2018-07-06-mini-hott.lagda"
  ></pre>
  </div>
  

</div>







      </div>
      
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
<script src="/assets/jquery.min.js"></script>




<!-- Script which renders TeX using tex.s2cms.ru -->
<script src="//tex.s2cms.ru/latex.js"></script>
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "&zwnj;$$" + tex + "$$&zwnj;";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<p class=\"equation\">" +
                 "$$" + tex + "$$" +
                "</p>";
     });
</script>


<script type="text/javascript">
WebFontConfig = {
 google: { families: [ 'PT+Serif:400,700,400italic:latin', 'PT+Sans:400:latin' ] }
};
(function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js';
      wf.async = true;
      s.parentNode.insertBefore(wf, s);
   })(document);
</script>


<!-- FOLDABLE  -->
<script type="text/javascript">
 $('pre.foldable').each(function(){
     var lineHeight = parseFloat($(this).css('line-height'));
     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     var until = parseFloat($(this).attr('until'));
     if ( isNaN(until) ) { until= 1; }
     if ( until <= 0 ){
       $(this).hide();
     }
     else{
       var newHeight = ((1.3 * until) + 1.0) + "rem";
       //                               ^^^----------- for the padding
       //                ^^-- line-height

       // console.log('afuera-until: ', until);
       // console.log('afuera-newheight: ', newHeight );
       $(this).css("padding", "0.5rem 1rem");
       $(this).css("overflow", "hidden");
       $(this).css("height", newHeight);
       $(this).attr("original", "false");

       $(this).click(function(){

         // console.log('dentro-original: ', $(this).attr('original') );
         // console.log('dentro-newheight: ', newHeight );

         if ( $(this).attr('original') == "true" ) {
           $(this).css("overflow", "hidden");
           $(this).css("height", newHeight);
           $(this).attr("original", "false");
           $(this).css("padding", "0.5rem 1rem");
           plus.show();
         }
         else {
           $(this).height('auto');
           $(this).attr("original", "true");
           plus.hide();
         }
       });
     }
 });
</script>






<script type="text/javascript">
  if ( $('div').hasClass('cited-references') ){
    $('.cited-references').append( $('.references').html() );
    $('.references').hide();
    $(".cited-references").prepend("<h2 id='refs'>References</h2>");
    $(".toc nav>ul").append("<li><a href='#refs'>References</a></li>");
  }
</script>



<script type="text/javascript">
var pre, title, id, tag, url, coauthor, year, lastchecked, originalyear;

$('.citation').hide();
$('.citation pre').each(function(){

    var pre           = $(this);
    var title         = $(this).data('title');
    var id            = $(this).data('url');
    var year          = $(this).data('year');
    var lastchecked   = $(this).data('lastchecked');
    var originalyear  = $(this).data('originalyear');
    var url           = $(this).data('url');

    var bibtextag     = $(this).data('bibtextag');
    var bibtexauthors = $(this).data('bibtexauthors');

    if (bibtexauthors == ""){
      bibtexauthors = "Prieto-Cubides, Jonathan";
    }

    pre.append(
    "@online{ " + bibtextag + ",\n" +
    "  author  = { " + bibtexauthors +" },\n" +
    "  title   = { " + title + " },\n" +
    "  url     = { \\url{" + url   + "} }\n" +
    "  year    = { " + year  + " }\n" +
    "  lastchecked  = { " + lastchecked  + " }\n" +
    "  originalyear = { " + originalyear  + " }\n" +
    "}\n"
    );
  });

$('.citation').show();
</script>




    <script>
      (function(document) {
        var toggle   = document.querySelector('.sidebar-toggle');
        var sidebar  = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>

    
    <script src="/assets/galleryjs/lightgallery.js"></script>

    <script src="/assets/galleryjs/lg-thumbnail.min.js"></script>
    <script src="/assets/galleryjs/lg-fullscreen.min.js"></script>

    <script  type="text/javascript">
      $(document).ready(function() {
        $('.post img').wrap(function(){
          return "<div class='gallery' data-src='" + $( this ).attr("src") + "'></div>";
        });

        lightGallery(document.querySelector('.post'),
          { selector     : ".gallery"
          // , mode         : 'slide'
          , thumbnail    : true
          , animateThumb: false
          , closable     : true
          , counter      : true
          , enableTouch  : true
          , enableDrag   : true
          , showThumbByDefault   : false
          , thumbWidth           : 90
          , thumbMargin          : 5,
          });
      });
    </script>
    
  </body>
</html>
